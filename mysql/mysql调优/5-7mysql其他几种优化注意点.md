### MySQL 优化注意事项

#### 日期：2024年8月16日
#### 时间：10:34

**只取出需要的列，避免使用 `SELECT *`**

- 如果取出的列过多，传输给客户端的数据量会增大，浪费网络带宽。
- 若在排序时输出过多的列，可能会导致内存使用增加（出现 `Using filesort`）。
- 输出过多的列还可能影响查询优化器的选择，从而改变执行计划。

**漫查询优化思路及案例**

- **仅使用最有效的过滤条件**
  - **案例**: 使用 `sakila.film` 表中的 `film_id` 和 `title` 字段作为例子。假设我们需要找到所有标题包含 "ACADEMY" 的电影，我们可以使用 `WHERE title LIKE '%ACADEMY%'`，但是如果我们知道 `title` 已经有索引，而 `film_id` 是主键（通常也是索引），那么我们可以通过使用 `WHERE film_id IN (SELECT film_id FROM sakila.film WHERE title LIKE '%ACADEMY%')` 来进一步筛选结果，以减少扫描行数。
  - **结论**: 不是条件越多越好，应该选择最有效的过滤条件。

- **索引选择**
  - 当多个条件都有索引时，MySQL 会选择最有效的索引来使用。
  - **案例**: 假设 `sakila.film` 表中 `film_id`, `title` 和 `release_year` 都有索引。如果我们要找出所有2006年发布的、标题包含 "ACADEMY" 的电影，可以使用 `WHERE release_year = 2006 AND title LIKE '%ACADEMY%'`。在这种情况下，MySQL 会根据 `key_len` 的长度来选择使用 `release_year` 和 `title` 的组合索引。
  - **结论**: 选择 `key_len` 最短的索引，通常是最有效的方法。

**慢查询优化思路及案例**

- **尽可能在索引中完成排序**
  - **案例**: 在 `sakila.actor` 表中，如果我们需要按 `first_name` 排序所有演员的信息，可以创建一个 `first_name` 的索引，这样就可以通过索引完成排序，不需要额外的磁盘 I/O。
  - **SQL 示例**: `SELECT actor_id, first_name, last_name FROM sakila.actor ORDER BY first_name;`
  - **结论**: 对 `ORDER BY` 后的字段创建索引可以提高排序效率，避免使用临时表进行排序。

- **避免使用临时文件排序**
  - 如果没有适当的索引支持排序操作，MySQL 可能会创建一个临时表来排序数据，这会导致磁盘 I/O 操作。
  - **案例**: 如果上面的查询没有为 `first_name` 创建索引，那么 MySQL 将会使用临时文件来完成排序操作，从而降低性能。
  - **结论**: 确保对需要排序的字段有合适的索引可以避免物理 I/O。

---

以上是对您的笔记进行了修正和补充，并加入了一些具体的示例来帮助理解每个概念。希望这对您的学习有所帮助！如果您还需要更详细的解释或有其他疑问，请随时告诉我。