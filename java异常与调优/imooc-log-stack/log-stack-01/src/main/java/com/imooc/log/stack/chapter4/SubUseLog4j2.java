//package com.imooc.log.stack.chapter4;
//
///**
// * <h1>子类使用 getClass 不需要修改代码</h1>
// * */
//public class SubUseLog4j2 extends UseLog4j2 {
//
//    private void printLog() {
//        logger3.info("print log in sub");
//    }
//}



这段代码展示了如何在 Java 子类中重用父类的日志记录逻辑，并且不需要修改父类的代码。下面是对代码的详细解析以及它所体现的一些调优思想。

### 代码解析

1. **继承关系**:
   - `SubUseLog4j2` 类继承自 `UseLog4j2` 类。
   - 这意味着 `SubUseLog4j2` 类可以访问 `UseLog4j2` 类中的成员变量和方法。

2. **日志记录**:
   - `UseLog4j2` 类中有一个 `logger3` 成员变量，它是 `org.apache.logging.log4j.Logger` 类型的对象。
   - `SubUseLog4j2` 类中的 `printLog` 方法使用了 `logger3` 来记录日志信息。

3. **日志绑定**:
   - `UseLog4j2` 类中 `logger3` 的初始化通常是通过 `org.apache.logging.log4j.LogManager` 的 `getLogger` 方法完成的。
   - 由于 `SubUseLog4j2` 类继承了 `UseLog4j2` 类，因此可以直接使用 `logger3` 而不需要额外的初始化。

### 调优思想

1. **代码复用**:
   - 通过继承，子类可以重用父类中的日志记录逻辑，而不需要重复定义日志记录器。
   - 这有助于减少代码重复，并提高代码的可维护性。

2. **避免硬编码**:
   - 在父类中定义日志记录器，子类可以直接使用，而不需要修改或硬编码日志记录器的创建逻辑。
   - 这有助于保持日志配置的一致性，并简化子类的实现。

3. **可扩展性**:
   - 通过继承，可以轻松地添加新的子类，并重用父类中的日志记录逻辑。
   - 这有助于提高系统的可扩展性，因为可以方便地添加新的功能或行为，而不会破坏现有的日志记录机制。

4. **减少耦合度**:
   - 通过将日志记录逻辑封装在父类中，子类可以专注于自己的功能实现，而不需要关心日志记录的细节。
   - 这有助于降低子类与日志框架之间的耦合度。

5. **配置驱动**:
   - 日志记录器的配置通常是在外部配置文件中完成的，而不是硬编码在程序中。
   - 这样可以在不修改代码的情况下调整日志级别，有助于在不同的环境中调整日志输出的详细程度。

### 实际应用场景

在实际应用中，这种继承和日志记录逻辑的复用适用于以下场景：
- 当你需要在多个类之间共享日志记录逻辑时。
- 当你需要确保日志记录逻辑的一致性时。
- 当你需要在不修改现有代码的情况下添加新的子类时。

总结来说，这段代码示例通过展示如何在子类中重用父类的日志记录逻辑，体现了代码复用、避免硬编码、可扩展性、减少耦合度和配置驱动等调优思想。这对于提高代码的可维护性、一致性和扩展性非常重要。