306-【Java面试】SpringBoot如何解决跨域问题？-480P 清晰-AVC

	Spring book如何解决跨域的问题。今天啊正好有空给大家分析一下这个问题的底层逻辑以及面试的时候的一个回答技巧。关于文字版本的回答，我整理到了一个50万字的面试文档里面，有需要的小伙伴可以在我的评论区的制定中去领取。跨域指的是浏览器在执行网页中的JavaScript代码的时候，由于浏览器的同源策略的一个限制，只能访问同源的资源，而不能访问其他人的资源。比如像这样一个情况就体现了跨越的问题，而解决跨越问题的方法就是在不破坏同源策略的情况下，能够安全的实现数据的共享和交互。常见的解决跨域问题的方法呢有两种，一种是杰森p另外一个是 cors其中 cois是一种在服务器后端去解决跨域的方案。它的工作原理特别简单，如果一个网站需要访问另外一个网站的资源，浏览器首先会发送一个op的一个请求，根据服务器端返回的access CTRL o这样一个头的信息来决定是否允许跨域的一个访问行为。所以我们只需要在服务器端配置这样一个属性，并配置允许哪些域名啊知识话语请求就好了，在springboard中提供了两种配置access CTRL的属性的一个方法来解决话语问题。
	第一种通过这样一个注解去指定允许哪些orange允许话语。第二种使用web mvc康菲格接口来重写add course map这样一个方法来配置允许跨域的请求员。以上就是解决这个问题的方法。



304-【Java面试】Java初级必问题：Thread和Runnable区别是什么？-480P 清晰-AVC
Hello大家好，我是麦克。一个工作了14年的Java程序员和创业者，昨天呢一个工作了一年的粉丝出去面试，遇到这样一个问题，他说thread和roundtable它有什么区别？其实呢这个问题啊是非常简单的，但是如果能够去按照高手的回答思路去说明，呢效果会更好。另外我花了一个多星期的时间，啊把往期的高手回答整理成了一个10万字的文档，如果你想获取的话，可以在我的主页加v去领取。下面我们看看普通人和高手对于这样一个问题的回答，普通的回答，呃 thread和run的区别，呢我认为有两个，吧第一个是呃斯瑞德和罗尼泊它是就是斯瑞德它是一个类，嘛然后罗尼泊是一个接口。然后第二个是呃因为在Java里面，它是说我我的接口是可以实现就多重实现，嘛但是内存能单一继承。嘛所以我们在使用的时候，如果有有有那种就是呃已经有有有那种类的继承的情况下，我们就只能实现run这个接口了。高手的回答。好的，我认为three和roundtable接口的区别呢有4个，第一个 three的是一个类，啊 Roundtable呢是一个接口，由于在Java云里面，呢它的一个继承特性啊接口可以支持多继承而类，呢只能实现单一继承。
	所以啊如果在已经存在竞争关系的nei里面要去实现县城的话，我们只能去实现Lomba接口。第二个roundtable呢表示一个现成的顶级接口，而Siri的类呢其实是实现了round这样一个接口，我们在使用surname内或者实现round接口的时候都需要去实现run方法。第三个，站在面向对象这样一个思想来说，让内部呢相当于是一个任务，而three的才是真正的一个处理线程，所以我们只需要去用roundtable去定义一个具体的任务，然后交给Siri去处理就好了，这样就达到了一个松耦合的一个设计目的。第四个啊接口表示一种规范或者标准，而实现内呢表示对这个规范或者标准的实现。所以站在现实的角度来说，three的才是真正意义上的线程实现。而罗内伯呢表示县城要去执行的一个任务，所以我们可以发现在现实池里面要去提交一个任务的时候，它传递的类型是一个roundtable。总的来说啊在我看来，斯瑞的只是实现罗拉姆这个接口，并且做了现成的实现的一个扩展，所以这两者我认为没有什么可比性。
	以上就是我对这个问题的理解。在我看来啊有些问题其实真的是为了面试而面试，可能这个问题本身就毫无考察价值，啊但是不专业的面试官呢确实很多，所以呢我们只能做一些充分的准备去应对各种各样奇葩的问题。好的，本期的普通人vs高手的面试系列视频啊就要到结束了，喜欢我作品的小伙伴记得点赞收藏加关注，我是麦克。咱们下一期再见。
307-【Java面试】阿里二面，什么是微服务？99%的人回答不上来！-480P 清晰-AVC
	什么是微服务？说一下你对微服的理解。Hello大家好，我是麦克。一个工作了14年的Java程序员，今天给大家分享一下面试过程中遇到这个问题，我们应该怎么去回答这个问题的文字版本，我整理到了一个50万字的面试文档里面，有需要的小伙伴可以在评论区的置顶中去领取。一般面试过程中问这个问题有两个目的，第一，是否真正理解微服务架构的特点和概念。第二，是否具备系统设计和架构能力，能否根据具体的业务场景和需求去设计合适的微服务架构。我认为这种问题千万不要通过死记硬背来回答，这样容易导致回答思路比较混乱。建议可以先理解，然后再总结成自己的语言去回答，把一些关键点回答正确，基本上就差不多了。微服务呢是一种架构风格，我们可以把应用程序划分为一组小型的松散耦合的服务，每个服务都运行在自己的进程里面，并通过轻量级的通信机制来进行通信。每个服务都可以独立部署，独立扩展、独立更新，从而提高了应用程序的可伸缩性、可维护性和可测试性。由于微幅呢是属于分布式架构下的一种针对应用架构的一种设计风格，所以我们会面临到分布式架构下的一些服务治理的复杂问题，因此是spring官方提供了一套spring cloud解决方案，帮助我们快速实现微服务的技术方案的落地。
	以上就是我对微服的理解，如果你喜欢这个作品，记得点赞和关注，我是麦克，我们下期再见。
305-【Java面试】网易一面：binlog和redolog有什么区别？-480P 清晰-AVC

	前两天一个工作了三年的同学好不容易约到一个面试，却被这样一个问题给难倒。问题是冰log和ideologue有什么区别？关于这个问题的回答，呀我把它整理到了40万字的面试文档里面，大家可以在我的评论区置顶中去领取。这个问题啊其实比较简单，但凡稍微了解过max口数据库都能够很容易回答出来。一般考察1~3年的程序员，所以对于这个工作年限的小伙伴要注意了解他们的原理。首先啊并log和绿地log呢都是max里面用来记录数据库数据变更操作的日志，其中并log主要用来做数据备份，数据恢复和数据同步。大家初步接触这个概念应该是在max的主从数据同步的场景里面，master节点的数据变更会写入到bealock中，然后在把bealock的数据通过网络传输给slave节点，实现数据同步，而video log主要是在max口数据库事务的acid特性里面，用来保证数据的持久化特性，但是其实它还有很多作用，比如数据库崩溃的时候，可以通过radio log来恢复未完成的数据，保证数据的完整性，还可以通过合理的配置video log的大小和数量，去优化Mia Siek的性能，并log和绿地log的区别其实有很多，我可以简单总结三个点，一使用场景不同，b log主要是用来做数据备份，数据恢复以及主从集群的数据同步。
	Redo log主要用来实现mesko数据库的事务恢复，保证事物的act特性，当数据库出现崩溃的时候，绿地log可以把未提交的事物回滚，把乙提交的事物进行持久化，从而保证数据的一致性和持久性。第二记录信息不同，冰log是记录数据库的逻辑变化，它提供了三种日格式，分别是statement、Lowe以及makes。Radiolog呢记录的是物理的变化，也就是数据页的变化的结果。第三记录的时机不同，冰log是在执行CK语句的时候，在主线程中生成逻辑变化写入了磁盘里面，所以它是语句级别的记录方式，而redo log是在indie存储引擎层面的操作，他是在mak后台线程中去生成，并且写入磁盘磁盘中的，所以它是事物级别的记录方式，一个事物操作完成以后才会被写入到radio log里面。以上就是我的理解。



310-【Java面试】蚂蚁金服二面：什么是拆包和粘包？怎么解决？-480P 清晰-AVC
	什么是菜包和棉包？该怎么解决？这个啊是一个工作三年的粉丝提交给我的面试整体，今天啊给大家分享一下这个问题的底层原理以及回答思路。文字版本的回答，我整理到了一个50万字的面试文档里面，有需要的小伙伴可以在我的评论区的置顶中去领取。拆包和粘包是在网络编程中比较常见的现象，因为TCP协议底层是面向流的传输，所以数据在传输的过程中会被分割成一个一个的数据包。接收端在接收数据的时候需要重新组装数据包，但是 TCP协议不保证数据包与应用层的数据交互一一对应，所以就有可能会造成数据不完整的问题。因此候选人在回答这个问题之前，必须要了解这个问题的发生背景，否则啊回答不到点上就会错过这次机会。拆包是指把一个完整的数据包拆分成多个小包进行发送，而接收端可能无法一次性接收所有的小包，导致接收到的数据不完整，而连包指的是把多个数据包联合在一起一次性发送，而接收端可能无法正确的去区分每个数据包，导致接收到的数据出现错位或者混乱。拆包和粘包现象是TCP协议的数据传输机制导致的，所以要解决这个问题，就需要让服务器端知道如何判断一个数据包的完整性。
	因此可以采用以下几种方法，第一，在数据包中添加特殊字符或者特殊标记，来表示一个数据包的开始和结束。第二，通过制定消息协议，并在协议头中去保存数据包的长度信息，接收端可以根据这个长度来解析数据包，保证消息的完整性。最后基于定长消息，也就是说发送的消息长度是固定的，服务器端只需要按照固定长度来解析就好了。以上就是我的理解。
312-【Java最新面试题】京东一面：MVCC过程中会加锁吗？-480P 清晰-AVC
Mvcc过程中会加锁吗？昨天一个工作4年的粉丝在面试的时候呢被问到这个问题，他果断而自信的回答说不会，然后呢面试官就拒绝了他。后来啊在我给他的大厂面试指南里面看到答案以后恍然大悟，经过两年时间的整理，啊大厂面试指南已经覆盖了市面上99%以上的问题，大家可以直接去评论区的置顶中去领取。 Mvcc，机制全称叫Martin叫多版本并发控制，它是确保在高并发的情况下，多个事物读取数据的时候，布加索也可以多次读取相同的值。Mvcc在可重复读的事物隔离级别下，可以解决脏、毒、脏、血和不可重复毒等问题。我们知道mvcc呢是基于乐观锁的实现，所以很自然会想到mvcc是不枷锁的，这个问题呢也要看情况来回答。下面我们来看一下回答的建议。在mvcc中通常不需要枷锁来控制并发的访问，相反每个事物都可以读取到已提交的快照，而不需要去获取共享锁或者排他锁。在写操作的时候，mvcc会使用一种叫写实复制的技术，也就是在修改数据之前先将数据复制一份，从而创建一个新的快照。当一个事物需要修改数据的时候，mvcc会首先检查修改数据的快照版本号，是否与该事物的快车版本一致，如果一致就表示可以修改这条数据，否则这个事物需要等待其他事物完成对该数据的修改。
	另外这个事物在新坏账上的修改的结果不会影响原始数据，其他事物可以继续读取原始数据的快照，从而解决脏、毒和不可重复毒的问题。所以正是有了mvc机制，让多个事物对同一个数据进行读写的时候，不需要枷锁，也不会出现读写冲突的问题。以上就是我的理解。
313-【Java面试】高频面试题：订单超时，如何设计自动取消功能？-480P 清晰-AVC
	订单超时自动取消功能怎么去设计？最近一个工作7年的粉丝去面试，因为这个问题没有回答出来，导致错过了一个高薪的offer。因为现在很多小伙伴看到这个问题的时候，第一反应肯定是这个问题很简单，直接写在平时任务去轮选数据库，根据订单时间去找到超时的订单，把它取消就行了。那个工作青年粉丝也是这么回答结果。这种方式很明显存在几个问题，第一个是允许会存在延迟时间，也就是没有办法准时的去实现订单的取消，去释放这个订单锁定的资源。第二个是轮训数据库会给数据库造成很大的压力，如果订单表的数据量比较大的情况下，轮巡的效率如果要考虑到性能，又要去考虑到实质性，有没有更好的方法？当然有比如时间的算法，这种算法是采用了一个典型的环状速度加链表的方式去管理延迟任务，我们只需要去计算这个订单的超时时间，再把它加入到19人里面就好了。时间轮算法的唯一缺点就是无法持久化，所以我们在服务重启之后需要去重新漏的一次订单数据，确保所有订单数据都能够被准时处理。第二种我们可以利用主流的mq里面的延迟消息的功能，延迟消息的特点就是我们把消息发送到博客上以后，他并不会立刻投递，而是根据消息里面设置颜值直接去投递。
	我们只需要把新的订单计算出这个订单的超时时间，发送mq里面就好了。实际上mq里面的颜值消息的处理很多也是用的石杰伦，比如说卡夫卡里面的颜值消息也是用到了石杰伦的算法，mq这种方式啊在性能上在可扩展性上，在稳定性上都比较好，是一个比较不错的选择。好了，今天我的分享就到这里了，大家如果有更好的实践方案，可以在评论区留言，最后给大家分享一套我花了一年多时间整理的20万字的面试题，由于这是给粉丝的福利，所以只发10份，大家可以在评论区的制定中去领取。
308-【Java面试】为什么阿里巴巴强制要求使用包装类型定义属性？-480P 清晰-AVC
	为什么阿里的开发手册强制要求使用包装类型来定义属性呢？Hello大家好，我是麦克。一个工作了14年的Java程序员，又是一个开发规范性的问题，问题的本质是为什么企业强制要求使用包装类型定义属性。关于这个问题的完整回答，我整理到了一个50万字的面试文档里面，有需要的小伙伴可以在评论区的置顶中去领取，这是一个开发规范性的问题，开发规范更多的是为了后续程序的可维护性，以及避免出现一些低级错误，影响了程序的稳定。所以对于一些规模比较大的公司，对规范的定义就会更加严格和细致，所以在回答这个问题的时候，可以往包装类型的优势上去切入，从而保证自己回答的内容在面试官的预期范围内。下面我们来看一下这个问题的完整回答。我认为主要有几个方面的原因，第一默认值的问题，使用基本数据类型定义属性的时候，如果没有给属性赋予初始值，会使用默认值，比如说intel的默认值是0，而使用包装类型定义属性，如果没有给属性赋予初始值，那么属性的初始值就是那这样就可以更加清晰的去表达属性的状态。
	第二拆箱问题。在一些特定场景下，如果使用基本数据类型去定义属性，需要进行多次装箱和拆箱的操作，这个操作会带来额外的性能开销和代码的复杂度，而使用包装类型定义属性的时候，可以避免这个问题，提高代码的效率和可读性。第三，Java中的泛型只能使用对象类型，如果要在泛型编程中使用基本类型，就必须要使用对应的包装类型。最后包装类型提供了基本类型所不具备的方法和属性。比如说equals哈奇扣的舒适骏等等这样一些方法，这些方法在特定的场景中比较有用，以上就是我的理解。如果你喜欢这个作品，记得点赞和关注，我是麦克。我们下期再见。
311-【Java面试】面试突击Spring：@Conditional注解的作用是什么？-480P 清晰-AVC
	Condition的注解的作用是什么？但凡有加好开发经验的同学，这个问题应该都能够很好的回答出来。如果回答不上来，建议认真看一下这条视频，这道面试题的文字版本我已经整理到了一个20万字的面试文档里面，有需要的小伙伴可以在我的评论区去领取。Hello大家好，我是麦克菇泡科技的联合创始人， condition呢是10分4点x版本里面引入的一个注解。因为这个问题本身啊比较简单，所以考察的范围一般是工作一年到工作三年左右，考察目的啊就是去了解求职者对于spring from rock里面的注解的了解情况。作为求职者来说回答的时候不过度去解读面试官的一读，简单明了的去回答就好了。 Condition呢是spring4点x版本里面提供了注解，它的作用是给需要装载的病增加一个条件判断，只有满足条件病才需要装载到IOC容器里面。这个呢是康定性的注解的一个定义。从这个注解中我们可以了解到几个关键信息，第一个condition的注解可以修饰在类或者方法上面。
	第二个condition的注解可以接收一个或者多个实现了condition接口的类，这个呢就是condition的接口的一个定义，它提供了一个返回值为不能的match方法。根据康d系统注解本身的一个作用，啊不难猜测出它应该是用来实现并是否能够被装载的判断逻辑。康熙的注解既然是用来去判断病是否能够被装载的条件，那么意味着我们可以在病的描述逻辑上呢去增加这样一个注解。然后通过重写康d选这个接口的March方法，自定义病的装载条件，比如这样的一个使用方法，当spring解析这个配置类的时候，啊 hello service这个病是否能够被装载的IOC容器，取决于哈斯曼康迪逊里面的match方法的一个返回值，返回to才可以被装载，这就给我们并的装载过程增加了很多的灵活性。下面我们来看看高手的回答。康d选择注解的一个作用啊是为病的装载操作提供一个条件判断，只有在满足条件的情况下，spring才会把当前的病装载到IOC容器里面，而这个条件的实现是我们可以自定义去完成的，我们可以实现康d选这个接口，并且重写里面的match。
	这个方法去实现自定义的一个逻辑。所以condition的这个注解增加了病的装配的一个灵活性，在食品boot里面呢对康迪系统注解呢做了更进一步的一些扩展。比如说增加了conditional on class，看d系统on病等这样一些注解，使得我们可以在使用过程中啊不再需要去写那些条件判断的逻辑，而是可以直接根据本身的这个语义去完成对应的条件的一个装备。以上就是我的理解。这个问题啊其实很好回答，切记不要绕来绕去的去说一大堆没用的话，大家可以直接去参考高手的回答。好的，今天的视频就到这结束了。喜欢我这个作品的小伙伴记得点赞收藏加关注，我是麦克。咱们下期再见。
309-【Java面试】小米一面：线程池如何知道一个线程的任务已经执行完成？-480P 清晰-AVC
	最近啊一个小伙伴私信我一个小米的面试题，他的问题是县城池是如何知道一个县城的任务已经执行完成了。说实话这个问题确实有点刁钻，毕竟啊像很多工作5年的小伙伴，连线程池可能都没有用过。那么怎么可能回答上来呢？好了，那我们下面来看一下，普通人和高手遇到这个问题的时候，他是怎么回答呢？普通的回答。县城池如何知道一个县城的任务已经执行完成了。
	好像好像它里面有一个方法，有一个有个方法可以去实现。具体我不太清楚了。高手的回答，我会从两个方面来回答这个问题。第一个，从县城市的内部，啊当我们把一个任务丢给县城池去执行的时候，限制时会调度工作线程来执行这个任务的run方法。当run方法正常结束以后，也就意味着这个任务完成了。所以线程时钟的工作线程是通过同步调用任务的run方法，并且等待run方法返回后，再去统计任务的完成数量。第二个，如果想在限制至外部去获取现成池内部的任务执行状态，有几种方法可以实现？第一个，现成时呢提供了一个s和net的方法，可以去判断线程池的运行状态，我们可以循环去判断 its terminated方法的返回值来去了解现成的运行状态。一旦现成池的运行状态是特米net的，意味着县城之中的所有任务都已经执行完成了。但是啊想要通过这个方法去获取现成状态的前提是什么？是程序中需要主动去调用现成池的虾子档方法，在实际业务中一般不会去主动去关闭仙人池，因此呢这个方法在实用性和灵活性方面。
	第二个呢在现实中啊有一个叫Sam的方法，它提供了一个future的返回值，我们可以通过future点get方法去获得任务的执行结果。当现成池中的任务没有执行完之前，future点get方法会一直阻塞，直到任务执行结束。因此啊只要 future的方法正常返回，就意味着传入现成池的任务已经执行完成了。第三个呢我们可以引入 calm down lunch这样一个计数器。它可以通过初始化指定的一个计数器去进行倒计时。其中呢它提供了两个方法，分别是o white主色线程以及 countdown down去进行倒计时。一旦倒计时归零，呢所有被主摄在why'd方法的线程都会被释放。基于这样一个原理，啊我们可以定义一个 count当lunch对象，并且计数器为一，接着呢在现实时代码块的后面去调用 awhile方法去组设主线程，然后当传入到县城池中的任务执行完成以后，呢调用康字档方法去表示任务，执行结束，最后呢计数器归零唤醒，处于额外的方法阻塞的线程。
	第三个，基于这个问题啊我想简单总结一下，不管是线程池内部还是外部，想要知道县城是否执行结束，我们必须要获取线程执行结束后的状态，而县城本身呢是没有返回值的，所以只能通过阻塞唤醒的方式来实现 future Goette和扛子弹上去，都是这样一个原理。以上呢就是我对这个问题的回答，大家可以站在面试官的角度去看高手的回答，不难发现呢高手对于技术的基础的掌握是非常深和全面的，这也是面试官考察这一类问题的目的。因此啊麦克老师提醒大家，除了日常的crud之外，抽出部分时间去做一些技术深度和广度的学习是非常有必要的。好的，本期的普通人vs高手面试系列的视频呢就到这结束了。喜欢的朋友记得点赞，和收藏，我是麦克。一个工作了14年的Java程序员，咱们。

314-【Java面试】ReentrantLock 是如何实现锁公平和非公平性的？-480P 清晰-AVC
	什么情况？一个工作三年的程序员连这个问题都回答不上。Hello大家好，我是麦克。今天啊分享一道三年经验频率非常高的一个面试题。这个问题是与安全的log是如何实现锁的公平和非公平性？啊这个问题呢我整理成的文档，啊有需要的小伙伴可以在我的主页去加v领取。下面对这个问题呢我们来看看普通人和高手的回答，普通的回答。愿去look去实现公平锁和非公平锁。
	就我们在调用那个 Rock方法去竞争锁的时候，啊它会就如果是非公民所的话，他会直接去直接去去抢占那个锁资源。然后如果是弓皮索的话，他会去有一个判断，我就判断那个组织队列里面是不是有有些人在排队，如果有人在排队的话，他会他就不能去抢厕所，他会会加入到那个队列的的的的尾部，然后去进行等待。高手的回答。好的，我先解释一下公平和非公平这样一个概念。所以公平呢是说竞争所支援的一个县城啊严格按照请求的顺序来分配所，而非公平，呢就是说竞争所支援的一个县城呢允许插队来抢占所支援。瑞安却洛可能默认采用了非公平锁的策略来去实现锁的一个竞争。其次呢对安全洛可内部使用的aqs来实现锁资源的一个竞争，没有竞争的所支援线程呢会加入到一个aqs的同步队列里面，这个队列是一个FIFO的一个双向列表，在这样一个背景里面呢公平的实现方式，就是县城在竞争所资源的时候会判断as里面有没有等待线程，如果有就加入了队列的尾部进行等待，而非公民所的实行方式，就是不管队里面有没有现身等待，他都会先去尝试抢占锁资源。
	如果抢占不到，就会再加入到aks同步队列里面去等待。与安吉洛可和辛苦奈子都是一样，默认都是非工兵所的一个策略。之所以这么设计，啊我认为还是考虑到了性能这个方面的原因。因为一个进厕所的县城，如果按照公平的策略去进行主色等待，同时aqs再把等待队列里面的线程唤醒，这会涉及到一个内核态的切换，对性能的影响会比较大。如果是非工品所的策略，呢当前现在正好在上一个县城释放的临界点去抢占了锁，那么意味着这个线程不需要切换到内核肽，虽然对原本应该被唤醒的县城不公平，但是提升了所竞争的一个效率。以上就是我对这个问题的一个理解。这个问题呢主要是考察求职者的基础知识，别小看这样一些基础，啊在实际开发过程中，不管是对代码的稳定性，还是对性能的影响都是非常大的。这也是大场面试必然会问基础的一个原因之一。好的，本期的普通人vs高手的面试系列视频呢就到这结束了，喜欢我的作品的小伙伴记得点赞收藏加关注，啊我是麦克。一个工作了14年的Java程序员，我们下一期再见。
316-【Java面试】腾讯二面：Zookeeper如何实现分布式锁？-480P 清晰-AVC
	猪keep如何实现分布式锁。这个问题特别简单，我可以分解出至少三种回答，听完我的分解，分分钟吊打面试官，我把这个问题的分解过程和完整回答整理到了一个面试文档里面，这个文档有50万字，有需要的小伙伴可以在评论区的置顶中去领取。关于分布所这个问题，不管用什么技术，锁的本质是不变的。如果是排他所意味着在同一个时刻，只有一个县城或者京城拿到锁资源去获得访问权，所以基于这样一个点去推演猪keep怎么达到这个目的就行了。我们都知道猪keep的存储结构呢类似于一个具有层次关系的文件系统，每一个节点代表一个TV结构的数据，这节点有几个重要特性，第一，同一节点呢不能存在重复数据。第二，提供了有序节电的特性，可以根据创建的先后分配一个有序编号，这几个特性是实现分布所的关键。下面我们来看一下这个问题的回答。我们可以用到猪keep里面的有序节点来实现分布锁。具体的实验过程是，第一，在猪keep上去创建一个持久化的节点，exclusive杠rock作为锁的根结点。
	第二，每个客户端去竞争所的时候，直接在根节点下面创建一个临时有序节点，截止的名称以lock-1为前缀，自动加上猪keep生成的一个序列号。第三，在判断当前竞争所的进程，创建的节点，在所有子节点里面是否是最小的。如果是就表示获得所成功，如果不是表示有其他进程先创建这个节点，那么意味着我没有货渠道锁，那当前客户端需要监听自己在猪people上创建了节点的前一个节点的删除事件。这样的话当前面一个节点释放锁之后，那么它就会触发一个事件通知我，那么我就可以再次尝试去获取所。除了这个方案以外，还可以用猪keep里面的同一节点的微信来实现分布锁。以上就是我的理解。
319-【Java面试】蚂蚁金服二面，会员批量过期的方案怎么实现？-480P 清晰-AVC
	昨天一个工作了6年的同学去某互联网大厂面试，遇到这样一个场景问题，有一张200万数据量的会员表，每个会员都有一个长短不一的到期时间，先想在快到期之前啊去发送邮件去通知续费，那该怎么去实现呢这个问题的解决思路有很多，我把这个问题的回答整理到了40万字的面试文档里面。对于这一类的场景问题，我建议大家不要急着去回答，而是先冷静下来，想清楚面试官希望通过这个问题去了解你哪一方面的能力，以及这个问题里面有哪些陷阱。特别要注意一个点，一定要理解清楚面试官的问题，如果没有听懂可以向他确认一遍。很显然这个问题里面有几个关键词，第一两百万数据意味着数据量比较大，二每个会员都有过期时间，需要能够快速筛选出快过期的会员。很显然如果直接通过select语句去筛选，就很容易掉入坑里了，因为这里会存在一个性能问题。那接下来我们看一下相对比较合理的回答，关于这个问题呢有很多解决方法，第一种系统不主动人群，而是等用户登录系统以后触发一次检查，如果发现会员过期的时间小于设定的阈值，就触发一次弹窗提醒或者邮件提醒，这种方式规避了轮巡的问题，不会对数据库和后端应用程序造成任何压力，但缺点也比较明显。
	如果用户一直不登录，就一直无法实现会员的过期，并且也无法提前去根据运营策略来发送邮件或者续期的提醒。第二种我们可以直接使用搜索引擎，比如Zora或者elastic search，把会员表里面的会员ID和会员过期时间存储一份到搜索引擎里面，搜索引擎的优势在于大数据量的快速检索，并且具有高可扩展性和高可靠性，非常适合大规模数据的处理。第三种可以直接使用reds来实现。用户开通会员以后，在race里面存储这个会员的ID以及设置这个 ID的过期时间，然后可以使用radius里面的过期提醒功能，把这样一个配置项做一个修改，当race里面的key过期以后，会触发一个key的过期事件，我们可以在应用程序里面去监听这个事件来进行处理。第四种，可以直接使用mq里面提供的延迟队列，当用户开通会员以后，直接计算这个会员的过期时间，然后发送一个延迟消息在mq里面，一旦消息达到过去时间，消费者就可以消费这样一个消息来触发会员过期的一个提醒。以上就是我的一些回答思路，如果大家有更好的回答，欢迎在我的评论区给我留言。
317-【Java面试】阿里一面：谈一谈Mysql的二阶段提交原理？-480P 清晰-AVC
	请减速麦c口二阶段提交的原理，一个工作了7年的粉丝啊表示，之前从来不知道卖SQL里面有二阶段提交这样一个概念，然后呢就以年龄大为理由礼貌的拒绝了。这个问题在我之前整理的大成面试指南里面有一个标准的回答，大家可以在我的评论区的指点中去领取。很多粉丝在面对这个问题的时候，第一反应绝对是懵的，因为他并不知道麦西口里面哪里涉及到二技能提交。实际上如果在max开启了冰log日志的情况下，在max事务提交的时候，需要同时完成radio log和冰log的事物写入video和兵log，大家都知道一个是事务日志，另外一个是数据库变更的逻辑日志。这是两个独立的写入磁盘的动作，并且两个操作都要成功。而为了保证两个日志内容的一致性，需要用到两阶段的提交机制。麦穗口的二技能提交啊发生在radio、logo和宾logo的日志写入阶段，也就是把日志写入和日志提交拆分成两个阶段来确保radio log和宾log的写入的数据一致性。第一阶段是prepare阶段，在这个阶段中MSC我会把失误操作记录到redo log中，并标记为prepare状态。
	第二阶段是康妹的阶段，当事物提交的时候，max狗会将事物操作记录到冰log里面，然后把radio logo中的日志设置为康妹的状态，所以英斗DB在写radio logo的时候并不是一次性写完的，而是有两个阶段，prepare和康妹的这就是两阶段提交的含义，在这一个设计中，如果在写入video log之前崩溃，那么此时radio log和宾洛克中是没有数据的，那么数据是满足一致性的，如果再写入radio log，佩尔阶段立马崩溃了，那么之后会在崩溃恢复的时候，由于video中没有标记为康妹的，于是拿着radio local的事物ID去冰local去查找，此时肯定是找不到的。那么这个时候就执行回滚操作，如果在写入冰logo后立马崩溃，在恢复的时候，由于radio log中的事物，ID可以找到对应的并log，那么这个时候可以直接提交数据，通过这个方式就可以保证radio和宾log的数据一致性。以上就是我的理解。


315-【Java面试】阿里一面：Mysql为什么使用B+树作为索引结构？-480P 清晰-AVC
	一个工作了8年的粉丝啊私信我一个问题，他说这个问题是去阿里面试的时候被问到的，这个问题是买水果里面为什么要使用b加速来作为索引结构？好了，关于这个问题，呢我们看看普通人和高手的回来不断的回答。啊买c口为什么使用b加速作为索引？啊就是我我我觉得有几个原因，吧就是第一个是嗯就是b加速它的特征啊就是说相对b数来说，它的这个一呃非叶子节点是不存数据的，它除了叶子数据都存在叶子节点，那么意味着嗯那我每我的这个索引就每一个层里面能够存储的这个索引的数量是会更多。然后第二个就是说它相它它相对来说它的查询次数唉呦次数会更稳定，因为嗯还是因为说所有的数据都存在叶子节点的原因，啊因为呃如果我要在比赛书里面去做一次查询的时候，他还是最终要到那个叶子节点去获取数据对吧？但是嗯 B数不一样，b数的话就是比如说我我有可能我在第一层就查到这个数据之后返回，但是有可能我第一层查不到，需要查到第二层第三层，所以它的io次数不稳定的，所以相对于说这种情况下，那么就它它它的这个对稳定性嘛主要是稳定性这一块。
	高手的回答。关于这个问题呢我会从几个方面来回答。首先常规的数据库存储引擎一般都是采用b数或者b加速来实现所有的存储。因为b数呢是一种波入平衡数，用这种存储结构来存储大量数据的情况下，呢它的整体高度相比2345来说会矮很多。而对于数据库来说，呢所有的数据必然是存储在磁盘上的，而磁盘io的效率实际上是很低的，特别是在随机磁盘l的一个情况下效率更低，所以树的高度就能够决定磁盘io的一个次数，磁盘io次数越少，那么对于性能提升就会越大，这也是为什么采用b数作为索引存储结构的原因。但是在卖c口的一诺DB存储引擎里面，它采用的是一种增强的b数结构，也就是b加速来作为索引和数据的一个存储结构，相比较于b数的结构，啊 b加速做了几个方面的一个优化。首先第一个是b加素的所有数据都存储在叶子节点上，而非yes节点呢只会存储索引。第二个是叶子节点里面的数据是使用双向电表的方式来进行关联的，所以呢使用b加速来实现索引的一个存储结构，我认为有几个方面的一个原因。
	第一个啊 b加速的非叶子节点，不会存储数据，所以每一层能够存储的索引数量会增加，那么意味着b加数在层高相同的情况下，它存储的数据量会比b数要更多，这样的话磁盘的l次数会更少。第二个啊在max里面呢范围查询是一个比较常用的操作，而b加速的所有数据都是存在叶子节点里面，并且使用了双向电表来关联，所以在查询的时候只需要查两个节点，然后进行便利就好了。而b数需要获取所有的节点，所以毕加索在范围的查询上效率会更高一些。第三个啊在数据的检索方面，由于所有的数据都是存储在叶子节点，所以b加速的io次数会更加稳定一些。第四个因为b加速的所有数据都是存储的叶子节点，所以b加速的全局扫描能力是更强一些的，因为它只需要扫描叶子节点，但是b数需要去遍历整个数。另外基于b加速这样一个结构，如果采用自身的整齐数据作为组件，还能够更好的去避免增加数据的时候带来的叶子节点分裂，导致了大量运算的一个问题。总的来说啊我认为技术方案的选择更多的是去解决当前场景下的一些特定问题，并不一定说b加速就是最好的选择，就像芒果DB里面采用b数结构，本质上来说呢其实是关系性数据库和非关系型数据库的一个差异。
	以上就是我对这个问题的理解。对于为什么要选择某某技术的这一类问题，啊其实很好回答。只要你对这个技术本身的特性足够了解，那么自然就知道为什么要这么设计呢？就像我们在业务开发里面，呢知道什么时候使用类似什么时候使用慢，道理是一样的。好的，本期的普通人vs高手的面试系列的视频呢就要到结束了。如果你喜欢这个视频，记得点赞和收藏，如果有任何的面试问题，呢或者说有学习上和职业发展的问题都可以来。我是麦克一个工作了14年的Java程序员，咱们下次再见。

322-【Java面试】阿里二面，Mysql索引在什么情况下会失效？请看Mic老师的最优解！-480P 清晰-AVC

	昨天一个工作了一年的粉丝好不容易拿到一个面试机会，结果在一个简单的问题上挂了，有点可惜，卖c狗索引失效这个问题面试水平也很高，但同时也很简单，我把完整的回答思路整理到了一个30万字的大场面试指南里面。下面说一下我的回答思路。第一没有使用索引列作为VR主句的一个查询条件。第二对索引链进行函数操作，比如字符串操作或者日记操作，MAC狗呢无法使用索引，这个时候索引呢会失效，因为买水果没有办法去在运行的时候使用函数计算来做索引匹配。第三对索引链进行类型转化。如果所以你也是数字类型，但是你传入的值呢是这么算，那么这个时候max会默认对类型进行转换，同样会导致所以时效第四，Lykke查询的查询字符串以通被俘开头，当我们使用like查询的时候，并且查询字符串以通配符为开头的时候，Maxey口无法索引，因为通配符在开头的时候没有办法进行一个最多匹配。第五or条件查询，当查询条件中包括or条件的时候，如果or条件中的每个条件都不涉及到，所以列卖切口呢是无法使用索引。第六，查询条件涉及到大量数据，当查询条件涉及大量数据的时候，假如返回表中的大部分数据查询的时候，那结果认为可能使用索引意义并不大，所以呢也不会使用索引。好的，对于这样一个问题啊大家不需要去回答说百%的完美，你们只需要把一些关键的点说清楚，面试官能够感受到你的一个理解或者一个知识深度就好了。Ok今天的分享就到这里，感谢大家的点赞和关注，我们下期再见，拜拜。

320-【Java最新面试题】JD二面：谈谈你对序列化和反序列化的理解？-480P 清晰-AVC
	Hello大家好，我是麦克。一个工作了4年的粉丝啊投了很多简历，好不容易接到一个互联网公司的面试邀约，结果在面试第一轮就被干掉了，其中就有这样一个问题，啊他说简单说一下你对序列化和非序列化的一个理解。这个问题的回答呢我整理成了文档，需要的小伙伴们可以在我的主页去加v领取。啊下面我们看看普通人和高手对于这个问题的一个回答，普通人的回答。序列化和反序列化。
	就我我要去把一个对象传输到网络上的其他的一个应用上的去。一个情况下就是我需要对这个对象做序列化，然后像Java里面我们可以我们需要对这个对象的序列化的话，我们需要去实现像C罗来之宝这样一个接口。吧高速的回答。好的，关于这个问题呢我需要从几个方面来回答。首先我认为啊之所以需要序列化，它的核心目的是为了解决网络通信之间的一个对象传输的一个问题，也就是说怎么样去把当前gvm进程里面的一个对象，跨网络传输的另外一个基本的精神里面进行恢复，而序列化呢就是把内存里面的对象转化为自己流，以便用来实现存储和传输。而反序的话就是根据从文件或者网络上获取到的对象的一个自节流，根据自己流里面保存的对象描述信息和状态，重新构建一个新的对象。其次啊序列化的前提是为了去保证通信双方对于对象的一个可识别性，所以很多时候我们会把对象先转化为通用的解析格式，比如说像节省啊 X怎么样或者其他一些格式，然后再把它们转化为数据流进行网络传输，从而去实现跨平台或者跨语言的这样一个可识别性。
	最后我再补充一下序列化的一个选择问题。啊市面上开源的序列化技术非常多，比如说像杰森x秒或者把否可有凯撒等等。那么在实际应用里面呢哪种序列化更合适？我认为有几个关键因素，第一个是序列化之后的一个数据大小，因为数据大小会影响到传输的一个性能。第二个序列化的性能，序列化耗时较长呢会影响到业务的一个性能。第三个呢我们要去判断它是否支持跨平台跨云的一个特性。第四个是技术的成熟度，越成熟的方案使用的公司会越多，也就会越稳定。以上就是我对这个问题的一个理解。序列化这个问题呢在面试过程中啊是问的比较多的，如果再深入一点的话，还会问到序列化的一些算法和原理。在实际开发过程中，呢序列化技术的选择对性能的影响也是比较大的，因此呢互联网公司啊对于这方面的考察会比较多一点。好的，本期的普通人vs高手的面试系列的视频啊就到这结束了，喜欢我的作品的小伙伴记得点赞收藏加关注，我是麦克一个工作了14年的Java程序员，我们下一期再见。
321-【Java面试】在生产环境上，发现内存泄漏问题，该如何排查？-480P 清晰-AVC
	如果在生产环境上发现内存泄漏，我们应该怎么去排查呢？昨天一个工作了三年的粉丝在投递了200多家公司以后，终于约到了那次机会，好不容易遇到一个面试机会，因为没有实操过，所以被问到如果发生内存泄露该怎么排查这个问题的时候，他不知道怎么去回答这个问题，在我之前整理的50万字的大肠面试指南里面有一个标准的回答模板，大家可以去评论区的视频中去领取。关于内存泄露有关的面试题，呢在面试过程中的面试频率还挺高的，一方面啊它是一个比较重要的基础知识，另外一个方面我们写的所有程序都是运行在gpm上，在出现故障的时候，需要开发人员具备解决该问题的能力，这个问题分为两个部分，第一，什么是内存泄漏以及会带来什么样的影响？第二，内存泄露的排查和解决方法。内存泄露是指在程序运行的过程中，啊因为某些原因导致不需要使用的对象，仍然占用gbm，内存空间，并且这块内存还无法被回收，最终呢导致程序占用的内存越来越大，从而出现om的错误，或者影响程序的性能。一般情况下，除了om这种错误以外，内存泄露也会出现一些比较明显的现象。
	比如说频繁的负GC，内存占用量过大，一直无法释放等等，内存泄露的排查，呢我们一般会根据现象去定位问题，所以第一步我们会先去定位是否是内存泄露。比如说老年代逐步增长，富尔基c卡顿年轻代的内存一直在高位无法被释放，频繁富尔GC等等这些现象基本上都是内存出现异常。要了解GC的情况，我们可以使用GC的命令去查看虚拟机中各个内存的使用情况和GC情况，然后使用double工具去把当前那种down下来，然后使用mat工具来进行一个分析，如果当普的文件比较大，呢可以使用轻量级的在线分析工具，仅卖 mat工具会自动分析当铺文件的内容，给出一个分析结果，并定位到有问题的类。然后我们只需要根据分析的结果找到对应的代码进行优化就好了。一般情况下可能是循环引用，内存对象泄露没有被销毁，动态分配内存以后未被释放，长期持有对象引用，资源未被关闭等等，以上就是我的理解。
323-【Java面试】腾讯一面：Spring里面的事务与分布式事务的使用，如何去区分？-480P 清晰-AVC
	Hello大家好，我是麦克。也工作了14年的Java程序员和创业者，昨天啊有一个粉丝来私信我一个问题，他说他去面试的时候，遇到这样一个问题，spring里面的事物和分布式事物是如何区分的，以及这两个事物有什么关联？我没有想到还有人回答不了这样一个问题，所以今天我们来给大家分享一下这个问题应该怎么去回答。这个问题的高手不能回答，已经整理成了文档，大家可以在我的主页去加v领取。关于这个问题我们看看普通人和高手的回答，普通人的回答。 spring里面的事物和分布的事物。唉我记得 spring的事物和分布事物是没有关系的，呀就没有任何关系，因为spring里面是是不是因为你的事物它只是对所以单个数据库的一个封装嘛就是一个事物的封装，但是分布式事物它是可能是涉及到多个数据库的一个管理，嘛 spring应该是跟跟这个分布事物没有什么关系的。高手的回答。好的，面试官。首先在spring里面并没有提供事物，它只是提供了对数据库事务的一个管理的封装。
	我们可以通过村民事事务的配置，啊使得开发人员可以从一些复杂的事务处理里面去脱离出来，我们不需要再去关心连接的获取，啊连接的关闭啊事务的提交事务的回滚这样一些操作，我们可以更加聚焦在业务的开发层面，所以呢 spring里面的事物啊本质上是数据库层面的一个事物。而这种事务管理啊主要是针对于单个数据库里面的多个数据表的操作，它去满足一个事物的act特性，而分布事务呢是解决多个数据库事务操作的一个数据一致性问题。传统的关系数据库呢不支持跨库的输入操作，所以需要引入分布式事物的解决方案，而spring里面并没有提供分布事物的场景知识，所以spring里面的事物和分布事物在使用上并没有直接的关联关系，但是呢我们可以使用一些主流的分布式事务解决框架，比如说像西塔集成到spring生态里面去解决分布式事务的一个问题。以上就是我对这个问题的理解。其实啊我认为在面试的时候不应该问这一类问题，因为spring事务和分布式事务虽然名字上类似字，但是它完全就是两个概念。
	好的，本期的普通人vs高手的面试系列视频呢就到这结束了。大家记得点赞收藏加关注我是麦克。我们下一期再见。
325-【Java面试】京东三面：Java类加载面试题，三面是双亲委派？-480P 清晰-AVC
	今天我们来分享一道关于Java类加载方面的面试题，啊在国内的一二线互联网公司面试的时候，面试官通常是使用这一方面的问题来暖场的，但结果往往是造成冷场。比如啊什么是双歧委派，什么是类加载news，dream生成了几个对象等等。双亲委派的英文呢是拍人得力给一些model，我认为啊从真正的实现逻辑来看，正确的翻译应该是副委托模型，当然不管它叫什么，我们来先看看遇到这个问题的时候应该怎么去回答呢？普通的回答。什么是双亲委派？双击委派呢是是那个呃 GM在实现那个类加载的时候，啊呃它会涉及到多个类加热器，啊比如说像那个启动类加热器啊或者呃扩展类加载器，啊还有是那个应用加载器，然后他们这种加载器之间会有一个这种层级关系，嘛然后就我们要去加载一个类的时候，它所有的加载它应该是会给到给到那个就是附加载器来执行，就是最终嗯会往上去传递，然后最终当每一个内架去他会去检查嘛去检查。就是每一个就这个类是不是我我的那个加热器应该是加载的，如果呃如果不是的话，就他会继续又又又往下发去给到去给到那个那个指甲的继续加载。
	高手的回答。关于这个问题呢需要从几个方面来回答，首先啊我简单说一下类的加载这样一个机制，就说我们自己写的Java文件到最终运行，它必须要经过编译和类加载这两个阶段，而编译的过程就是把点Java文件编译成点class文件，而类的加载过程就是把点class文件加载到GM的内存里面，装载完成以后会得到一个class对象，我们就可以使用6关键字来实例化这个对象。而类的加载过程需要涉及到类加载器，今天我们在运行的时候会产生三个类加载器，这三个类驾驶器呢组成了一个层级关系，每一个类加载器分别去加载不同作用范围的假包，比如说像Busch、klaas Lowder，他主要是负责Java核心类库的加载，也就是gieck homes下面laps下面的一个aarti减价和resource降价等等，extension casi loader呢主要是负责GDP Heaume下面的Laib exe d目录下的一个架包和class文件。
	Apk classbook的主要是负责当前应用里面clasp sparse下面的所有假包和类文件。除了系统自己提供的内加热器以外，还可以通过class楼的类来实现自定义加热器，去满足一些特殊的场景需求。而所谓的副委托模型呢就是按照类加载器的层级关系逐层进行委派。比如说当我们需要加载一个class文件的时候，首先会去把这个 class文件的查询和加载委派给负加载继续执行，如果附加载器都无法加载，再尝试自己来加入这样一个class。那么这样设计的好处呢我认为有两个，啊第一个是安全性，因为这种层级关系实际上代表的是一种优先级，也就是说所有的类加载优先要给到不是shift class load，那么对于核心类库中的一些类呢就没有办法被破坏，比如说自己写一个Java点，让电视剧最终还是会交给启动类加载器，再加上每个类加载器的本身的一个作用范围，那么自己写的Java点让点是菌就没有办法去覆盖类库中的类。
	第二个啊我认为这种层级关系的设计呢可以避免重复加载，导致程序混乱的一些问题。因为如果附加热器已经加热过了，那么子加热器就没有必要再去加载了。以上呢就是我对这个问题的理解。Gbm，虚拟机呢一定是面试必问的一个领域，因为我们自己写的程序就是运行在GM上，一旦出现问题，你不理解就无法去排查。就像一个汽车修理工人，他不知道汽车的工作原理，不懂发动机，那么他也无法去做好这份工作。好的，本期的普通人vs高手的面试系列视频就到这结束了，喜欢的朋友记得点赞和收藏。另外呢这些面试题我都整理成了笔记，大家如果有需要可以私信来获取。我是麦克一个工作了14年的Java程序员，咱们下期再见。


327-【Java面试】京东三面，Mysql使用B+树，而不是使用B树的原因？-480P 清晰-AVC

	为什么卖c口的索引要用b加速来实现，而不是b速呢？首先常规的数据库存储引擎一般都是采用b数或者b加数来实现，因为b数是一种多路平衡数，用这种存储结构来存储大量数据的时候，它的整个数的高度相比二加速来说会矮很多。而对于数据库来说，所有的数据必然都是存在磁盘上，而磁盘io的效率实际上是比较低的，特别是在随机磁盘io的情况下效率更低，所以树的高度能够决定磁盘io的次数，磁盘号次数越小，那么对于性能的提升就越大，这也是为什么采用b数作为索引存储结构的原因，但是在max口的英诺DB存储引擎里面，呢它用到了一种增强的b数结构，也就是b加速来作为索引和数据的存储结构。相比于b数结构来说，b加速做了几个方面的优化，第一个b加速的所有数据都存储在叶子节点，非叶子节点指存储索引。第二个叶子节点的数据使用双向列表的方式进行关联。关于MAC狗相关的面试，啊我给大家准备了1000道带有标准答案的面试题只有10份，大家可以在评论区的制定中去领取使用，b加速来实现索引的原因，呢我认为有几个方面，第一个 b加速的非叶子节点不存储数据，所以每一层能够存储的索引数量会增加，意味着b加数在层高相同的情况下，存储的数据量要比b数更多，使得磁盘的io次数更少。
	第二个在MAC口里面范围查询是一个比较常用的操作，而毕加索的所有存储在叶子节点的数据使用了双向链表的方式来关联，所以在查询的时候只查询两个节点，进行便利就行。而b数呢需要获取所有节点，所以b加速在范围查询上的效率更高。第三个在数据的检索方面，由于所有的数据啊都存储在叶子节点，所以b加速的io次数会更加稳定。第四个因为叶子节点啊存储了所有数据，所以b加速的全局扫描能力要跟墙，因为它只需要扫描叶子节点，但是b树呢需要便利整棵树。另外基于b加速这样一个结构，如果采用自身的整形数据作为组件，还能更好的避免数据增加的时候带来的叶子节点分裂，导致大量运算的问题。总的来说啊我认为技术方案的选型更多的是去解决当前场景下的特定问题，并不一定是说b加数就是最好的选择，就像芒果DB里面采用b数的结构，本质上来说其实是关系型数据库和非关系数据库的差异。好了，今天的分享就到这里结束。
318-【Java最新面试题】数据结构面试题：谈一谈你对B树和B+树的理解？-480P 清晰-AVC
	数据结构与算法的问题啊困扰了无数的小伙伴，很多小伙伴对数据结构与算法的认知有一个误区，认为啊工作中没有用到，为什么面试要问我呢？为了能够解决实际问题吗？今天啊我们来分析一道数据结构的一个题目，b数和b加速。关于这个问题我们来看一下普通人和高手对这个问题的回答，普通人的回答。想一下。啊嗯 My SQL里面应该是用 b加速来实现索引的。然后嗯在英诺DB里面或者my inside这个引擎里面，它都是用的毕加速。嗯然后 b加速是一种它的它是一个有多个分录的，相比于b叔来说，它的这个指路会比较多。然后高手的回答。为了更加清晰的去回答这个问题，啊我打算从这三个方面来回答。第一个啊我们知道b数是一种多路平衡查找术，为了更加形象去理解数的概念，我们先来看一下二叉树，我们先来看一下这个图，首先去了解一下二叉树，啊所谓的二叉树是指每个节点最多支持两个分叉，相比于单项链表来说它多了一个分支，而二叉查找术呢是指在二叉树的基础上去增加了一个规则，它的规则是浊指数的所有指节垫都要小于它的根结点，而柚子树的所有直接点呢都要大于它的跟界点。
	我们来看这个图，二三查手术有可能会出现邪术的问题，导致时间复杂度会增加，因此呢又引入了一种叫平衡二叉树的一个机制，它具有二叉查找树的所有特点，同时增加了一个规则，它的规则是它的左右两个指数的高度差的绝对值不能超过一平衡二杀素为了达到这样一个平衡，所以它会引入一个叫左旋和右旋的机制去实现竖的平衡。我们再来看这个图，啊而b数呢它是一种多路平衡查找树，它满足平衡二杀树的规则，同时它也可以有多个指。指数的数量呢取决于它的关键字的数量，比如说像这个图中根节点中有两个关键字，3和5，那么它能够拥有的子路数量等于关键字的数量加上一。因此啊从这个特征来看，在存储同样数据量的情况下，平衡二差数它的高度一定是要大于b数的。而所谓的b加数呢其实是在b数的基础上做了增强。最大的区别有两个点，第一个，b数的数据存储在每个节点上，而b加速的数据是存储在叶子节点上，并且通过链表的方式把叶子节点的所有数据进行一个连接。第二个，b加数的指路数量是等于它的关键字的数量。
	我们来看这个图，啊这个是b数的存储结构，从b数的结构上可以看到，每个节点都会存储数据。我们再来看另外这个图，这个是一个b加速的结构，b加速的所有数据是存储在椰子结节上的，并且呢叶子节点的数据是用双向链表来关联，这个是属于一诺DB里面的一个特征。第二，b数和b加数呢一般是应用在文件系统和数据库系统中，用来去减少磁盘io所带来的性能损耗的一个以MAC口中一诺DB为例，啊当我们去通过select的语句去查询一条数据的时候，英诺DV呢需要从磁盘上去读取数据，而这个过程会涉及到磁盘io以及磁盘的随机io我们来看这个图，我们知道啊磁盘io的性能是特别低的，特别是随机磁盘的io，为了更好的去理解为什么性能低，呢我们来看一下磁盘io的工作原理。首先系统会把数据的逻辑地址传给磁盘，磁盘控制电路按照寻址的逻辑，把逻辑地址翻译成物理地址，也就是确定要读取的数据在哪个渠道哪个扇区，为了读取这个扇区的数据，呢需要把磁头放在这个扇区上面。
	为了实现这样一个点，啊磁盘会不断的去旋转，把目标的扇区旋转到石头下面，使得石头能够去找到对应的磁道，这里呢会涉及到寻到的时间以及旋转时间的一个损耗。很明显磁盘io这个过程的性能开销是非常大的，特别是查询的数据量比较多的情况下，所以啊在英诺DB里面干脆对存储在磁盘上的数据建立一个索引，然后把索引数据以及索引列对应的磁盘地址，以b加速的方式来进行存储。我们来看这个图，当我们需要查找目标数据的时候，呢根据索引从b加数中去查找目标数据就行了。由于啊 b加速的子路比较多，所以只需要较少次数的磁盘io就能够查到目标数据。第三个，为什么要用b数或者b加数来做索引结构？呢原因是啊 Av二suo它的高度要比b suo或者b加速的高度要更高，而高度就意味着磁盘io的数量，所以啊为了减少磁盘io的次数，文件系统或者数据库才会使用b数，或者b加速来做索引结构。以上呢就是我对于b数或者b加数的一个理解。数据结构在实际的开发中非常常见，比如宿主链表，双向链表、红霉素跳跃表，b数和b加数等等。
	在我看来啊数据结构是编程中最重要的基本功之一，比如学了顺序表和链表，我们就能够知道查询操作比较多的场景中应该用顺序表而不用列表，而修改操作比较多的场景中应该使用列表，学了队列之后呢就知道对于FIFO的场景应该使用队列，学了树结构之后会发现原来查找类的场景还可以进一步去提升查找的性能。基本功啊决定了大家在技术这个岗位上能够走到什么样的一个高度。嗯好的，本期的普通人vs高手面试系列的视频就要知道结束了，喜欢的朋友呢记得点赞和收藏，如果啊最近大家遇到一些场景类的和方案设计类的问题，呢欢迎私信我，我会在后续的内容中给大家做一些解答。我是Mike。一个工作了14年的Java程序员，咱们下期再见。
324-【Java面试】并发编程面试题：什么是ThreadLocal，以及其实现原理？-480P 清晰-AVC

	一个工作了4年的小伙伴，他私信我一个并发编程里面的问题，他说他要抓狂了，啊每天ciud也没有用过，所有的logo啊怎么就不能问我怎么去写ciud呢？我反问他，啊如果只问你项目和业务，那么那些4年的小伙伴他要求月薪30k有些只要求月薪15k那请问一下凭什么每个月要多出15k给你，我花30k去招两个15k的人，不能显示一下ud吗？我们来看看所有logo这个问题，普通人和高手的回答，普通人的回答。uh Straight local。所以logo是一种县城本身的一个就就县城那种隔离的积蓄法，就是它它可以去实现多个县城之间的一种一种隔离，就是它能够避免多性的访问某个共享边的时候的一种一种现成安全性，啊就是嗯是这样的一个东西，然后它的实验原理的话，它是原理，它里面用到了用了一个这个 map来存储，就是他好像每个县城里面都会有一个这样的map来去存储对应的这个现这个共享变量。高手的回答。好的，那么这个问题啊我会从下面几个方面来回答。首先three的logo呢是一种现成隔离机制，它提供了多线的环境下对于共享变量访问的一个安全性。
	再多线的访问共享变量在一个场景里面，呢一般情况下的我们的解决办法是对于共享变量去枷锁，索取保证在同一个时刻只有一个线程能够对共享变量进行更新，并且基于happens before规则里面的一个锁监视器的一个规则，又能够保证数据修改之后对其他线程是可见的，但是枷锁呢会带来一个性能上的下降，啊所以 three logo用了一种空间换时间的一个设计思想，也就是说在每个县城里面都有一个容器，存储共享辩论的一个副本，然后每个县城只对自己的变量副本来做更新操作，这样的话既解决了县城的安全问题，又避免了多线程竞争所的一个开销。Three的logo的一个具体实现原理是在three的那里面有一个成员变量叫 threader local map，它专门用来存储当前限量的共享变量的一个副本，后续这个线程对共享变量的一个操作，呢都是从这样一个three的logo map里面去进行变更的，不会影响全局共享变量的一个值，从而去实现数据的一个隔离。
	以上就是我对这个问题的一个理解。Thread lowk的使用场景呢是比较多的，比如说数据库的连接的一个隔离，对于客户端请求会话的一些隔离等等。在所有的logo里面，呢除了空间换时间的设计思想以外，还有一些比较好的设计思想。比如说信息探测去解决哈希冲突，数据预清理机制，以及若引用k的设计去尽可能避免内存泄露的一些问题，那么这些思想在解决某些特定业务场景问题的时候，我们是可以直接去借鉴的，这就是我们去学习一些底层原理的一个价值。啊好的，本期的普通人vs高手的面试系列的视频就到这结束了，喜欢的朋友记得点赞和收藏，另外呢这些面试题我都已经整理成了笔记，大家有需要的可以私信来获取。我是麦克一个工作了14年的Java程序员，咱们。
326-【Java面试】阿里二面，AQS为什么要使用双向链表？-480P 清晰-AVC
	一个工作的4年，程序员简历上写了精通并发编程，并且呢阅读过 aqs的一个源码。然后面试官只问了他一个问题，hello大家好，我是麦克。一个没有才华，只能靠颜值混饭吃的Java程序。Aqs呢大家都不陌生，啊它是guc包里面一个非常重要的线程同步器，而面试官啊提了这样一个问题，说ax为什么要使用双向列表这样一个存储结构？呢关于这个问题的回答，我指引到了一个10万字的面试文档里面，大家可以在我的主页去加v领取。下面我们看看普通人和高手对于这样一个问题的回答，普通的回答。我认为x要使用双向链条，双向列表应该会涉及到涉及到双向查找，我记得好像是中段。就是线程中段的时候，需要删除节点，30节内的情况下，可能需要这种反向的一个查找，就需要一个双向查找。然后就就就会用到重新列表。高手的回答。好的，面试官。首先呢双向列表的特点啊是它有两个指针，一个指针呢指向前置节点，一个指针指向后驱节点。所以啊双向列表它可以支持常量级别的时间复杂度的情况下去找到前驱节点。
	那么基于这个特点，呢双向链在插入和删除操作的时候，要比单项链表更加简单和高效。因此呢从双向列表的特点来看，我认为aqs使用双向链表有三个方面的原因，第一个方面，没有竞争的所在县城加入到阻塞队列，并且阻塞等待的一个前提是当前县城所在的节点的前置节点，是一个正常状态。那么这样设计的目的是为了去避免在列表里面存在异常状态的节点，导致无法唤醒后续现成的一个问题。所以线程在主测之前啊需要去判断前置节点一个状态，如果没有指针指向前置节点，那么这个时候我们就需要从头部节点开始往下遍历，那么它的性能是非常低的。第二个方面呢在lock接口里面还有一个可以中断的锁的竞争的方法叫rock interrupt，这个方法是表示处于所阻塞的线程是允许被中断的，也就是说没有竞争到所的县城，加入到同步队列等待以后，是允许被外部新人通过interrupt的方法去触发唤醒灭中断的。而这个时候呢被中断的线程的状态会修改成看守的状态，被标记为看守的状态，这个县城是不需要去诊所的，但是它仍然会存在于整个双向列表里面，意味着后续的锁的竞争中需要把这个节点从列表里面去移除，否则啊会导致所阻塞的线程无法被正常唤醒。
	那么在这种情况下，如果是单向列表，就需要从head节点开始往下去逐个便利找到并移除异常状态的节点，那么同样效率也是比较低的，而且还会导致锁的唤醒的操作和便利的操作之间的一个竞争。第三个方面，啊为了避免线程阻塞和唤醒的开销，所以加入到链表的线程，呢它首先会通过自旋的方式去尝试竞争所，但是实际上按照弓屏锁的一个设计，呢只有头节点的下一个节点才有必要去竞争所，后续的接地区竞争所的意义不大，否则呢会造成一个金群效应。也就是说大量的县城在主摄之前尝试竞争所带来一个比较大的新的开销。所以啊为了避免这个问题，加入到链表里面的节点，在尝试竞争所的时候，需要去判断前置节点是不是头节点，如果不是头节点呢就没有必要去触发锁的竞争动作，所以这里会涉及到一个前置节点的一个查找。如果是单向列表是无法实现这样一个功能的。以上呢就是我对这个问题的理解。关于这个问题呢我相信90%以上的人都回答不上来，而且呢我也简单翻阅了一下网上的技术博客，基本上全都是错的。
	对于aqs理解不够深刻的情况下，乱回答会导致很多同学被误解。理解一个技术为什么这么设计，关键在于它需要解决什么样的问题。好的，本期的普通人vs高手的面试系列视频呢就到这结束了，大家记得点赞收藏加关注。我是Mike。我们下期再见。

331-【Java面试】大厂高频面试题，为什么加索引能提升查询效率？请看Mic老师的最优解！-480P 清晰-AVC
	为什么增加索引能够提升查询效率，我们都认为加索引提升查询效率是理所应当的。既然还有理由，我们应该怎么回答？Hello大家好，我是麦克一个工作了14年的Java程序员，我呢把高手的回答整理到了一个20万字的面试文档里面，大家可以在我的主页去领取。下面呢我们来分析一下这个问题的考察点，这是一道原理性的问题，考察求职者对于my SQL中索引的实现原理和理解程度。一般情况下考察三年经验以上的人会比较多一点，毕竟MAC口是应用开发的基础存储组件，因此对这个问题的回答建议把所有的实现以及它的工作原理说清楚，这样会更容易获得面试官的认可。想必大家都知道MAC狗呢采用了b加速作为索引的存储结构来提升数据的查询效率。其实如果大家真正要去理解并且搞懂，所以我建议大家从三个维度来看，第一个问题为什么需要索引？很简单，如果一本中华字典没有前面的字典目录，你需要花多久才能找到某一个汉字？同样的道理，如果没有索引，当我们要去查询数据的时候，需要从磁盘里面去随机查找，而机械磁盘随机读取数据需要频繁的寻找磁道以及从磁盘读取数据，这个过程中呢非常耗时。
	第二个问题，所以是如何提升效率的？有了索引以后，相当于把索引列以及所属的10万块地址缓存到了内存里面，在数据查询的时候呢直接可以找到目标数据链所属的磁盘地址，去读取对应磁盘块的数据，好相当于减少了磁盘io的一个次数。第三个问题为什么要采用GB加速？原因有很多，如果单纯站在新人的角度来考虑，磁盘io次数越少越好，那用什么样的数据结构来存储索引链能够去达到这样一个目的呢？很显然多路平衡长寿处就是一个非常好的选择，也就是b加速或者b数，至于为什么要采用b加速，我在前面的视频里面有专门说过，大家可以去找找看，接下来我们看看高手是如何回答这个问题的。好的，准确来说啊只要命中了索引链的一个查询，它都能够去提升查询效率，但是呢即便是命中的索引查询效率也不一定会增加。比如说像性别字段去加索引，那么因为数据的闪电度不高，导致可能会便利整颗毕加索。所以我认为加所以能够提升查询效率的根本原因啊是一个APP采用了一个b加数字，多路平衡查找数来存储索引，那么使得在千万级数据量的一个情况下，呢树的高度呢可以控制在30以内，而层高代表磁盘io的一个次数，因此呢基于索引查找呢它可以减少10分io的一个次数。
328-【Java面试】Java理财业务题，为什么两个Integer的对象不能用==来判断？含泪背下生产事故！-480P 清晰-AVC
	昨天一个工作了4年的粉丝来私信我，啊他说他最近背了一个生产事故，想让我去把这个事故分享给大家，避免踩坑。他呢是在做理财这一块的业务，他每天会收到一些基金公司的一个收益文件，然后他需要把这样一个文件解析入库。那么在解析文件的时候，呢它需要对数据的条数做校验，于是采用了integer这样一个对象，并且使用了等于等于来判断在测试环境的时候都没有问题，但是上生产环境的时候出现了用户收益没有到账的一个问题，造成了大规模的一个投诉，最后定位才发现啊这个收益文件的验证失败，导致没有被解析入库。所以这里面就出现这样一个问题，啊为什么两个index的对象不能用等于等于来判断？为什么测试环境没有把这个问题测试出来。呢另外关于这个问题和之前以往的高手回答，我花了一个多星期时间呢整理成了一个10万字的文档，可以在我的主页去加v遴选。啊下面我来看一看普通人和高手对这样一个问题的回答，普通人的回答。 injure Injure它里面呃我记得有一个就是那个嗯负-1208~127之间，它会有一个那种就数据的一个缓存。
	嗯也就是说比如说如果我的那个取值范围是在这个区间内的话，它直接会从缓这边拿到这个对象。然后如果说我直接用两个英特尔的一个一个对象去做比，等于对于比较的话，如果在这个区间内它肯定是也相同的，嘛因为它的地址是同一个。然后高手的回答。好的，面试官。英特尔呢是一个封装类型，它对应的是一个int类型的包装，在Java里面之所以要去提供intel的这样一些基本类型的封装类，是因为Java是一个面向对象的语言，而基本类型呢不具备对象的特征，所以呢在基本类型上做了一层对象的包装，并且提供了相关的一些属性和访问的方法，来完成基本类型的一些操作。在intel9这个封装类里面，除了基本的intel类型的一些操作以外，呢还引入了想源模式的设计，对-128~127之间的数据啊做了一层缓存，也就是说如果intel者类型的目标值在-128~127之间，就直接啊从缓存里面去获取英特尔的这样一个对象的实力，并且返回，否则啊会创建一个新的intel9对象。
	那么这样设计的好处啊是减少频繁创建intel的对象带来的一个内存消耗，从而去提升性能。因此在这样一个前提下，呢如果定义了两个intel酒对象，并且这两个intel酒的取值范围正好在-128~127之间，并且我们直接使用等于等于来判断返回的结果必然是to，因为这两个intel指向的内存地址是同一个，否则啊返回的结果是boss。之所以在测试环境上没有把这个问题暴露出来，是因为测试环境上的数据是有限的，也就是说文件解析的数据的条数的取值范围正好在intel9的一个缓存区间，所以导致我的测试是通过的。但是在实际生产环境里面，数据量是远远超过-128到127这个曲子区间。呢所以就会导致当我们使用两个intel姐的对象去进行等于等于比较的时候，他的校验会失败。以上呢就是我对这个问题的理解。你看对于Java基础有一个非常深度的理解，还是很重要的。吧一个小小的知识点，往往能够造成生产环境上比较大规模的一些影响。啊所以在一些大厂的面试环节里面，啊基础的考察比例会比较重。
	从另外一个层面来说，呢中间件和技术框架已经是一个成熟的产品，所以呢我们即便再怎么乱玩，造成的影响也是有限的。好的，本期的普通人vs高手的面试系列视频呢就到这结束了，大家记得点赞收藏加关注。我是麦克。我们下一期再见。
334-【Java面试】百度三面，一个空Object对象占多大空间？请看Mic老师的最优解！-480P 清晰-AVC


	一个空的object，对象它到底占多大内存空间？一个工作了5年的Java程序员呢被这个问题搞晕了。Hello大家好，我是麦克。一工作了14年的Java程序员，下面我们看看普通人和高手是如何回答这个问题的？普通人的回答。在我记得好像是32位和64位好像是不太一样的。然后它里面对象它里面应该有有几个所区域吧就是高手的回答，好的面试官在开启了压缩指针的一个情况下，呢 object默认会占12个字节，但是为了避免伪共享的问题，啊 GM会按照8个自己的倍数去进行填充，所以会填充4个字节变成16个字节的1个长度。在关闭压缩指针一个情况下，呢 obtain默认会占16个质检，而16个质检呢正好是8的整数倍，所以呢它不需要填充。因此呢在开启和不开启压缩值的情况下，1个object对象默认都只占用16个字节的1个空间。在hotspot虚拟机里面，啊一个对象在堆内存里面的一个内存布局，呢它使用了一个Otey的一个结构来表示，它主要分为三个部分，第一个部分是对象头，对象头里面包括马可波尔内能指针和数组长度，其中啊马可word呢是用来存储对象的运行时的一些相关数据的，比如说像还是扣的呀几乎分的年龄，啊以及所标记啊等等。
	那么在64位的操作系统里面，呢它会占用8个字键，在32位操作系统里面它会占4个字节，其中啊类圆指针呢指向的是当前实力对象所属哪个类，在开启压缩指针的1个情况下，它会占4个字节，在没有开启的情况下会占8个字节，速度长度呢只有在当前是一个对象数组的情况下，它才会存在，它会占4个字节。第二个实例数据它是用来存储对象中的一些字段信息的。第三个是对齐填充，Java对象的大小需要按照8个字节或者8个字节的倍数来进行对齐，来去避免伪共享的问题，所以呢一个空的对象在开启压缩指针的情况下，它会默认在16个字节的一个长度，其中马克word会占8个字节，内缘指针呢会占4个字节，对齐填充会占4个字节以上，呢就是我对这个问题的理解。这个问题呢不仅仅考察GM基础，还考察求职者对于GM对象内存布局的一些理解程度。对于内存布局这块的理解，主要还是帮助我们更好的去解决GM应用过程中的一些实际问题。好的，本期的视频就到这结束了。
329-【Java面试】字节二面，Spring中有两个id相同的bean，会报错吗？请看Mic老师的最优解！-480P 清晰-AVC
	嗨大家好，我是麦克。一共做了三年的粉丝，啊早上6:00给我发微信语音，直接把我吓醒。啊我以为是什么天大的事情，结果一问才知道面试官问了他一个问题，他没有回答上来问题是 spring里面如果两个ID相同的病会报错吗？如果会在哪个阶段报错？下面我们看看普通人和高手对于这个问题的回答，普通人的回答。两个ID相同的并他应该会报错。因为因为在spring LC容器里面，它的它的ID一定是唯一的，吧因为如果说有两个胸痛ID的话，那就会存在。我我我找不到，就是说我我我们去找一个病的时候，他会根据名字来找，嘛要么根据类型，嘛那么意味着如果我根据名字来找的话，它如果存在重复的话，我肯定只能找到一个，所以它应该是会再报错的。然后在哪个阶段的话，哪个阶段？应该是在应该是在 spring启动的时候。吧高手的回答。好的，关于这个问题呢我会从几个方面来回答，首先在同一个xm配置文件里面不能存在ID相同的两个病，否则视频容器在启动的时候会报错。
	因为啊 Id这个属性呢表示病里面的唯一标志符号，所以spring在启动的时候会去验证ID的一个唯一性，一旦发现重复呢就会报错，而这个错误发生在spring对xml文件进行解析，转化为并definition的一个阶段。但是啊在两个不同的视频配置文件里面，可以存在ID相同的两个病，IOC容器在加载病的时候呢默认会把多个相同ID的病呢进行覆盖，在spring三点x版本以后呢这个问题啊发生了变化，在Spreen三点exo版本里面呢提供了一个configuration这样一个注解去声明一个配置类，然后使用been这个季节去实现bea的声明，那么这种方式完全取代了xml的一个配置形式。那么在这么个情况下，如果我们在同一个配置类里面去声明多个相同名字的病，那么spring IOC容器在解析的时候，只会注册第一个生命病的一个实例，后面重复明治病的实例呢就不会再注册了。像这样代码啊在CFC容器里面只会保存优质service01这样一个实例，后续相同名字的实例呢不会再加载。
	如果使用奥特y的这个注解去根据类型进行实例注入的时候，因为二c龙庆呢只存在优质service01这个实力，所以啊在启动时候会提示找不到这serving02这样一个实例，如果我们使用riso这个注解就根据名字来实现依赖注入，而在PLC容器里面根据名字只会得到一个优质service01的这个实力，向于是sprig把优质service0这样一个实例赋值给you，servis02的时候会提示一个类型不匹配的一个错误，那么这个错误呢是在CBRC溶剂里面的并初始化之后依赖之路阶段去发生的。以上呢就是我对这个问题的理解。你看一个小小的面试题，既然涉及到这么多的知识点，有些粉丝会问，啊那么这个我已经会用了，问这个问题的意义在哪里呢？其实很多刚工作1~2年的小伙伴，如果出现使用不恰当，很容易出现各种奇怪的异常。而对斯宾来说，如果你有足够深入的理解，那么你可以快速定位和解决这一类的异常。好的，本期的普通人vs高手的面试系列的视频呢就到这结束了。
	喜欢我的作品的小伙伴记得点赞和收藏加关注，我是麦克。一个工作了14年的Java程序员，我们下期再见。
335-【Java面试】得物一面，TCP协议为什么要设计三次握手？请看Mic老师的最优解！-480P 清晰-AVC
	一个工作5年的粉丝，啊最近去面试了很多的公司，每一次都被各种技术原理问得语无伦次，因为他找了一个月的时间还没有找到工作，有点焦虑来向我求助，我能做的呢只是保证每一天去更新一个面试题。然后我问他印象中最深刻的一个面试题是什么？他说 TCP协议为什么要设计三次握手？我怎么知道？那么对于这个问题呢我们看看普通人和高手的回答，普通人的回答，TCP为什么要设计三次握手？我认为啊就是因为TCP它是一个双攻协议，双攻协议的话呢就是意味着它可以双向去进行数据传输，嘛高手的回答。关于这个问题啊我会从下面三个方面来回答。第一个啊 TCP协议是一种可靠的基于字节流的面向连接的一个传输协议，可靠性体现在TCP协议通信的双方的数据传输是稳定的，即便是在网络不好的情况下，TCP都能够去保证数据传输到目标端，然后TCP通讯双方的数据传输啊是通过字节流来实现传输的。最后面向连接是说在数据传输之前必须要建立一个连接，然后基于这个连接来进行数据传输。第二个因为TCP是面向连接的协议，所以在进行数据通信之前需要建立一个可靠的连接，TCP呢采用了三次握手的方式来实现连接的一个建立。
	所谓的三次握手，其实就是通信双方一共需要发送三次请求，才能确保一个可靠连接的一个建立。第一次是客户端向服务端发送连接请求，并且携带同步序号syn。第二次是服务端收到请求之后，发送sym和ack那么这里的sy呢表示是服务端的一个同步序列号，ack啊表示的是对前面的客户端的这个请求的一个确认，表示告诉客户端我收到你的请求了。第三次客户端收到服务端请求之后，再一次发送SK，而这个SK是针对服务端的连接的一个确认表示告诉服务端，我收到了你的一个请求。第三个点，之所以啊 TCP设计三次握手，我认为有三个方面的原因，第一个TCP是一个可靠的通信协议，所以TCP协议的通信双方都必须要维护一个序列号，去标记已经发送出去的一个数据包，哪些是已经被对方签收的，而三次握手就是通信双方去相互告知序列号的一个初始值，为了确保这个序列号被收到，所以双方都需要有一个确认的操作。第二个，TCP协议需要在一个不可靠的网络环境下去实现一个可靠的数据传输，意味着通信双方必须要通过某种手段来实现一个可靠的数据传输的一个通道，而三次通信是建立这样一个通道的最小值，当然我们还可以通过4次5次只是没必要去浪费这样1个资源而已。
	第三个防止历史的重复连接初始化造成的一个混乱问题。比如说在网络比较差的情况下，客户端多次发送建立连接的一个请求，假设只有两次握手，那么服务端只能选择接受或者拒绝这样一个连接，但是服务端并不知道这次请求是不是之前因为网络堵塞而过激的一个近郊，也就是说服务端不知道当前的客户端请求是有效还是无效的。以上就是我对这个问题的一个理解。网络通信这块内容呢还是非常重要的。我们在面对一些线上网络故障排查的时候，可以快速的去帮助我们去定位问题，并且找到解决办法。好的，本期的普通人vs高手的面试系列的视频就到这结束了。我是Mike一个工作了14年的Java程序员，咱们下期再见。

330-【Java面试】蚂蚁金服二面，什么是守护线程？堪称史诗级的回答！-480P 清晰-AVC
	Hello大家好，我是麦克。一个工作三年的粉丝在面试的时候遇到一个县城有关的问题，他想让我帮他去解答一下。他的问题是什么是守护县城，它有什么特点？这个问题的高手回答呢我已经整理成了文档，啊如果你需要的话可以在我的主页去加v领取。下面我看看普通人和高手对这个问题的一个回答，普通人的回答是守护县城。嗯我记得守护县城，就是比如就是就这个这个县城它它不会影响到 gbm进程的一个结束，就是高手的回答。好的。守护县城啊它是专门为用户县城提供服务的一种县城，它的生命周期是依赖用户现成的，只有gpm仍然存在，用户现在正在运行的情况下，守护县城才会有存在的一个意义，否则啊一旦GPS进程结束了，那么守护县城也会随之结束。也就是说守护先生不会阻止GM的一个退出，但是用户先生会守护线程和用户线程创新方式其实是完全一样的，我们只需要去调用用户线程里面的一个setem的方法去设置成q就好了，那么就表示这个线程是守护线程，而基于守护线这样一个特性，啊所以我认为它更适合一些后台的通用型服务的一些场景里面。
	比如说像gpm里面的垃圾回收，那么就是一个典型的使用场景。这个场景的特殊点啊在于当机会员的进程结束的时候，内存的回收线程本身就没有存在意义了，所以不能因为正在有线程进行垃圾回收，导致基本的进程无法结束这样一个问题。而基于守护现在这样一个特性，啊所以它不能用在一些县城池或者一些io的一些任务场景里面，因为一旦基本上退出以后，守护先生也会直接退出，那么就会导致任务还没有执行完，或者资源还没有证据释放的一些问题。以上就是我对这个问题的一个理解。这个问题啊大部分工作年限比较长的同学也不一定能够回答上来，首先现成这个领域呢在业务开发中本身就使用比较少，而守护前人的接触就更少了。我始终认为啊只有积累了足够多的技术，才能够去更从容的去应对未来长期的职业发展。好的，本期的普通人vs高手的面试系列视频呢就到这里结束了，喜欢我作品的小伙伴记得点赞收藏加关注，我是麦克。一个工作14年的Java程序员，我们下期再见。




333-【Java面试】京东二面，怎么实现集群环境下的分布式单例模式？请看MIc老师的最优解！-480P 清晰-AVC
	前两天一个工作了8年的粉丝在面试的过程中啊被问到单例模式的问题，他当时还暗自窃喜，因为他已经准备了7种单例模式的回答，结果面试官不按套路出牌，问他如何设计实现一个集群环境下的分布式单例模式，顿时给闷傻了。这个问题在我之前整理的大场面试指南里面也有标准的回答，大家可以在我的评论区的置顶中去领取。单立模式，相信每一个人都会，但是分布式集群下的单立模式就很困难了。大家如果在面试的时候遇到这个问题，肯定第一时间反应就是懵了，但是其实也不用着急。其实这个问题应该可以拆成两个部分，第一如何实现跨进程级别的单粒实力。第二，如何保障在任何时刻只有一个进程可以访问这个实力，一旦做到这两个点，那么基本上我们这个问题的答案就有了，但是关于第一个点，如果按照常规的单例模式的思路去思考，是无法去实现的。因为啊你不管怎么做，最终每个进程获取到的对象实力，在进程内的内存地址都是不一样的。所以我们应该换一个思路，也就是对象状态的唯一性，简单来说就是不同的进程在获取这个对象实例的时候，都能保持上一个进程，对这个状态修改之后的一个状态。
首先我们可以把单例对象序列化保存到文件里面，然后再把这个文件存储到外部的共享存储组件里面。其次各个进程在使用这个单位对象的时候，先从外部共享存储组件里面去读取到内存，并且反序列化成对象来使用。最后当前进程使用完这个单粒对象以后，再把这个对象序列化以后，再存储回外部的共享组件里面，去实现更新，并显示的把当前这个对象实力从本地内存里面删除掉。据这样一个操作呢就能够保证各个进程对单位对象的状态一致性，但是因为多个进程可以同时访问这个单例对象，所以为了保证在任何时刻都只有一个进程去访问这个当地对象，所以我们就需要引入到分布式所的设计，也就是一个进程在获取到分布式，所以后才能访问这个共享代理对象，使用完以后再释放分布式锁。当然分布式所的实现可以使用中keep etcd release等等。以上就是我的理解。
332-【Java面试】大厂高频面试题，数据库索引的原理为什么要用B+树？你能回答出吗？-480P 清晰-AVC
	数据库的索引的原理为什么用b加速？我建议大家在回答这个问题之前，你们一定要搞懂它的底层原理，就是数据库本身的数据存储是在磁盘上的，那么我们在进行数据的查询的时候，写写一个CQ就把sexy西方user它就把数据给你查出来了，那你想一想它底层怎么做的，它查询的数据分布在磁盘的很多位置，不同的磁块，然后你要查找的话，它需要去不断的寻找这个磁盘的地址，根据磁盘地址去通过那个磁盘的运作，通过那个渠道去找到对应的那个磁道的一个数据。另外给大家整理了一份程序员开发求职突击手册，包含简历模板、面试技巧，热门面试题、学习路线，有需要的小伙伴可以在评论区去领取。那么通过读取这个数据然后返回你想一想，如果我查询的数据有1万条或者1000条的时候，它的整个io次数和磁盘的io效率是非常非常低的。那么如果是这种情况下，我们去使用数据库，那你你会愿意使用吗？你们不愿意使用，所以我们在这里面怎么去提升效率，减少磁盘扫描次数，这是第一个方案，怎么减少？存在内存里面就是保证你的磁盘的连续性，对不对？就你数据存储是连续的，这样的话你就不会存在这个磁盘大量的这个磁盘页的一个扫描的数据结构，数据结构的优化去减少我磁盘的扫描次数，所以在数据库里面设计了一个8分破，这个就是内存的部分，它会在这里面缓存一部分数据。
	第二个刚刚说数据结构，我通过数据结构干嘛？假设我的磁盘扫描一定会存在，那么我怎么去减少我的查询的次数，查询次数我可以用什么结构来减少呢？正常的时间复杂度，比如常量OA n或者oo Logan这样的一些时间法度，那么我们通过这种时间复杂度去减少数据的便利次数计算制度，那么这样的话我是不是可以去减少磁盘的一个查询的次数，呢内存这个部分有了，在数据库MAC口里面是有这个部分的。第二个部分，我们用什么方式去减少查询便利次数？呢你看我们实际上是有这种数的结构的，那我们用什么数？我们说啊老师我们能不能用这个二差数或者说平衡数或者多路平衡数，我们会有很多的这种选择，对不对？可以通过不同的数据结构去决定我当前的时间复杂度。那我们这里做什么选择，我们要选择哪一个？我们选择的点一定是来自于便利次数，那我怎么去减少便利次数，二差数或者平衡数，行不行？呢它可以，但是相比于多路平衡数来说，它的便利次数要多一些，减少变性次数就是数的层高越矮越好，所以多路平衡数就作为一个选。
	我们采用了这样一个矮的结构，因为多路平元素它可以有多个分叉，所以在这个时候我们可以选择像b数或者b加数，我们从这个点衍生出我怎么去减少磁盘的交互次数，所以我们在这里面用了这个数的结构，好，那我用b数还是b加数，呢因为我们最终的目标就是怎么去减少层高，而b数和b加数的区别在于我们的数据存储的方式，b数的存储方式是每一个节点上都会存索引和数据，但b加速它只有叶子节点出来会存数据，它的这个非叶子节点存储的是索引，所以这样的话它的层高越低，所以理解了这个点，你再来看这个问题的时候，你至少能够回答出一个问题，就是为什么采用b要素？因为我要去减少跟磁盘的交互次数。
338-【Java面试】字节二面，谈一谈日常工作中如何去优化SQL语句？请看Mic老师的最优解！-480P 清晰-AVC
	昨天一个工作两年的粉丝去面试，被问到日常工作中的CK优化的一个问题，这个问题在面试过程中的频率会特别高，c口编写和c口优化呢是开发人员的基础技能，但是要回答好这个问题还是有难度的，因为很多时候啊大家第一反应是加索引，但这个回答并不完整。关于这个问题啊我们其实可以从几个方面来回答。第一个加索引，增加索引是一种简单高效的手段，但是需要选择合适的链，同时避免导致所以私下的操作，比如like函数等等。第二个是避免返回不必要的数据列，减少返回数据列，可以增加查询效率。第三个根据查询分析器适当的优化CK的结构，比如是否走全秒扫描，避免只查询等等。第四个分库分表，在单表数据量较大或者并发连接数过高的情况下，可以通过这种方式有效的提升查询效率。第五读写分离，针对读多写少的场景，这样可以保证写操作的数据承载更小的压力，也可以缓解独占锁和共享锁的竞争。基本上回答这个程度啊得到面试官的认可是没有问题。Nice，不过要注意面试官还会基于你的回答的内容再做更进一步的深度考察，比如为什么增加索引，能够提升查询效率等等，这些在我整理的面试文档中都有，好了，今天的分享就到这里。
336-【Java面试】春招必刷题：简述一下你对线程池的理解？-480P 清晰-AVC
	到底是一道什么样的面试题，让一个工作了4年的精神小伙，只是去参加一场技术面试，就被搞得精神萎靡，郁郁寡欢，这一切的背后到底是道德沦丧还是人性的扭曲，让我们一起来揭秘一下这道面试题。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，可以在我的主页姐姐里面去找到。好的，关于简述你对线程师的理解，我们来看看普通人和高手的回答。普通人的回答。呃线程池线池它是一种现成的一个复用技术，嗯在县城里面它可以维护很多的这种县城，嘛然后我我们只我们在执行任务的时候，我只需要去把任务丢到现实里面去处理就好了，那么它可以避免我去做这个县城频繁创建和销毁这种的一个一个一个一个动作。然后就现实池里面它可以设置各种参数，嘛然后这个参数可以去可以去维护，就是说我每个县城能够就每个县城能够用多少线程，啊这个是可控的。就是至少在那个程序里面，我我能够对资源的使用资源的使用是可控的。高手的回答。好的，关于这个问题我会从几个方面来回答。
	首先啊现在这个本质呢是一种磁化技术，而磁化技术是一种资源复用的一个设计思想，比较常见的磁化技术有连接池、内存池和对象池，而线程池里面复用的是线程资源，它的核心设计目的呢我认为有两个，第一个是它可以减少现成的频繁创建和销毁带来的性能开销，因为县城创建会涉及到CP的上下文切换以及内存的分配这样一些工作。第二个是线程池本身啊会有一些参数来控制线程的创建数量，这样的话呢可以去避免无休止的创建县城带来的资源利用率过高的问题，所以它可以起到资源保护的一个作用。其次呢我简单说一下线程池里面的现成复用技术，因为线程本身啊并不是一个受控的技术，也就是说现成的生命周期是由任务的运行状态来决定的，无法去人为控制。所以为了实现现成的复用，现成池里面用到了阻塞队列，简单来说就是限制里面的工作线程处于一直运行状态，它会去从阻塞队列里面去获取待执行的一个任务。一旦队列空了，那么这个工作性能就会被阻塞，直到下一次有新的任务进来。
	也就是说工作线程是根据任务的情况来决定阻塞和唤醒，从而去达到线程复用的一个目的。最后现实池里面的资源限制是通过几个关键参数来控制的，分别是核心线人数和最大线人数量，核心线程数呢表示默认长期存在的工作线程，而最大的线程数是根据任务的情况来动态创建的线程，它的主要目的是为了提高阻塞队列中任务的处理效率。以上就是我对这个问题的理解。我当时在阅读现成时的源码的时候，发现里面的设计思想非常的惊艳，比如动态扩容和缩容思想，现成的复用思想以及现成的回收方法等等。我发现越是简单的东西反而是越不简单。好的，本期的普通人vs高手的面试系列视频呢就要知道结束了。我是Mike。一个工作了14年的Java程序员，咱们下期再见。

337-【Java面试】蚂蚁金服三面，Mybatis是如何进行分页的？请看Mic老师的最优解！-480P 清晰-AVC
	My bits是如何进行分页的，这是一个工作了三年的同学在面试的时候遇到的一个问题。Hello大家好，我是麦克一工作了14年的Java程序员，经常有同学在后台跟我吐槽，啊他说在求职过程中呢遇到了各种各样的面试难题，我发现大部分的问题之前的视频里面都有分析过，考虑到视频可能太过于分散，不方便大家学习，所以我系统的整理了一份20万字的面试文档，有需要的同学呢可以在我的主页去领取。下面我来分析一下对于这样一个问题，面试官的考察意图以及我们应该怎么样去回答。 My business是Java应用开发的基础框架，而分页呢又是我们实时都在使用的功能。所以在我看来，一方面考察的是求职者对于my best框架的一个使用能力。另外一个方面以此为切入点，去深度挖掘 my business里面更多的一些问题，从而去了解求职者对于他的理解深度。这道题考察的难度并不大，主要考察1~3年的Java开发经验的同学，数据性分页是开发里面最基础的功能，一般我们可以把分页分成两类，第一个是逻辑分页，先查询出所有的数据缓存到内存里面，再根据业务相关的一些需求，从内存的数据里面去筛选出合适的数据，进行分页。第二个是物理分页，直接利用数据库里面所支持的分页语法来实现。
	比如MAC口里面提供了分页相关的关键词叫limit，my business里面啊提供了4种分析方式，第一种在my best map配置文件里面，直接去写分页的CQ，这种方式比较灵活，实现起来呢也比较简单。第二种可以通过low bounds去实现逻辑分页，也就是一次性加载所有符合查询条件的目标数据。根据分页参数的值在内存里面去实现分页，当然在数据量比较大的情况下，呢 gdpc驱动本身呢会做一些优化，也就是说不会把所有的结果一次性查询存储在result的赛程里面，而是先只加了一部分数据，然后再根据需求去数据库里面滚动去加载对应后续的一个数据。这种方式呢不适合数据量较大的一个场景，而且有可能会频繁的访问数据库造成比较大的压力。第三种是通过intercept拦截器来实现，我们可以通过拦截需要分页的select语句，然后在这个select语句里面去动态拼接分页的关键字，从而去实现分页查询。Interceptors是myce是里面提供的一种针对于不同生命周期的拦截器，比如拦截执行器方法拦截参数的处理，拦截结果级的处理，拦截c口语法构件的处理，我们可以拦截不同阶段的处理，啊来实现卖杯子里面相关功能的扩展，这种方式的好处呢就是可以提供统一的处理机制，不需要我们再单独去维护分页相关的一些功能，像我们经常使用的配置hip，卖贝利斯巴斯特PK卖贝利斯这样一些框架，它们本质上都是通过卖贝利斯的拦截器进行一个扩展，去帮我们实现了分页的封装，使得我们不需要去关心分页相关的一些配置，节省了开发的一个时间和配置的时间，总结一下对于任何的om框架，分页的时间逻辑啊无外乎两种，不管怎么包装，最终给到开发者的只是使用上的一个差异而已。
	那么我们来看一看高手是如何回答这样一个问题的。我认为有三种方式去实现分页，第一种是直接在select语句里面去增加一个数据库提供的分页关键字，然后呢在应用程序里面去传递当前页以及每页展示的条数就好了。第二种是使用卖杯子提供的low bound这样一个对象，实现内存级别的一个分页。第三种是基于my best里面的英德赛普的拦截器，在CK语句执行之前动态的去拼接分页的关键字。以上就是我的理解。
344-【Java面试】美团一面，Mysql幻读的解决，堪称史诗级的回答！-480P 清晰-AVC
	My circle如何解决换毒问题？一个工作了4年的小伙伴去美团面试，遇到这样一个问题，hello大家好，我是麦克，一个工作了14年的Java程序员，最近呢我把所有的高手回答的一些面试题啊全部整理到了一个20万字的面试文档里面，大家可以在我的主页去领取。关于这个问题啊面试官想考察什么？我们应该如何去回答？呢这个问题至少是考察三年以上开发经验的同学，Mexico底层去解决并发事务的问题，啊至少是要有一定的技术积累，才能够去真正理解，否则呢只是理解一个皮毛，而如果作为一个刚工作没有多久的程序员，必须要知道数据库的事务隔离级别的一些问题，因为不同的隔离级别对于数据的安全性的影响是不同的，也就是所谓的幻、毒、脏、毒和不可重复毒等这样一些问题。所谓换毒呢就是一个事物前后两次读取到的数据条数不一致，在第一个事物里面执行一个范围查询，这个时候满足条件的查询数据呢只有一条。接着第二个事物里面插入了一条数据，并且提交了然后在第一个事物里面再次执行查询的时候发现有两条数据满足条件，在r的事物隔离级别里面呢引入了mecc和lbcc这两种方式去解决换毒问题。
	Mvcc类似于一种乐观锁的一个设计，简单来说就是针对每个事物生成一个事物版本，然后针对这个版本去定一个访问规则。第一个一个事物只能看到第一次查询之前已经提交的事务，以及当前事物的修改。第二个一个事物不能看到当前事物第一次查询之后，创建的事物以及未提交的事物的修改，但是如果在一个事物里面存在当前图的情况下，呢 mvcc啊还是会存在换毒的问题。因为当前读呢不是读的快照，而是直接读的内存。所以啊针对这样一个情况，可以使用lbcc也就是基于锁的机制来去解决，也就是我们常说的场所表锁和间隙锁等等，基于对这样一个知识的一个理解，我们没有对MAC口不同事物隔离级别的底层实现原理，有一个清晰认识的同学在回答这个问题的时候，呢要么就是很生硬，要么就是无法扩展，就会显得有点像是在背这样一个答案。好，那么我们来看看高手是怎么回答这个问题的。在r二也就是可重复读的一个事物隔离级别下，呢一朵DB啊采用了一个mvcc的技师来去解决换毒的问题。
	Mvcc就是一种乐观锁的一个机制，它是通过对于不同事物生成不同的快照版本，然后呢通过undue的版本链来进行管理，并且呢在mvcc里面，它规定了高版本能够看到低版本的一个事物变更，低版本呢看不到高版本的一个事物变更，从而去实现了不同事物之间的一个数据隔离，解决了换毒的问题。但是如果在事物里面存在当前毒的一个情况下，那么它是直接读取内存里面的数据，跳过了快消毒，所以呢还是会出现患者的一个问题。我认为可以通过两种方式来解决，第一种呢是尽量去避免当前的这样一个毒的一个情况。第二种是可以引入一个lbcc的一个方式来解决。以上就是我的理解。

341-【Java面试】腾讯三面，RDB和AOF的实现原理与优缺点？请看Mic老师的最优解！-480P 清晰-AVC
	Hello大家好，我是麦克。一个工作了5年的粉丝来私信我，他说最近面试总是碰到很多瑞贝斯有关的问题，其中一个面试官问他，rallies里面的持久化机制没有回答得很好，希望我帮他去系统性的回答一下。关于raci里面are DB和aof两种持久化机制的一个原理和优缺点这个问题。呢我把高手的回答整理成了详细的文档，有需要的小伙伴们可以在我的主页去加v领取。那么下面我们看看普通人和高手对于这个问题的一个回答，普通人的回答。Rdb好像是就rdb是一种坏账的方式，然后if是一种就是指令追加的方式，嗯他们两个都是reads里面的一种啊数据持续化的一个机制。优缺点的话，嗯像rdb它的它是快照，嘛快照的话它它的那个时间间隔它会有一个配置，但是这种配置过程中就是有可能会导致说我的数据丢失的一个问题，但是if呢 it was lf它应该是那种就是追加的方式，嘛所以它的一个数据安全性可能会比rdb会好一点。高手的回答。好的，关于这个问题啊我需要从几个点来回答。
	首先威利斯本身是一个基于t一value结构的内存数据库，arraylist的一个设计者，为了避免raci故障导致数据丢失一个问题，呢提供了are DB和aof两种直觉化的一个机制。Rdb是通过快照的方式来实现时间化的，也就是说会根据快照的一个触发条件，把内存里面的数据快照写入到磁盘里面，以二进制的压缩文件的方式进行存储。Rdb快照的触发方式里有很多，比如说执行b级c命令触发异步快照，直接C5名呢触发土木快照，同步和异步的区别在于同步快照会阻塞客户端的一个执行指令。第二个根据red康复一个文件里面的一个配置，啊自动触发bgc第三个是主从复制的时候会触发，aof话呢它是一种近乎实时的方式，把editserver执行的事务命令进行追加存储，简单来说就是客户端执行一个数据变更的操作，瑞就会把这样一个命令追加到aof的缓冲区里面，然后再把缓冲区的数据写入了磁盘的if文件里面。至于最终什么时候真正把数据持久化到磁盘的lf文件里面，是根据磁盘的刷盘策略来决定的。
	另外因为aof这种指令追加的一个方式会造成aof文件过大，带来明显的io性能问题。所以呢瑞丽斯针对这样一个情况提供了lf重写机制。也就是说啊当af文件大小达到某一个阈值的时候，就会把这个文件里面相同的指令进行压缩。所以基于我对于rdb和lf的工作原理的理解，它们的优缺点呢我认为有两个，第一个是rdb是每隔一段时间会触发持续化，因此呢它的数据安全性会比较低，lf呢可以做到实时持久化，所以它的数据安全性呢相对会比较高一点。第二个是rdb，文件默认是采用压缩的方式来持续化的，lf处的是执行指令，所以在我看来啊所谓的优缺点本质上其实是哪种方案更适合当前的业务场景而已。以上就是我对这个问题的一个理解。这个问题的实际意义啊在于求职者者知道什么场景下去选择什么样的职业化策略，因此呢如果能够对aof或者are DB这两种持久化方式有一个比较深入的理解，那么自然也能够在实际开发应用中去合理的进行使用了。好的，本期的普通人vs高手的面试系列视频呢就到这结束了，喜欢我的作品的小伙伴记得点赞收藏加关注，我是麦克。一个工作了14年的Java程序员，我们。
340-【Java面试】京东一面，Java文件拷贝方式，哪一种效率最高？你能回答出吗？-480P 清晰-AVC
	Java有几种文件拷贝方式，哪一种方式的效率最高？屏幕前的你知道吗？这个问题呢是京东一面的时候，针对一个4年经验的同学的一个面试题。Hello大家好，我是麦克。一个工作了14年的Java程序员，下面我们来看看普通人和高手的回答，普通人的回答。文件拷贝的话，我们可以直接使用那个 Java点io包里面有一个那个文件io流，就faya input string和phylon polystream，就是它可以去实现文件的拷贝，然后我记得还有一种是零拷贝的方式，啊领拷贝的方式，它可以减少那个减少那个交互的方式，就是内核态和用户态的一个交互方式，所以它的效率应该是更高的。高手的回答。好的，面试官我认为有三种方式来实现文件的拷贝，第一种是使用Java点l包里面的一个库，比如说使用filing pujian来读取数据，使用fire奥特布鲁斯逊来写出数据。第二种我们可以利用Java点NL包里面的一个库，使用transport two方法或者全什么from方法来去实现。第三种可以使用Java标准内裤里面本身提供的发一点copy来实现。
	对于文件拷贝的效率，啊这个其实和操作系统和配置的情况有关系，在传统的文件l里面，呢我们都是调用操作系统提供的底层标准，io系统调用函数read，right，由于内核指令的调用呢会使得当前用户线程切换到内核碳，然后呢内核限制负责把对应的文件数据读取到内核的io缓冲群里面，再把数据从内核io缓冲区里面拷贝到进程的私有地址空间里面去，那么这样去完成了一次io操作，而ml里面提供的全市fourtou和穿什么from方法，也就是常说的零拷贝的一个实现，它能够去利用现代操作系统底层的一个机制，避免不必要的拷贝和上下文切换，因此呢在性能上表现比较好。以上就是我对这个问题的理解。关于文件io方面的问题啊和内容，在面试过程中呢是比较多的，这块属于Java里面的一个基础知识。啊但是啊随着这个技术知识的一个延展，会涉及到mioeioaio以及领拷贝或者 io的多路复用机制等等。对于求职者来说，啊这块内容的重要性也是不言而喻的。
	好的，本期的视频啊就到这结束了。大家记得点赞收藏加关注我是麦克。咱们下期再见。
345-【Java面试】面试突击Spring，BeanFactory和FactoryBean的区别？请看Mic老师的最优解！-480P 清晰-AVC
	一个工作了6年多的粉丝啊胸有成竹的去京东面试，然后被spring里面的一个问题卡住了。唉我和他说啊6年了，spring都没搞明白，那怎么让面试官给你通过呢？面试官问的问题是 springs、abeam、factory和factory兵的区别。下面我们来看看普通人和高手对这个问题的回答，普通的回答。嗯 Spring里面的病factory驻兵的区别，呃并发过去它是一个工厂，就是一个病的工厂。然后就是我我我们可以通过并发出去，他可以说去去获得那个 uh spring容器里面就IOC容器里面的一个这个病的实力，啊它我觉得里面有一个叫get病的方法，可以去获得。啊然后factory been的话，它是一个工厂兵。工厂病，对工厂病。啊不不记得了。嗯高手的回答。好的，关于这个问题呢我会从几个方面来回答，首先啊 spring里面的核心功能是IOC容器，所谓的IOC容器啊本质上就是一个冰的容器或者是一个冰的工厂，它能够去根据x秒里面声明的病的配置去进行病的加载和初始化，然后并factory呢来生产我们所需要的各种各样的一个病。
	所以我对bean factory的理解呢有两个，第一个并faculty呢是所有spring并容器的顶级接口，它为SP容器定义了一套规范，并提供了像该的病这样的一些方法，去从容器中获取指定并实例的一个功能。第二个，并faculty呢在产生病的同时，啊还提供了解决病之间的依赖注入的一个能力，也就是所谓的DNA而factory病呢是一个工厂病，它是一个接口，它的主要功能是动态去生成某一类型的病的一个实例，也就是说我们可以自定义一个并并且加载到IOC容器里面，它里面有一个重要的方法叫get object，这个方法里面呢就是用来实现动态构建并的一个过程。Spring call里面的open的组件呢客户端代理啊就是使用了fact并来实现的。以上就是我对这个问题理解。这个问题啊只要稍微看过spring框架的源码，怎么样都能回答出来的。嘛关键在于你是否愿意去逼自己学习一些工作中不常用到的技术，来提升自己。在我看来啊薪资和能力是一种等价交换，在市场经济下能力一般又想去获得更高的薪资，很显然是不可能的。
	好的，本期的普通人vs高手面试系列的视频呢就到这结束了。如果有任何技术上的问题或者面试上的问题，欢迎随时来私信我，我是麦克。一个工作了14年的Java程序员，咱们下期再见。

345-【Java面试】面试突击Spring，BeanFactory和FactoryBean的区别？请看Mic老师的最优解！-480P 清晰-AVC
	一个工作了6年多的粉丝啊胸有成竹的去京东面试，然后被spring里面的一个问题卡住了。唉我和他说啊6年了，spring都没搞明白，那怎么让面试官给你通过呢？面试官问的问题是 springs、abeam、factory和factory兵的区别。下面我们来看看普通人和高手对这个问题的回答，普通的回答。嗯 Spring里面的病factory驻兵的区别，呃并发过去它是一个工厂，就是一个病的工厂。然后就是我我我们可以通过并发出去，他可以说去去获得那个 uh spring容器里面就IOC容器里面的一个这个病的实力，啊它我觉得里面有一个叫get病的方法，可以去获得。啊然后factory been的话，它是一个工厂兵。工厂病，对工厂病。啊不不记得了。嗯高手的回答。好的，关于这个问题呢我会从几个方面来回答，首先啊 spring里面的核心功能是IOC容器，所谓的IOC容器啊本质上就是一个冰的容器或者是一个冰的工厂，它能够去根据x秒里面声明的病的配置去进行病的加载和初始化，然后并factory呢来生产我们所需要的各种各样的一个病。
	所以我对bean factory的理解呢有两个，第一个并faculty呢是所有spring并容器的顶级接口，它为SP容器定义了一套规范，并提供了像该的病这样的一些方法，去从容器中获取指定并实例的一个功能。第二个，并faculty呢在产生病的同时，啊还提供了解决病之间的依赖注入的一个能力，也就是所谓的DNA而factory病呢是一个工厂病，它是一个接口，它的主要功能是动态去生成某一类型的病的一个实例，也就是说我们可以自定义一个并并且加载到IOC容器里面，它里面有一个重要的方法叫get object，这个方法里面呢就是用来实现动态构建并的一个过程。Spring call里面的open的组件呢客户端代理啊就是使用了fact并来实现的。以上就是我对这个问题理解。这个问题啊只要稍微看过spring框架的源码，怎么样都能回答出来的。嘛关键在于你是否愿意去逼自己学习一些工作中不常用到的技术，来提升自己。在我看来啊薪资和能力是一种等价交换，在市场经济下能力一般又想去获得更高的薪资，很显然是不可能的。
	好的，本期的普通人vs高手面试系列的视频呢就到这结束了。如果有任何技术上的问题或者面试上的问题，欢迎随时来私信我，我是麦克。一个工作了14年的Java程序员，咱们下期再见。
339-【Java面试】阿里一面，谈一谈Mysql的事务隔离级别是什么？请看Mic老师的最优解！-480P 清晰-AVC
	一个工作了6年的粉丝去阿里面试，在第一面的时候被问到Michael事务隔离级别的一个问题，他竟然没有回答上来，啊一直在私信我向我诉苦，我只能安慰他，我说以后还有机会的啊慢慢来。好吧，关于这个问题我们来看看普通人和高手的回答，普通的回答。呃麦塞口的事物隔离级别它有4种，啊第一种是独立提交。第二个是可重复读？啊第三个是串气化，第四个是。
	高速的回答。好的，啊关于这个问题呢我会从几个方面来回答。首先呢事物主义级别是为了解决多个并行事务竞争导致的数据安全问题的一种规范，具体来说呢多个事物竞争可能会产生三种不同的一个现象。第一个啊假设有两个事物，t一和t二同时在执行，那么t15有可能会读取到 t25未提交的数据，但是未提交的失误，t二有可能会出现回滚，也就导致t一失误读取到一个最终不一定存在的数据，从而产生一个脏腑的一个现象。第二个是说假设两个事物t一t二同时在执行，那么事物t一在不同的时刻读取的同一行数据的时候，有可能结果会不一样，主要导致一个不可重复度的一个问题。第三个呢是说假设有两个事物t一t二同时在执行，那么事物t一在执行范围查询或者专门修改一个时候，师傅t二呢插入了一条属于师傅t一范围内的数据，并且提交了那么这个时候事物t一查询的时候发现多出了一条数据，或者说t一事物发现这条数据并没有被修改，那么看起来像是产生一个幻觉，这种现象呢我们称为患毒。
	而这三种现象在实际应用里面呢可能有些场景不能接受某些现象的存在。所以在CK标志里面呢定义了4种隔离级别，第一种是不被提交，在这种隔离级别下，呢可能会产生脏、毒、不可重复毒以及贩毒。第二组是足以提交在这种隔离级别下可能会产生不可重复毒和患毒。第三种是可重复读，那么在这种隔离级别下可能会产生幻读。第四种是那么在这种隔离疾病下，呢多个变形事物呢会串起化磁性，不会产生任何安全性问题。在这4种隔离级别里面，呢只有串行化解决了全部的问题，但也意味着呢这种隔离级别的性能是最低的。在max里面啊 in的DB引擎默认的隔离级别是r二，也就是可重复读，因为它需要保证事物acip特性中的隔离性。以上呢就是我对这个问题的理解。关于这个问题，啊很多用了Mexico很长时间的程序员都不一定能够回答得很清楚，这其实啊是非常不正常的，因为虽然啊一诺DB的默认隔离级别能够去解决90%以上的问题，但是有些公司或者某些业务可能会去修改事务隔离级别，而如果你不去注意或者你不知道，就很可能在程序中去出现一些莫名其妙的问题。
	好的，本期的普通人vs高手的面试系列视频呢就这样结束了。如果你有任何的面试问题或者职业发展的问题都可以私信我，我是麦克。一个工作了14年的讲话程序员，咱们下期再见。
347-【Java面试】面试突击Spring，Spring Boot中约定优于配置的理解？请看Mic老师的最优解！-480P 清晰-AVC
	对于spring boot约定优于配置这个问题，看看普通人和高手是如何回答的呢？
	普通的回答。嗯在 spring boot里面，啊就是我们可以通过约定优于配置这样一个思想可以去让我们减少这种配置，就像我们在使用boot里面一样，我们可以可以通过一些这个嗯就是创建这样一个项目，通过角色架构这一个项目之后，我就可以去直接直接去写我的这个业务代码，然后嗯就不需要去写那种很多的像一些家包管理啊一些那个配置文件，这个这是应该是 slip里面约定优异配置它的一些体现。高手的回答。对这个问题呢我从4个方面来回答。首先约定优于配置是一种软件设计的范式，它的核心思想是减少软件开发人员对于配置项的维护，从而让开发人员呢更加聚焦在业务逻辑上。第二个，呢 spring boot就是约定优于配置这一理念下的产物，它类似于 spring框架下的一个脚手架，通过视频或者我们可以快速开发基于spring生态下的应用程序。第三个呢基于传统的spring框架，外部应用的时候，我们需要做很多和业务无关，并且只需要做一次的配置项，比如第一个管理架包的依赖，第二个呢 web点xml的维护。
	第三个 spring mvc中的一个叫dispart servlets点exo秒配置项的一个维护。第四个，应用需要自己手动去部署到外部容器。第五个，第三方组件集成到spring IOC容器中的时候，我们需要做配置项的维护，而在springboard中，呢我们不再需要去做这些繁琐的配置，因为springboard已经帮我们自动完成了，而完成这样一个动作的前提，就是基于约定优于配置这样一个思想，最后呢 springboard约定优于配置的体现有很多，比如第一个斯伦波特斯塔德启动依赖，它能够帮助我们管理所有的Java版本。第二个，如果当前的应用依赖了 web这样一个架包，那么 springboard会自动内置他们看的容器来去运行web应用，我们不再需要去单独进行应用部署。Spring boat的自动装配机式的实现中，啊通过扫描约定路径下的spring点factory文件去进行识别配置类，从而去实现并的自动装载。
	第四，视频过程呢默认会加载resource目录下的application点property文件，总的来说啊约定优于配置呢是一个比较常见的软件设计思想，它的核心本质都是为了去更加高效以及更加便捷的去实现软件系统的开发和维护。以上就是我对这个问题的理解。好的，本期的普通人vs高手系列的视频就到这结束了。





343-【Java面试】阿里二面，谈谈分布式事务的理解和解决方案？-480P 清晰-AVC
大家好，我是麦克一个工作是三年的Java程序员，啊在互联网企业面试中啊经常会问到分布式高并发下面的一些技术问题，其中分布事务的问题呢就是其中之一。下面我们来看一下关于分布式事务的解决方案，普通人和高手是如何回答这个问题的？普通人的回答。嗯分布事务呢就是多个事物分布在不同的计算机节点上，导致的一个呃数据一致性的问题。嗯我们公司目前基本上没有涉及到一些分布式事务的问题，不过呃我也知道像一些开源的解决事物的一些问题的一些框架，比如说像c塔，然后呢呃分布事务里面啊就是有一个强一致和弱一致性的一些解决方案，比如说我们嗯要用强硬执行方案的时候，就相当于是保证了整个数据的一致性，但是它会损失掉一部分的性能，但是如果我们使用弱一致性的话，那么他就能够去说在当某一段时间数据可能存在不一致，但是但是它的那个性能会比这个强硬之心也要更好一些。嗯对，这个是我对于分布式事物的理解。高手的回答。分工事务呢是指事务的参与者，支持事务的服务器，资源服务器以及事务管理器呢分别位于分布式系统的不同节点之上。
	比如说大型的电商系统中的一些下单场景会涉及到扣库存，优惠促销计算订单ID生成，通常情况下呢库存促销组件生存策略都位于不同的服务器和数据库表中，那么下单接口的成功与否不仅取决于本地结局的数据库的操作，而且还依赖第三方系统的一个结果。这个时候呢分布事务就是保证这些操作要么全部成功，要么全部失败。因此呢本质上来说，啊分布的事物就是为了保证不同数据库的数据一致性，基于cap定理，啊我们可以知道对于上述情况产生的分布事物问题，啊我们要么采用强一致性方案，要么采用弱一致性方案。所谓强一致性方案是指通过第三方事务管理器来协调多个节点的事务性，保证每一个节点的事务达到同时成功，或者同时是办。为了实现这样一个需求，呢我们会引入x open DP模型提供的essay协议，基于二阶段提交或者三阶段提交的方式去实现，但是如果全局事务管理其中的多个节点，这一个节点在进行事务提交确认的时候，由于网络通信延迟导致的阻色就会影响到所有节点的事务提交，而这个阻塞过程呢也会影响到用户的请求线程，这对用户体验以及整体的性能影响非常大，而弱一致性方案就是针对强一致性方案所衍生出来的性能和数据一致性平衡的一个方案，简单来说啊就是损失掉强制性数据在某一个时刻会存在不一致的状态，但是最终这些数据会达成一致，真的好处是提升了系统的性能。
	在若一次性方案中常见的解决方案有第一个使用分布式消息队列来实现现最终的一致性。第二个基于tcc，15通过演进版本的二阶段提交去实现最终一次性第三个使用c塔事物框架，它提供了多种事物模型，比如说at xa，傻傻tcc等不同的模型提供的是强一致性或者弱一致性的一个支持。以上呢就是我对分布事物的一个理解。好的，普通人和高手啊谁能回答更好呢？相信屏幕前的你已经有了答案，另外啊考大家一个问题，你能看出来高手回答问题的一个逻辑吗？没错，就是一个典型的结构性思维表达。提醒一下各位小伙伴啊结构性思维在这种临场面试中能够更好的去表现出你的能力和优势。本期的普通人vs高手系列的视频呢就到这里结束了。喜欢的朋友记得一键三连加关注，我是麦克，一个工作是三年的Java程序员，咱们下期再见。
348-【Java面试】蚂蚁金服二面，谈一谈你对Spring cloud的理解？请看Mic老师的最优解！-480P 清晰-AVC
	Hello大家好，我是麦克。一个工作了7年的Java粉丝，啊既然连这个问题都回答不上来，难怪被裁员以后，呢每一次面试都被技术问题卡脖子了，导致一直找不到工作。今天他遇到这样一个问题，希望我能够给出一个回答上的一个建议，那请你说一下你对spring call的一个理解。下面我们来看看普通人和高手对于这样一个问题的回答，普通人的回答。就我认为spring call的它就是它是解决微服务的一个方案，吧就是说就是说它里面有很多的这种技术组件，嗯像尤瑞卡呀或者像嗯 v本啊这样一些组件，就是可以去嗯帮我们在微服务架构里面去解决，像服务注册啊或者或者这种就负载均衡这样一些问题。高手的回答。好的。Spring call的呢是spring官方推出来的一套微服务的解决方案，准确来说，啊我认为spring call的其实是对微服务架构里面出现的各种技术场景定义的一套标准规范。然后在这个标准里面呢 spring集成的net，face公司里面的oss开源套件，比如说做去实现应用网关，永瑞卡去实现服务注册与发现，v本去实现负载均衡，还是去x呢去实现服务的熔断。
	我们可以去使用spring call的net这样一套组件去快速落地微服架构，以及去解决微服务治理的一系列的一些问题。但是啊随着net flex oss相关的一些技术组件的闭源和停止维护，所以spring官方也自研了一些组件，比如说像gateway来实现网关，not the bananas去实现负载均衡。另外阿里巴巴里面的开源组件也实现了speaker的这样的标准，成为了10分card里面的另外一套微服务解决方案，包括double来实现rpc通信，拉cos去实现服务注册与发现以及动态配置中心，三种去实现服务的限流和服务的降级等等。以上就是我对十分靠的一个理解。另外我再补充一个点，啊我认为spring call的生态的出现有两个很重要的意义，第一个是在十分靠的出现以前，呢为了去解决微服架构里面的各种技术问题，我们需要去集成各种开源组件，因为标准和兼容性的问题，呢所以在实践的时候会很麻烦，而使命靠的呢统一的这样一个标准。
	第二个是降低了微服架构里面的开发难度，我们只需要在springboard的项目的基础上，去通过它的启动依赖去集成相关的一些组件，就可以轻松的去解决微服务架构里面的各种服务治理的一些问题。以上就是我对这个问题的一个理解，随便靠的呢已经是一个普及度和应用度非常高的一个框架，但往往知道spring card是怎么用的，但是为什么用以及什么场景下去使用，却不一定能够明白。而这个问题其实就是考察工作4年以上的求职者对于技术的一个了解程度。好的，本期的普通人vs高手的面试系列视频，呢就这里结束了喜欢我的作品的小伙伴记得点赞收藏加关注，啊我是麦克。一个工作了14年的Java程序员，我们下期再见。

349-【Java面试】京东一面，Integer和int的区别，为社么要设计封装类？请看Mic老师的最优解！-480P 清晰-AVC
	Integer和int有什么区别？Java为什么要去设计封装类？虽然我们经常使用，啊但是很少去关注为什么？导致面试过程中遇到这一类的问题的时候就懵了。Hello大家好，我是麦克。关于这个问题啊我们来分析一下面试官的考察意图，这是一个典型的Java基础问题，本质上来说这个问题是考察求职者对于面向对象的理解程度，也是在考察求职者的一个基本功了。其实越是简单常见的一些东西，啊就越能体现求职者的基础扎实的一个程度。这个问题一般是考察1~3年开发经验的同学，那么在回答这个问题的时候，尽量从封装类型的特性和功能全方位的去回答。英特尔是基本数据类型，int的封装类在Java里面有8种基本数据类型，它们都有一一对应的封装类型。基本类型和封装类型的区别有很多，比如说第一个int类型，我们可以直接定义一个变量名称赋值就好了，但是intel者呢需要去使用6关键字来促进对象。第二个基本类型和英特尔类型混合使用的时候，家委会自动通过拆箱和装箱来实现类型的转化。第三个英特尔作为一个对象类型，啊碰撞了一些方法和属性，我们可以利用这些方法来操作数据。第四个作为成员变量，intel者的默认值是钠，而intel的默认值呢是0，其实要是真正去逐一列数，我们其实还可以挖掘更多的差异点。
	在Java里面，之所以要对基础类型设计一个对应的封装类型，是因为Java本身是一门面向对象的语言对象，是Java的基础操作单元，我们时时刻刻都在创建对象，也随时都在使用对象。很多时候在传递数据的时候也需要用到对象类型，比如说像 Paris好行吧这样一些集合，它只能去存储对象类型，啊因此从这个点来说，封装类型存在的意义就很大。其次封装类型其实还有很多好处，啊比如安全性比较好，可以避免外部操作随意修改成员变量时，保证了成员变量和数据传递的安全性，隐藏的实现细节对使用者更加友好，只需要去调用对象提供的方法，就可以完成对应的操作。下面我们来看一下高手的回答。英特尔和in的区别呢有很多，我简单罗列三个方面。第一个作为成员变量来说，英特姐的初始值是n英特的初始者呢是0，第二个英特尔它是存储在堆内存里面，因为它是一个对象，而硬的类型呢它是直接存储在占空间里面。第三个英特尔是一个对象类型，它封装了很多的方法和属性，我们在使用的时候呢会更加灵活。
	至于为什么要设计成封装类型，我认为主要的原因是家伙本身它是一个面向对象的语言，一切操作都是以对象作为基础的，比如说像集合里面存的元素，也只支持存储object类型，普通类型是无法通过集合来存储的。以上就是我的理解。所以遇到特别基础的问题的时候，呢先不用着急着回答，好好整理一下思路，找到这个问题的关键因素。然后以此为切入点，去回答，一般这种情况下是没什么太大问题的。好的，本期的视频就到这结束了。


342-【Java面试】百度一面，ConcurrentHashMap底层实现原理？请看Mic老师的最优解！-480P 清晰-AVC
	之前我分享过一期哈希map的面试题，然后呢有个小伙伴来私信我，他说最近遇到了一个 concurrent hashemite的一个问题，他不知道怎么回答。于是就有了这一期的内容。我是Mike。一个工作了14年的Java程序员，今天啊我们来分享一下关于康卡伦的哈希迈普它的底层实现原理这个问题。看看普通人和高手是如何回答的？普通人的回答。
	康康尔哈希迈普呢它是用数组和链表的方式来实现的这样一个结构。在做数据查询的时候效率会比较低一点，啊所以就是会采用这个是高手的回答。关于这个问题呢我从这三个方面来回答。第一个康凯润的哈希迈克的整体架构，我们来看这个图，这个呢是康康润哈希迈克在gdk1.8里面的存储结构，它是由宿主单项链表和红霉素来构成的。当我们去初始化一个康熙Mapp的实力的时候，默认会初始化一个长度等于16的速度。由于康康还是map，它的核心仍然是哈希表，所以必然会存在哈希冲突的问题。所以呢慷慨开始哈西卖，不采用链式寻子的方式来解决哈希表的冲突。当哈希冲突比较多的时候，会造成链表长度较长的问题。所以这种情况下会使得康康尔哈西麦中的一个数组元素的查询复杂度会增加，所以在gdk1.8里面引入了红霉素这样一个机制，当速度长度大于64，并且链表的长度大于等于8的时候，单向链表就会转化成红黑素。另外呢随着康卡润的还是卖不到一个动态扩容，一旦链表的长度小于8，红黑素会退化成单项链表。
	第二个，康哈是map的一个基本功能，慷慨haj map呢本质上是一个哈希卖PPP，因此功能和哈希卖是一样的，但是康康的哈希迈普在哈希map的基础上提供了并发安全的一个实现。病房安全的主要时限呢主要是通过对于no的节点去枷锁来保证数据更新的安全性。我们来看这个图。第三个，concret还是Marva在性能方面做的一些优化，如何在并发性能和数据安全性之间去做好平衡，在很多地方都有类似的设计，比如说像CPU的三级缓存，买水口的88破，星空net的一个所升级等等，康熙map呢也做了类似的一个优化，主要体现在几个方面，第一个啊在gdk1.8里面，康卡伦哈西麦法它的锁的力度是宿主中的某一个节点，而在gdk1.7里面，它锁定的是3G满，锁的范围要更大，所以性能上它会更低。第二个引入红黑素这样一个机制，去降低了数据查询的时间复杂度。红黑素的时间复杂度是o log n第三个我们看这个图，当数组的长度不够的时候，康乃馨map呢它需要对数组进行扩容，而在扩容的时间上，康康瑞哈希迈克引入了多线程并发扩容的一个实现。
	简单来说呢就是多个线程对原始数组进行分片，分片之后，每个县城去负责一个分片的数据迁移，从而去整体的提升了扩容过程中的数据迁移的一个效率。康康的哈希迈普呢它有一个size方法来获取总的元素个数，而在多线程并发场景中，啊在保证原子性的前提下，去实现元素个数的累加，性能是非常低的。所以康康的哈希曼普呢在这个方面做了两个点的优化。第一个点是当线程竞争不激烈的时候，直接采用CS的方式来实现元素个数的一个原子递增。第二个，啊如果线程竞争比较激烈的情况下，使用一个数组来维护元素个数，如果要增加总的元素个数的时候，直接从数组中随机选择一个再通过CS算法来实现原子递增。它的核心思想是引入了数组来实现对并发更新的一个负载。以上呢就是我对这个问题的理解，从高速的回答中啊我们可以看到，康康的哈希迈普呢里面有很多的设计思想是的，我们去学习和借鉴的。比如说锁的力度控制，分段锁的设计等等，他们都可以应用在实际的业务场景中。
	很多时候啊大家会认为这种面试题毫无价值，当你有足够的积累之后，你会发现从这些技术底层的设计思想中去获得很多的设计思路，他能够真正意义上去帮我们解决实际问题。好的，本期的普通人vs高手系列的视频呢就到这结束了，喜欢的朋友记得点赞和收藏。另外我也陆续收到了很多小伙伴的面试题，我会在后续的内容中呢逐步去更新给了大家。我是Mike一个工作了14年的Java程序员，咱们。


346-【Java面试】鲨疯了！这样回答惊艳面试官，谈谈对Redis的理解。-480P 清晰-AVC
谈谈你对于als的理解。面试时候遇到这一类比较宽泛的问题，是不是很抓狂？是不是不知道应该怎么样去说？没有关系，今天呢我会通过三分钟去教你怎么回答。Hello大家好，我是麦克。一个工作了14年的Java程序员，我呢最近把高手的回答整理到一个20万字的面试文档里面，大家可以在我的主页去领取。关于今天我们问的这个问题，面试官到底他的考察目的是什么？希望得到一个什么样的回答呢？对于某某技术理解这一类的问题，啊它其实是一个比较宽泛的问题，在面试过程中啊考察这类问题有两个很重要的目的。第一个在面试过程中，面试官希望求职者能够多说出一些对技术的理解，从而去更好的对你的整体情况和能力有一个清晰的判断，因此这类问题呢可以找到一些了解你的突破口。第二个，这个问题其实本身没有什么标准答案，更多的是基于你对他的理解的一个总结，这反而能够去更好的考察你的技术沉淀和逻辑表达能力，所以求职者在回答这个问题的过程中，啊需要尽可能逻辑清晰简单明了的把你的想法和你的理解表述出来，否则就很难得到面试官的认可。
	欢迎。是什么？想必大部分人都能够脱口而出，它是一个分布式缓存中间键，可这样的回答有问题吗？当然有。准确来说readus是一个基于内存实现的kvil数据结构的 no CK数据库。注意这里有三个关键点，第一个内存存储，第二个key value结构，第三个no CQ所谓内存存储是使所有的数据啊存储在内存里面，数据的io性能会比较高，当然瑞士也提供了持久化策略来避免内存数据丢失的问题。T班的结构表示数据存储的方式，除了聊天室以外，还有像那个 DBS等等，它们都是属于t班的结构，而nos一q呢它指的是一种非关系型数据库，相比传统的关系数据库来说，更多的是考虑扩展性性能和大数据量的存储，弥补了关系型数据库的短板，像劣势存储，click house和看三卷，文档存储、芒果DB、图形存储、nu伏尔金等等都是属于no circle的范畴。好的，下面我们来看看高手是如何回答这个问题的。Bye。好的，瑞丽斯呢是一个基于k万六存储结构的no西q开源内存数据库，它提供了5种常用的数据类型，像俊啊卖、金set that那么针对于不同的结构，呢可以解决不同场景的问题，因此呢它可以去覆盖应用开发里面的大部分的业务场景，比如说像太阳石的问题，啊或者好友关注列表，热点话题等等。
	其次呢由于瑞丽丝本身是一个基于内存的一个存储，并且在数据结构上做了大量的一些优化，所以 io的性能呢会比较好。在实际开发里面呢我们会把它用在应用和数据库之间的一个分布式缓存中心键，并且呢它又是一个非关系型数据库的存储，它不存在表之间的关联查询的一些问题，所以呢它可以很好的去提升应用程序的数据io效率。最后作为企业级开发来说，啊他又提供了主从复制加哨兵以及集群的方式去实现高考用。在这个集群里面呢通过哈希槽的方式去实现了数据的分辨，进一步提升了整体的一个性能和可扩展性。以上就是我的理解。
354-【Java面试】腾讯一面，讲一下ArrayList的自动扩容机制？请看Mic老师的解答！-480P 清晰-AVC
	今天要分享的这道面试题呢是arrest，它的自动扩容机制的实现原理。另外我花了一个多星期的时间，呢把以往的高手回答整理成了10万字的一个文档，如果你想获取的话，可以在我的主页去加v领取。啊下面我们来看看普通人和高手对于这样一个问题的回答，普通的回答。嗯艾瑞斯的自动扩容，我记得应该是就是他会去创建一个新的速度，然后把那个就是老的那个宿主去直接科比就是数据的元素直接copy到新数据里面。嗯也就是说也就是我的那个宿主的这个长度啊就是不够的时候，它就会去做这个动作。高手的回答。好的，面试官。R一s呢是一个数组结构的存储容器，默认情况下呢数组的长度是10个，当然我们也可以在构建iOS的对象的时候指定初始长度，那么随着在程序里面不断的往iOS里面添加数据，当添加的数据达到10个的时候，arrest里面就没有足够的容量去存储后续的数据，那么这个时候呢艾瑞斯呢会触发自动扩容，扩容的流程呢其实也很简单，首先创建一个新的数组，那么这个数组的长度是原来受阻程度的1.5倍，然后使用iOS点copy这样一个方法去把老数组里面的数据 copy到新数组里面，扩容完成以后，呢再把当前需要添加的元素加入了新的数组里面，从而去完成动态扩容这样一个过程。
	以上就是我对这个问题的理解。作为一个业务程序员，呢虽然工作的性质是让大家去写ciud不需要过多的去关注技术的底层原理，但是在未来的职业晋升过程中，呢技术的理解程度就显得非常重要了，因为未来的岗位所需要的能力和当前的能力是完全不一样的。好的，本期的普通人vs高手的面试系列视频呢就到这结束了，我是麦克。我们下一期再见。
352-【Java面试】阿里一面，为什么用Spring框架？回答令人匪夷所思，请看Mic老师的解答！-480P 清晰-AVC
	一个工作了4年的小伙伴，啊他说他从线下培训就开始接触了spring，他从来没有想过为什么要使用spring框架，结果在面试的时候啊大脑一时间短路了来求助我。下面我们来看看普通人和高手的回答，普通的回答。嗯为什么要使用什么框架？啊我认为嗯可以。就是它核心嘛就是有LP和LC这两个组件，嘛那么它能够去帮我们在程序里面去做一些啊就是对象的管理，啊比如说病的管理，那么我们的这个程序的就是去构建这种对象的时候，它的耦合性就会更低了，因为它统一相当于一个容器。嗯然后然后就是它它本身是类似于这种就是粘合剂的一个作用，就它可以帮我们把很多的框架集成进来，对我们来说就是嗯整个的开发就是做外部开发来说，做企业级开发来说就是更加方便了，就是给我们提供了很多的一些便捷嘛。高手的回答。Spree呢是一个轻量级的应用框架，啊它提供了IOC和ALP这两个核心的功能，它的核心目的呢是为了简化企业级的应用开发，使得开发者呢只需要关心业务的需求，不需要关心冰的一些管理，以及通过切面的方式对功能进行增强，从而去减少代码的一个侵入性。从sleep本身的一个特征来看，呢我认为啊有几个关键点，首先第一个啊 Spring是一个轻量级的框架，它的基本版本呢只有两兆，第二个呢 spring通过IOC的容器来去实现病的生命周期的一个管理，以及通过div实现依赖注入，从而实现了对依赖的松耦合的一个管理。
	第三个啊 spring提供了ALP的面向切面编程这样一个功能，它可以把我们的业务逻辑和系统功能之间进行一个切分。第四个是一个mvc的框架，MACD呢提供的功能更加强大且更加灵活的一个外部框架的支持。第五个是事务管理啊 spring，通过ALP呢去实现了一个事物的统一管理，对应用开发中的事务处理呢提供一个非常灵活的一个知识的一个特性。最后呢 spring从第一个版本发布到现在，它的整个生态是非常庞大的，在业务开发的领域里面，呢 spring生态几乎提供了非常完善的一个支持。更重要的一个点是它的整个社区的活跃度和技术的成熟度都非常的高，所以我们在遇到问题的时候能够得到快速的一个响应。以上就是我对这个问题的一个理解。任何一个技术框架一定是为了解决某些特定场景问题的，只是大家忽略了这个点。为什么要用再往高一点来说，其实就是技术的选型。能回答这个问题意味着在面对业务场景或者技术问题的解决方案上，会有自己的见解和思考。
	所以啊我自己也喜欢去在面试的时候问这一类的问题。好的，本期的普通人vs高手的面试系列的视频就到这结束了，有任何不懂的技术面试题，欢迎随时私信我。

353-【Java面试】字节二面，Kafka如何保证消息消费的顺序性？请看Mic老师的回答！-480P 清晰-AVC
	今天呢我们来分享一道这样的面试题，mq是如何去保证消息的一个顺序消费的？下面我们来看看普通人和高手对于这样一个问题的回答，普通人的回答。卡夫卡如何去保证消息的顺序性这个问题？我我在那个就是我我我需要去保证那个消息应该是在同一个分区里面，因为卡夫卡的消息的这个分区它是有序的，然后我们去拿消息的时候是通过office来拿，嘛所以我只要去保证这个消息存储到party系统的有序性就好了。然后消费的时候我直接去指定那个盆景去消费就好了。高手的回答。好的，这个问题呢我想从两个方面来回答。首先啊在卡夫卡的整个架构里面用到了petition的分区机制来去实现消息的物理存储，也就是说在同一个topic里面可以维护多个petition来去实现消息的一个分片。那么生产者在发送消息的时候呢会根据消息的key来进行取模，来决定把当期的消息存储到哪一个petition里面，而且消息呢是按照先后有序的去存储在拍电信里面。那么在这种情况下，呢假设啊一个topic里面有三个培训，而消息呢正好被路由到三个独立的petition里面，然后消费端有三个消费者去通过balance的一个机制，据分别指派了对应的消费分区，因为消费者是完全独立的一个网络节点，所以可能会出现消息的消费顺序，不是按照发送顺序来实现的，从而导致消息的消费乱序的一个问题。
	所以我们觉得这个问题呢一般的解决方法就是自定义消息分区的一个路由算法，然后把指定的key啊都发送到同一个petition里面，然后我们去指定一个消费者专门去消费某一个分区的数据，这样的话就保证了消息的顺序消费了。另外呢在有些设计方案里面，在消费端会采用异步现成的方式来消费数据，以提高消息的一个处理效率。那么这种情况下，因为每一个现实的消息处理效率是不同的，所以即便是采用了单个分区的存储和消费，也可能会出现无序访问的一个问题。那么针对这样一个问题的解决办法，就是在消息消费端这一边采用一个阻塞队列，把获取到的消息先保存到组织队列里面，然后采用一个异步线程从组织队列里面去获取消息，来进行消费。以上就是我对这个问题的理解。关于这样一个问题，啊有些面试官还会这样去问，唉如果我不想把消息路由到同一个分区，但是还是想去实现消息的一个顺序消费怎么办？呢严格来说啊卡夫卡只能去保证同一个分区内的消息存储的一个顺序性，如果一定要去实现，不是不行，但是代价太大了，没有必要。
	虽然没有标准答案，但是面试官要这么去问，无非就想考察你面对复杂问题的时候是如何去思考的，以及你的技术底蕴是怎么样的。好的，本期的普通人vs高手的面试系列视频啊就到这结束了。大家记得点赞收藏加关注我是麦克。咱们下期再见。
350-【Java面试】为什么重写equals（）方法，就一定要重写hashCode（）方法？-480P 清晰-AVC
	为什么重写一cos方法就一定要重写哈斯克的方法呢？一个工作了4年的粉丝好不容易拿到了一个面试机会，结果就被这个问题给暴击了，没有办法，只能向我来求助。经常会有同学在后台私信我跟我吐槽，在求职过程中啊遇到各种各样刁钻男的面试，我发现大部分问题呢在我之前的视频里面都有分析过，考虑到大家看视频可能有点太过于分散，不方便大家学习，所以啊我系统的整理了一份20万字的面试文档，有需要的小伙伴可以在我的主页去领取，回答这个问题之前，我们来分析一下这个问题的背景。关于这个问题首先需要深入了解一下一cos这个方法，这种代码是实训这个类里面的一cos方法的一个实现。从这个代码里面可以看到，当调用equals方法去比较两个对象的时候，啊会做两个操作。第一，使用等于等于号去比较两个对象的内存地址，如果地址相同则返回to。第二，否则继续去比较这两个字符串的值，如果这两个字符串的值完全相同，同样返回去那 DS和haj，Coad有什么关系？呢首先Java里面任何一个对象都有一个native的haj kho的方法，其次这个方法在闪电集合中会用到，比如哈斯泰，而且map这样一些集合类，当往这样一些集合类去添加元素的时候，需要判断元素是否存在，而如果直接使用一course的话，效率太低，所以一般是直接使用对象的哈希扣子的值进行取模以后运算，如果table里面没有这个对象的哈希扣的对应的值，那么他就可以把这个对象直接存进去，不用再进行任何比较，而如果存在的话，就需要调用他的equal方法与新的元素进行比较，相同的话呢就直接覆盖，不相同就散列到其他的地址。
	所以这里面存在一个冲突解决的问题，这一来实际调用一个方法的次数就大大降低了，haj code的值默认是GM使用随机数来生成的，两个不同的对象可能生成哈奇扣的会相同，那么这种情况下在哈希表里面体现就是所谓的哈希冲突，通常会使用链表或者线性探测的方式来去解决这个冲突的问题，但是如果两个完全相同的对象，也就是内存地址指向同一个，那么它们的haj Coad一定是相同的，了解了一corse方法和哈西克的方法的关系以后，啊我们再来分析一下这个面试题。在理论情况下，如果x点1xy等于等于q如果没有重写equal方法，那么这两个对称的内存地址啊一定是同一个，意味着haj，Coad必然是相等，但是如果我们只重写equals方法，就有可能导致haj koh的不相同。一旦出现这样一个情况，就会导致这个类无法和所有的集合类一起工作。所以在持续开发过程中约定俗成了一条规则，重写equals方法的同时，也需要重写哈奇扣的方法。
	下面我们来看一看高手的回答。好的。如果只重写equals方法，不重写哈希克的方法，就可能会导致 a点1cos b这样一个表达式成立，但是哈希扣的却不同。那么这个只重写了equals方法的对象，在使用散列集合进行存储的时候就会出现问题，因为闪离集合是使用哈奇扣的来计算k的存储位置，如果存储两个完全相同的对象，但是有不同的哈希扣的，就会导致这两个对象存储在哈希表的不同位置。当我们想要去根据这个对象去获取数据的时候，就会出现一个悖论，一个完全相同的对象会存储在哈希表的两个位置，那么就会破坏大家约定俗成的规则，使得我们在程序过程中呢会出现一些不可预料的错误。强调一遍啊基础很重要，基础很重要，不要觉得每天写CEO能够解决业务问题就很牛逼了，等你工作七八年以后，你会发现对技术体系的理解和技术底层原理的学习才是自己的核心竞争力。好的，今天的视频就到这结束了。
355-【Java面试】Spring面试突击，Spring中有哪些方式把Bean注入IOC容器。请看Mic老师的解答！-480P 清晰-AVC
	今天啊收到一个工作4年的粉丝的面试题，school里面有哪些方式可以把病注入到IOC容器里面？他说啊这道题是所有面试题里面回答最好的，但是看面试官的表情好像不太对。啊我问他怎么回答的，他说接口注入，set注入和构造器注入。我们来对这个问题看看普通人和高手的回答，普通的回答。嗯 spring里面去把并注入在LC容器的方式，呢嗯就是嗯 xml啊就比较常用的一种方式嘛就是通过x秒里面生命病，嘛嗯还有一种就是像service姐，嘛就设备注解就是我们把那个对，我需要去把哪个病装在到iOS容器里面，我就可以加一个这样的设备注解。啊还有。
	高手的回答。好的，把并注入到IOC容器里面呢我知道有7种方法，首先第一种是大家都知道的，就x秒方式去声明并的定义，然后识别容器呢在启动的时候会去加载并解析这个 x秒，把Bing装载在LC容器里面。第二种呢是我们可以使用Capone scan注解来扫描生命，呢比如说culch了，或者servis或者repassed或者carpoint注解的这样一些类，然后去把这些类加载到LC容器里面。第三种是可以使用configuration注解曲声明配置类，并且使用并注解来实践b的定义。那么这种方式啊其实是x秒配置方式的一种演变，它是spring里面迈入无配置化时代的一个里程碑。第四种啊是可以使用input的注解，去导入一个配置类或者普通的病。第五种啊我们可以使用factory病这样的一个工厂病去动态构建一个病的实例。那么spring cloud的open里面的动态代理的实现呢就是使用f去bring来完成的。
	第六个啊我们可以去实现import并带分类型register这样一个接口，它可以动态注入being的一个实例。那么这个在spring boot里面的启动类的注解里面有用到第七个呢我们可以实现音破的select这样一个接口，那么它可以动态的批量的注入配置类或者并的对象。那么这个在视频boot里面的自动装配机制里面也有用到，以上呢就是我对这个问题的理解。工作了4年，啊 IOC和di都没有搞清楚，作为面试官想给你放水都不行了。呀这道题目呢其实也很有意义，啊想要更加优雅的去解决一些实际的业务问题。首先要有足够多的工具积累，而这道题里面所问到的问题其实就是一系列的工具箱，你有没有想过呢病的注入方式竟然有这么多，而且还有一些方式听都没有听过。好吧，我们本期的普通人和高手的面试系列的视频呢就到这结束了。我是Mike。一个工作了14年的Java程序员，咱们下期再见。
357-【Java面试】阿里二面，讲一下Mybatis里的缓存机制？请看Mic老师是如何替你解答的！-480P 清晰-AVC
	一个工作了5年的程序员在实习里面不断的向我诉苦，他说啊他用了my best。这么久怎么滴，也算是精通卖贝利斯了吧，结果竟然在卖贝克斯这样一个面试题上翻车了，真的好烦好吧，那么我们今天看看my business里面的缓存机制，普通人和高手的回答。普通人啊买奔驰的缓存机制，啊卖奔驰的缓存就是嗯它有两两级缓存，嘛一级是啊是一个c型级别的，就是因为啊 CC型它是属于单个绘画，嘛那么意味着就是如果我们的每一个用户的查询是在多个会话里面的话，那么他就无嗯也就是说一级缓存啊它是它是单个用户会话里面的，那如果说我要跨多个绘画的话，呢呃它没有办法去实现，所以在卖杯水里面还有个二级缓冲，二级缓冲就是嗯就是跨跨是一个c型里面的一个缓存，啊然后他能够针对多个这种这个 c线来去实现。嗯这个这个就是数据的一个一个缓存。吧高手的回答。这个问题啊有点复杂，啊我打算从几个方面来去说明一下。首先呢卖杯子里面设计了二级缓存这样一个机制来提升数据的一个检索效率，也就是说避免每一次数据的检索呢都去查询数据库，一级缓存是c筛选级别的一个缓存，也叫本地缓存，因为每一个用户在执行查询的时候都需要使用CC型来执行。
	为了避免每一次都去查询数据库，买别的省呢把查询出来的数据呢缓存到c哥c型的本地缓存里面，后续的CQ如果在命中缓存的情况下，就可以直接从本地缓存去读取这样一个数据，如果想要去实现跨c个c型级别的一个缓存，那么一级缓存是无法做到的。因此啊在卖杯子里面引入了二级缓存的一个设计，也就是说当多个用户在查询数据的时候，只要有任何一个SQL拿到了数据，就会放入到二级缓存里面，那么其他的这个 C选呢就可以直接从二级款式里面去加载数据。下面我再来解释一下一二级缓存的一个实现原理，啊首先我们看一级缓存，在这个 CT里面呢会持有一个一个加q的，每一个里面里面会有个叫local Cayce的一个对象。当用户发起查询的时候，呢 my baby会去根据执行语句在local里面去查找，如果命中了就直接把这个数据返回，如果没有命中再去数据库里面去查询出来，再写入到 locate区里面。所以啊一级缓存的生命周期是10个c选，需要注意的一点是在多个是一个c型或者分布式环境下，呢可能会因为一级缓存导致一个这样的脏毒的一个问题。
	而二级缓存的实现原理呢是在原来的一个在QQ上去做了一个装饰，引入一家k区一个Jack的这样一个装饰器。所以在进入一级缓存的查询之前，呢会先通过 k虚Excel进行二级缓存的查询，开启二级缓存之后，呢会被多个是一个筛选的共享，所以它是一个全局的缓存。所以它的查询流程呢就变成了先查二级缓存，再来查一级缓存，然后再去查数据库。另外啊卖贝利斯的二级缓存相对一级缓存来说，呢它实现了c和c型之间的缓存数据的一个共享，同时呢缓冲的力度也能够控制到name space的一个级别，并且还可以通过 k取这样一个接口来实现不同缓存实现的一个组合，对case的可控性也更高了。以上呢就是我对这个问题的理解。在实际的业务场景中，啊多级缓冲的设计思想啊是非常值得我们学习和借鉴的。所以呢我认为这是一个非常不错的面试题。大家牢记啊学习底层技术的目的是为了提高技术思维能力和积累解决方案，为以后更高的职位做好铺垫。好的，本期的普通人vs高手的面试系列视频呢就到这结束了，有任何不懂的技术面试题，欢迎在评论区给我留言。
358-【Java面试】百度一面，RabbitMQ如何去实现高可用性？看Mic老师是如何完美回答的！-480P 清晰-AVC
	Rabi tem q如何实现高可用？Hello大家好，我是麦克一个工作了14年的Java程序员，关于这个问题的解析和高手的回答，呢我已经把它整理到了一个20万字的面试文档里面，大家可以在我的主页去领取。下面我们来分析一下面试官对于这样一个问题的考察意向，这个问题呢就是简单的考察拉丁q相关知识点的一个了解，难度呢并不大，主要是考察三年以上开发经验的同学，但是这个问题只是一个切入点，我认为接下来会根据求职者的背景和在实际应用中对于r0q的一个使用程度，去针对性的做更进一步的深度考察。在分布架构下高可用是一个最基础的设计，也就是说啊一旦依赖的某个服务出现故障，不能影响业务的正常执行。Rap的mq呢提供了两种集群模式，第一个是普通的集群模式，第二个呢是镜像集群模式。我们先来看一下普通的集训模式，在这样一个集群模式下，呢各个节点呢只同步元数据，不同步队列里面的消息，其中的原数据包含对立的名称，交换机的名称和属性，交换机与对立的绑定关系等等。
	当我们发送消息和消费消息的时候，呢不管请求发送到rap集群的哪一个节点，最终呢都会通过原数据去定位到队列所在的节点去存储和拉取数据。很显然这种集训方式呢并不能去保证q本身的一个高口用，因为一旦q所在的节点挂了，那么这个 q的消息就没有办法被访问了，那么它的好处呢是可以通过多个节点去分担了流量的压力，提升了消息的吞吐能力。第二种呢是镜像集群，它和普通集群的区别在于镜像集群中的q的数据会在拉丁q集群的每个节点都存储一份，一旦任意一个节点发生了故障，那么其他节点仍然可以继续提供服务，所以这种集群模式下呢实现了真正意义上的q的高可用。最后啊在镜像的集群模式下，我们可以通过keep live加上h8c来去实现 rap、人q集群的负载均衡，像这样一个结构，其中啊 ha PRO x呢是一个支持4层和7层的负载均衡器，可以实现r0q集群的一个负载均衡，同时为了避免 h 8x的一个单点故障，啊可以在前置增加一个keep life来去实现 ha process的一个祖辈。
	如果hx主节点出现故障，那么备份的节点就会接管主节点提供服务。Q耐姆呢提供了一个虚拟IP，业务，只需要去连接到虚拟IP就可以了。好了，这就是rub用q常见的高可用的一个实现方案。那么在面试的时候，我们应该怎么去回答比较好呢？好的。Rabbit Emme cule高可用实现方式有两种，第一种是普通的集群模式，在这种模式下，一个q的消息只会存在于集群的一个节点上，集群里面的其他节点会同步q所在的节点的原数据。消息在生产和消费的时候，不管请求发送到集群的哪一个节点，最终都会由路由到q所在节点上去存储和拉取消息。这种方式并不能保证q的高可用性，但是他可以提升rabbit emco的消息吞吐能力。第二种是定向集群，也就是集群里面每个节点都会存储 q的数据副本，意味着每次生产消息的时候，都需要把消息内容同步给集群中的其他节点，这种方式能够保证q的高可用性，但是集群副本之间的同步会带来性能的损耗。另外由于每个节点都保存了副本，所以我们还可以通过ha可以实现负载均衡。以上就是我的理解。

356-【Java面试】腾讯二面，Spring中bean的作用域有哪些？请看Mic是如何替你解答的！-480P 清晰-AVC
	这个面试题是spring中的bean的作用域有哪些？对这个问题我们来看看普通人和高手的不断的回答。啊 Spring病里面的作用域，呢就是应该有一个单例，吧就默认应该是单例的，然后呃还有一个多实例，啊我我每一次去呃去获得这个病的时候，他都会生成一个新的实力给我，高速的回答。好的，啊这个问题呢我可以从几个方面来回答，首先呢 swim框架里面的IOC容器啊是可以非常方便的去帮助我们去管理应用里面的病对象的一个实例的，就我只需要去按照spring里面提供的xml或者注解的方式，去告诉IOC容器哪些病需要被IOC容器管理就行了。其次呢既然是病对象的实力管理，那么意味着这些实力呢是存在生命周期的，也就是所谓的一个作用域。理论上来说啊常规的生命周期呢只有两种，啊第一种是新过程，也就是单利啊意味着整个思维逻辑里面只会存在一个病的实力。第二个是prototype，翻译成圆形啊意味着是说每一次从IOC容器去获取指定病的对象的时候，它都会返回一个新的实力对象。但是在基于spring框架下的web应用里面，增加了一个绘画维度来控制病的生命周期的这样一个功能。
	它主要有三个选项，第一个是request，它是针对每一次的HTTP请求都会去创建一个新的病。第二个是c型以c型会换为维度，也就是说同一个c型共享，同一个病的实力，不同的c型呢会产生不同的病实力。最后一个是global station，它是针对于全局c型的一个维度，共享同一个病的实力，以上呢就是我对这个问题的理解。技术框架的本质呢是去解决特定问题的，所以如果你能够去站在技术的角度去思考，那么当遇到这一类问题的时候，呢就可以像这个高手的回答一样，能够去基于场景来推断出答案。就像我们现在写ciud是一样的，它已经变成了一种基本的能力，让我们去完成复杂业务逻辑的开发。好的，本期的普通人vs高手面试系列的视频呢就到这结束了，有任何不懂的技术问题，啊欢迎随时私信我，我是麦克。一个工作了14年的Java程序员，咱们下期再见。
351-【Java面试】腾讯二面，遇Redis底层原理，瞬间以泪洗面！-480P 清晰-AVC
	一个工作5年的粉丝在面试的时候遇到了ready主从复制的原理这样一个问题，他回答这个问题的时候呢断断续续的，没有一个比较清晰的逻辑性，导致啊面试没有发挥好。那么今天这个视频呢给大家分享一下，遇到这一类问题的时候正确的回答方式。Hello大家好，我是麦克菇泡科技的联合创始人，这个面试的文字版本呢我已经整理到了一个20万字的面试文档里面，有需要的小伙伴可以在我置顶的第一条视频里面去领取。下面我们来分析一下面试官的考察意图，这个问题还是有一定的深度，平时在工作中啊会很少涉及到这方面的内容。那么从这个问题的考查意图来看，很明显是考察求职者对于rex底层原理的一个理解成度，另外目标公司可能会需要涉及到 release中间件的一个日常运维，同时面试官也是希望通过这一类的技术原理，来达到筛选高级或者资深Java开发的一个目的。 Raci主从复制是指在readus集群里面，master节点和slave节点的数据同步的一种机制，简单来说就是把一台rad的服务器的数据复制到其他的rat服务器里面，其中负责复制数据来源的节点称为master，被动接收数据同步的节点称为斯莱瓦战略list里面提供了全量复制和增量复制两种模式。
	全量复合一般是发生在此level节点初始化的阶段，那么这个时候呢需要把master上所有的数据全部都copy一份，它的具体工作原理是第一步是level，节点会向master发送一个新口的命令，master收到命令以后呢会生成数据快照。第二步把数据快照发送给斯莱瓦节点。史莱文简历收到数据以后丢弃旧的数据，并且重新载入新的数据，然后对外提供服务。需要注意的是啊在组中复制的过程中，啊瑞并没有采用数据的强一致性，因此会存在一个数据同步的延迟，导致数据的一个不一致的问题。增量复制呢就是说master收到数据变更之后，会把变更的数据同步给所有的16个节点。那么增量复制的原理呢也很简单，master和斯雷尔都会维护一个复制偏移量叫offset，用来表示master向斯莱瓦传递的这些数量，每一次进行增量数据的传递，master和slip维护的offset都会增加对应的这些数量，瑞迪斯呢只需要去根据offset就可以去实现增量的数据的同好的。
	Release主从复制包括全量复制和增量复制，全量复制呢是发生在初始化阶段，从节点会主动向主节点发起一个同步请求，那么主节点收到请求以后，呢会生成一份当前数据的快照，发送给重节点，从节点收到数据进行加载之后，完成全量复制。声调负责是发生在每一次master节点发生数据变更的一个场景里面，会把变化的增量数据同步给重节点，增量复制是通过维护offset这样一个复制偏移量来实现的。以上就是我的理解。 Release主动复制的原理，啊在我们的实际过程中呢会接触的比较少，但是如果你知道不仅仅能够给你的面试加分，而且在实际开发过程中遇到类似的问题的时候，我们也能够快速定位和解决，这也是一种能力的体现。所以我们下次遇到这一类问题的时候，一定要去从底层的原理和它的整个工作机制甚至背景去做一个全面的回答，这样才能够在面试过程中获得面试官比较好的一个认可。好的，今天的视频就到这结束了。
351-【Java面试】腾讯二面，遇Redis底层原理，瞬间以泪洗面！-480P 清晰-AVC
	一个工作5年的粉丝在面试的时候遇到了ready主从复制的原理这样一个问题，他回答这个问题的时候呢断断续续的，没有一个比较清晰的逻辑性，导致啊面试没有发挥好。那么今天这个视频呢给大家分享一下，遇到这一类问题的时候正确的回答方式。Hello大家好，我是麦克菇泡科技的联合创始人，这个面试的文字版本呢我已经整理到了一个20万字的面试文档里面，有需要的小伙伴可以在我置顶的第一条视频里面去领取。下面我们来分析一下面试官的考察意图，这个问题还是有一定的深度，平时在工作中啊会很少涉及到这方面的内容。那么从这个问题的考查意图来看，很明显是考察求职者对于rex底层原理的一个理解成度，另外目标公司可能会需要涉及到 release中间件的一个日常运维，同时面试官也是希望通过这一类的技术原理，来达到筛选高级或者资深Java开发的一个目的。 Raci主从复制是指在readus集群里面，master节点和slave节点的数据同步的一种机制，简单来说就是把一台rad的服务器的数据复制到其他的rat服务器里面，其中负责复制数据来源的节点称为master，被动接收数据同步的节点称为斯莱瓦战略list里面提供了全量复制和增量复制两种模式。
	全量复合一般是发生在此level节点初始化的阶段，那么这个时候呢需要把master上所有的数据全部都copy一份，它的具体工作原理是第一步是level，节点会向master发送一个新口的命令，master收到命令以后呢会生成数据快照。第二步把数据快照发送给斯莱瓦节点。史莱文简历收到数据以后丢弃旧的数据，并且重新载入新的数据，然后对外提供服务。需要注意的是啊在组中复制的过程中，啊瑞并没有采用数据的强一致性，因此会存在一个数据同步的延迟，导致数据的一个不一致的问题。增量复制呢就是说master收到数据变更之后，会把变更的数据同步给所有的16个节点。那么增量复制的原理呢也很简单，master和斯雷尔都会维护一个复制偏移量叫offset，用来表示master向斯莱瓦传递的这些数量，每一次进行增量数据的传递，master和slip维护的offset都会增加对应的这些数量，瑞迪斯呢只需要去根据offset就可以去实现增量的数据的同好的。
	Release主从复制包括全量复制和增量复制，全量复制呢是发生在初始化阶段，从节点会主动向主节点发起一个同步请求，那么主节点收到请求以后，呢会生成一份当前数据的快照，发送给重节点，从节点收到数据进行加载之后，完成全量复制。声调负责是发生在每一次master节点发生数据变更的一个场景里面，会把变化的增量数据同步给重节点，增量复制是通过维护offset这样一个复制偏移量来实现的。以上就是我的理解。 Release主动复制的原理，啊在我们的实际过程中呢会接触的比较少，但是如果你知道不仅仅能够给你的面试加分，而且在实际开发过程中遇到类似的问题的时候，我们也能够快速定位和解决，这也是一种能力的体现。所以我们下次遇到这一类问题的时候，一定要去从底层的原理和它的整个工作机制甚至背景去做一个全面的回答，这样才能够在面试过程中获得面试官比较好的一个认可。好的，今天的视频就到这结束了。
365-【Java面试】阿里二面，遇Java反射的优缺点，把程序员逼疯！-480P 清晰-AVC
	请你说一下Java反射的优缺点。这是一个工作的5年的同学啊去阿里面试，第一面遇到了问题，今天这个视频呢给大家分享一下，我们遇到这个问题的时候该怎么回答，才能获得面试官的认可。另外呢经常有同学在后台跟我私信说，最近面试越来越难了，但是我发现大部分问题在我之前的视频里面都有分析过，可能内容太过于分散，所以大家学习起来比较费劲。所以呢我给大家整理了一个20万字的面试文档，大家可以系统的针对性的去进行刷题，有需要的小伙伴可以在我的主页去领取。反射是Java语言里面比较重要的一个特性，它能够在程序运行的过程中去构造任意一个类对象，并且可以获取任意一个类的成员变量，成员方法和属性，以及调任一个对称的方法。通过反射的能力可以让Java语言知识动态获取程序的信息以及动态调用方法的能力。在Java里面专门有一个叫Java点让点与flat这样一个包来实现反射相关的一些内裤，包括 contract，既有matter等等这样一些类，分别用来去获取类的构造方法成员变量和方法信息。
	反射使用的场景还挺多的，比如在动态代理这样一个场景里面，使用动态生成的代理类来提升代码的复用性，在spring框架里面有大量用到反射，比如用反射来实例化并对等等，下面我们来看一看高手的回答。 Java反射的优点呢有几个，一个是增加程序的灵活性，可以在运行的过程中去动态对内进行修改和操作。第二个可以提高代码的复用率，比如动态代理就可以用到反射来实现。第三个可以在运行的时候轻松的去获取任意一个类的方法和属性，并且还能通过反射来进行动态调用。加我反射缺点，我认为也有三个，第一反射会涉及到动态类型的解析，所以机缘无法对这些代码进行优化，导致性能要比非反射调用更低。第二，使用反射以后代码的可读性会下降。第三个反射可以绕过一些限制访问的属性或者方法，那么可能会导致破坏代码本身的抽象性，而且会造成一些安全性问题。以上就是我的理解。
363-【Java面试】阿里一面，HashMap是如何解决hash冲突的？-480P 清晰-AVC
	Hello大家好，我是麦克。今天我们来分享一道工作一年左右的一个面试题，最近很多粉丝在面试的时候啊都会遇到这样一个问题，这个问题是哈希map是如何去解决哈希冲突的，很多人觉得这个问题很简单，啊但是我认为高手的回答会更好一点，文字版的回答已经整理好了，大家可以在我的主页去加v领取。下面我们来看看普通人和高手对于这个问题的回答，普通人的回答。他先map解决他去冲的方式。呃我记得是用那个链表的方式，用单向链表，嗯如果存在还冲突的话，它会把那个存存在冲突这样一个一个剑指队啊会保存到那个链表的尾部。高手的回答。好的，这个问题呢我需要从几个方面来回答，首先哈希卖布层是采用数组的一个结构来存储数据元素，宿主的默认长度呢是16，当我们通过Poore的方法去添加数据的时候，啊下面会根据Kae的哈希值进行曲模运算，最终把这样一个值啊保存到数组的一个指定位置，但是这样一个设计方式会存在哈希冲突的问题，也就是说两个不同哈希值的key最终取模以后会落到同一个数组下标，所以啊哈希迈普引入了一个链式寻子法来解决哈希冲突的问题。
	也就是说对存在冲突的一个k呢哈希曼姆把这些k组成一个单向链表，然后采用尾插法把这样一个key呢保存到链表的一个尾部。另外为了避免链表过长，导致我的查询效率下降，所以当列表长度大于8，并且速度长度大于等于64的时候，啊哈希曼姆会把当前链表转化为红黑数，从而去减少链表数据查询的一个时间复杂度的一个问题来提升查询效率。最后我再补充一个点，啊解决哈奇冲突的方法有很多，比如说第一个在哈希法，也就是说如果某个哈希函数产生的冲突，那么再用另外一个哈希函数进行计算，比如说像布隆过滤器就采用这样一个方法。第二个开放寻址法，就是说直接从冲突的数组位置向下去寻找一个空的数组下标，进行数据的存储。这个啊在three的logo里面有使用到。第三个是建立公共溢出区，也就是说把存在冲突的key统一放在一个公共的溢出区里面去进行存储。以上就是我对这个问题的一个理解。哈希冲的这个问题呢在业务开发的过程中啊比较少遇到，但是从解决问题的方法里面，我们可以学到很多技术的设计思想，不管身份的面试还是为了长期的职业发展，我认为这个技术点都是有必要去深度理解的。
	基础知识。好的，本期的普通人vs高手的面试系列视频就到这结束了，喜欢我的作品的小伙伴记得点赞收藏加关注。我是Mike。一个工作了14年的Java程序员，我们下一期再见。
359-【Java面试】Spring面试突击，@Resource 和 @Autowired 有什么区别？请看Mic老师是如何回答的吧！-480P 清晰-AVC
	嗨大家好，我是麦克。一共做了两年的粉丝，啊问我一个spring里面的问题，他希望我能够从不同的视角去分析，然后去碾压面试官。这个问题是 resource和奥特y的这两个注解的一个区别。关于这个问题的高手部分的回答，呢我已经整理成了文档，如果你需要可以在我的主页上加v去领取。好的，那对于这个问题我们看看普通人和高手的回答，普通人的回答，呃 resource和autoeye的区别，呢我认为是在呃他们的一个注入的一个方式上，那个瑞呃 resource它是根据Naim来去进行著录的，然后奥特y的呢是根据于类型来进行注入的，高手的回答。好的面试官。Resource和Ortwein这两个注解的作用呢都是spring生态里面去实现并的依赖注入。下面我再分别说一下奥特y的和resource这两个注解的一个作用。首先呢奥特y的是spring里面提供了一个注解，它默认是根据类型来实现being的依赖注入。奥特y的柱径里面呢有一个require的属性，它的默认值to表示强制要求并实力的一个注入。
	在应用启动的时候，呢如果IOC容器里面不存在对应类型的病，那么启动的时候就会报错。但如果我们不希望去实现自动注入，可以把这个属性设置为force。其次呢如果在spring LC容器里面存在多个相同类型的病的实力，由于奥特y的注解，呢它是根据类型来注入病的实力的，所以spring容器启动的时候会提示一个错误，大概的意思是原本只能做了一个单实例病，但是在IOC容器里面会有多个导致注入失败。当然针对这个问题，啊我们可以使用primary或者coffee这两个注解来解决。Primary表示主要的病，当存在多个相同类型的病的时候，呢优先使用声明了primary注解的一个病，而quality注解呢类似于条件筛选，它可以根据病的名字去找到需要装备的目标病。接下来我再解释一下resource这样一个注解，resource呢是GD k里面提供的注解，只是spring在实现上提供了这种注解功能的一个知识，它的使用方式啊和奥特y的这个注解的方式是完全相同的，最大的差异化在于resource可以支持byname内和by time两种做的方式。
	如果使用name，spring会根据bean的名字去进行依赖注入，如果使用type，呢 spring会根据类型来实现依赖注入。假设啊两个属性都没有配置的情况下，它会先根据定义的属性名字去匹配，如果没有匹配成功，那么再根据类型来匹配，如果两个都没有匹配到的话呢就会报错。最后我再总结一下auto，Wye的租金呢是根据类型来匹配的，而resource这个主题呢可以根据name和我的态度来匹配，默认是name匹配。第二个o to y的注解呢是spree里面定的注解，而resource注解呢是GS250规范里面定义的注解，只是spring对GS250规范提供了支持而已。第三个奥特曼的注解，如果需要支持内PK，就需要配合primary或者qualify注解来实现之时。以上呢就是我对这个问题的一个理解。大家可以关注一下高手部分的回答，它的逻辑结构是很清晰的，他非常直观的去告诉面试官这两个注解的一个差异，同时呢又基于这两个注解的特性，解释了很多的差异，最后呢做了一个非常简短的总结，但在面试的时候啊可以去参考类似的回答思路。
	好的，本期的普通人vs高手的面试系列的视频呢就到这结束了，喜欢我的作品的小伙伴记得点赞和收藏加关注，我是麦克。一个工作了14年的Java程序员，我们下期再见。

367-【Java面试】网易一面，Redis哨兵机制和集群有什么不同？请看Mic老师的最优解！-480P 清晰-AVC
	Release的哨兵机制和集群有什么区别？如果你不知道怎么去回答这个问题，记得认真看完这条视频，hello大家好，我是麦克。专业面试题的文字版本，我已经整理到了一个20万字的面试文档里面，有需要的小伙伴可以在我的评论区去领取。下面我来分析一下这个问题的考察目的。这个问题的考察难度并不大，工作三年以上啊都会遇到，只是不同的工作年限，对面试的深度会有一些差异。考察这个问题的目的无非就是看看求职者是否了解瑞丽斯的集群，啊以及是否有自己去搭建过red集群，对于工作两年同学来说啊回答不需要太深入，但是5年以上的同学会以这个问题作为切入口，去深度考察求职者对于red集群和哨兵机制的底层原理， ready集群有几种实现方式，一个是主从集群，一个是red斯卡拉斯特组成集群，啊就是在Addis群里面包括一个master节点和多个slave节点，master节点的负责数据的读写，slave节点负责数据的读取，master节点收到数据变更会同步到slave节点上去实现数据的同步。
	通过这样一个架构可以去实现release的一个读写分离，提升数据的查询效率。但是啊 radies主从集群不提供容错和恢复的功能，一旦master节点挂了，不会自动选取出新的master，导致后续的客户端所有的企业请求直接失败，所以啊瑞丽丝提供了哨兵机制，专门用了监听ready主从集群提供故障的自动恢复能力，哨兵会监控race主从节点的一个状态，当master节点出现故障的时候，会自动从剩下的slave节点里面去选取出一个新的master。哨兵模式下虽然解决了master选举的一个问题，啊但是在线扩容的问题还是没有得到解决，于是就有了第三种情绪方式，readies cluster，它实现了readus的分布式存储，也是每个节点存储不同的数据，实现数据的分片功能。在瑞丽斯卡斯里面引入了slow的槽来实现数据分片，是note的整体取值范围是0~16383，每个节点会分配一个10兆的区间。当我们存取quay的时候，Reddy会根据Kae去计算得到一个时髦的一个词，然后找到对应的节点进行数据的读写。在高可用方面，raci casi呢引入了主从复制的一个模式，一个Maas节点对应一个或者多个slave节点，当master节点出现故障的时候，呢会自动从slave节点去选举出一个新的master，继续提供服务。
	瑞丽斯卡斯特呢虽然解决了在线扩容以及故障转移的能力，但同样他有缺点，比如说客户端在实践上会更加复杂，此类节点只是一个冷备节点，不提供分担读写操作的一个压力，对red里面的批量操作指令会存在限制，因此啊组成模式和class模式各有优缺点。在使用的时候，呢我们需要根据场景的需求来进行选择，好的面试官，因为vs群呢有两种，一种是主从复制，一种是edick laster，啊我不太清楚你问的是哪一种。按照我的理解，呢我认为你可能是说的 readies哨兵集群和readus的Klus之间的一个区别，对这个问题啊我认为可以从三个方面来回答。第一个瑞典骚平集群呢是基于主从复制来实现的，所以它可以实现读写分离，分担risk独操作的一个压力。而this class集群里面的slave节点呢只是实现冷备的一个机制，他只有在master宕机之后才会工作。第二个race，哨兵集群呢无法在线扩容，所以它的并发压力受限于单个服务器资源的一个配置。
	Readies klaas提供了基于slowed潮的一个数据分片的一个机制，它可以实现在线扩容去提升读写的一个性能。第三个从集群的架构来说，radix哨兵集训呢是一组多重，而readus Klus是一个多组多重的一个机制。以上就是我的理解。遇到这一类的问题，呢要学会用结构化的思维去整理好自己的思路，然后再根据体内的结构去回答，表达清晰又有逻辑性，这样的话更容易获得面试官的认可。好的，今天的视频就到这结束了。关注我每天分享一道技术面试题，我是Mike，咱们下期再见。
362-【Java面试】字节跳动二面，为什么ConcurrentHashMap中key不允许为null？-480P 清晰-AVC
	为什么康熙map里面的key和value是不允许wlan？呢听到这个问题啊大家有没有感受到面试过程中那种压迫感？Hello大家好，我是麦克。一个工作14年的Java程序员，关于这个问题的解析和高手部分的回答，我已经把它整理到了一个20万字的面试文档里面，大家可以在我的主页去领取。那么这个问题面试官的考察目的到底是什么？呢我们又应该怎么去回答呢？这是一个基础问题，主要考察的是1~3年的开发人员，康凯恩的哈希迈普在实际的应用中啊使用的频率非常高，考察这个问题的目的啊是了解求职者的基本功，所以为了表现的更好，可以从康康瑞哈奇map里面的一个设计角度去回答。打开Cara还是Mapp的一个源码，呢在put方法里面可以看到这样一段代码，如果key或者value为空，则会抛出一个空指针的异常，但是为什么刚看到哈希曼姆不允许key或者value为空呢？简单来说啊就是为了避免在多线程的环境下出现了一个歧义的问题，所谓的歧义问题，啊就是如果key或者value为那当我们通过get key去获取对应的value的时候，如果返回的结果是那我们是没有办法去判断。
	它是put key value的时候，value本身是一个n的值，还是说这个 T本身就不存在？比如在这样一种情况下，如果t线程调用content key的方法去判断key是否存在，假设当前这个key不存在，那么本来呢会应该返回一个boss，但是在t一线程返回之前，正好有一个t二线程插入了这样一个k的值，并且他的挽留是一个娜，这就会导致原本t一的线程返回的结果有可能为to，有可能为false，取决于 t一和t二线程的一个执行顺序。这种现象我们可以认为是线程安全性问题，而康凯瑞哈西曼又是一个现成安全的一个集合，所以自然就不允许key或者瓦里维纳，而哈希麦普中是允许维纳的，因为他不需要去考虑到现场安全性的一个问题，所以这个问题的核心本质还是康凯瑞哈西麦普这个病房安全集合的一个特性，当然多个利也认为不管是否是病房安全的一个集合，他都不应该允许存储钠的一个值。康康尔哈希迈普这么设计的原因是为了去避免在多线程并发场景下的一个歧义问题。
	也就是说当一个线程从康他去卖铺里面去获取Kae的时候，如果返回的结果是那那么这个线程是无法确认这个钠表示的是确实不存在这个 key，还是说存在这个key，但是 value为空，那么这种不确定性呢会造成线程安全性问题。而看看haj，mai本身又是一个线程安全的集合，所以才有了这样一个设计，以上就是我的理解。
373-【Java面试】百度一面，线程两次调用start（），会出现什么问题呢？请看Mic老师的最优解！-480P 清晰-AVC
	如果一个线程两次调用start方法，会出现什么样的问题？啊 Hello大家好，我是麦克。一共做了14年的Java程序员，关于这个问题呢涉及到现成的生命周期，我把完整的回答整理到了一个15万字的面试文档里面，下面呢我们看看普通人和高手的回答，普通人的回答。要用两次的话会报错。高手的回答。好的，面试官在Java里面的一个线程只能调用一次star的方法。第二次这样我会抛出一个一个线程本身是具备一个生命周期的，在Java里面的线程生命周期包括6种状态。第一种是6表示线程创建好了，但是还没有调用star的方法进行启动。第二种是roundtable在这个状态下，呢现在可能是正在运行，也可能是在就绪堆里面等待操作系统进行调度，分配CPU的一个资源。第三组是block表示线程处于锁等的状态。第四种呢是waiting，表示线程处于条件等待状态，当触发条件以后呢会唤起比如说wait对应的一个裸体饭。第五种是thyme的Viti，他和vit的状态是相同的，只是说它多了一个超时条件触发的一个机制而已。
	最后一种是特米net的表示现成的一个执行结束，当我们第一次调用star的方法的时候，现成的状态可能会处于终止状态，或者说非六状态下的一个其他状态。再调用一次star的方法的时候，相当于让这个正在运行的县城重新运行一遍。不管是从县城的安全性角度来看，还是说从县城本身的执行逻辑来看，它都是不合理的。因此啊为了避免这样一个问题，呢在县城运行的时候会先去判断当前县城的一个运行状态。以上就是我对这个问题的理解。这个问题啊非常简单，在面试过程中呢一般是作为一个热身题目出现，大家只需要回答出那个异常信息就好了。深度理解县城呢对于我们的日常开发工作以及问题的诊断是非常有帮助的。好的，本期的视频就到这结束了，大家记得点赞收藏加关注啊我是麦克。我们下期再见。
370-【Java面试】得物一面，JDK动态代理只能代理有接口的类？请看Mic老师的最优解！-480P 清晰-AVC
	一个工作了5年的Java程序员去应ping德物APP的月薪30k的Java开发岗位，被一个基础问题问的措手不及。啊这个问题是什么？呢它是jdk动态代理，为什么只能代理有接口的类？好吧，对于这个问题，我们来看看普通人和高手的回答，普通人的回答。呃因为 gdk里面的动态代理类，啊然后它是默认会继承一个叫 proxy这样一个类。啊所以因为Java里面它只能去实现单一继承，嘛所以嗯就是如果我我所以我们只能去针对于像那个接口来做动态代理，啊因为高速的回答，嗯我认为这个问题的核心本质啊是gdk动态代理本身的机制来决定的。首先呢在Java里面啊动态代理是通过process点6process这个方法来实现的，它需要传入被动态代理的一个接口类，之所以要传入接口而不能传入类，啊还是取决于gdk动态代理的一个底层实现。激励跟动态代理呢会在程序的运行期间啊去动态生成一个代理类叫boss，那么这个动态生成的代理类呢会去继承一个 Java点long点reflect点proxy这样一个类，同时还会去实现被代理类的接口，在Java里面呢是不支持多种继承的，而每个动态代理类都继承了一个process，所以就导致了gdk里面的动态代理只能代理接口，而不能代理实现类。
	我之前啊去分析过动态代理的源码，发现啊 Proc这个类呢只是保存了动态代理的一个处理器，叫一波开心哈德。如果不抽出来，直接设置到多了process，这个动态理论里面，我认为也是可以的。如果这么去实现的话，呢就可以针对时间内来做动态代理了。作者为什么这么设计？我认为呢还是有几个方面的原因，第一个是动态代理本身的使用场景或者需求呢只是对原始实现的一个拦截，然后去做一些功能的增强或者扩展。而实际的开发模式都是基于面向接口来开发的，所以基于接口来实现动态代理，从需求和场景呢我认为都是吻合的，当然确实可能会存在一些没有实现接口的一些类，那么这个时候我们要去实现动态代理，那么jdk很显然是无法满足的。第二个在Java里面类的继承关系的设计，啊更多的是考虑到共性能力的抽象，从而去提高代码的重用性和扩展性，而动态代理呢其实也在做这样一个事情，它封装了动态代理类的深层的抽象逻辑以及判断一个类是否是动态代理类，以及vocation handled的一个持有等等。
	那么我们去把这些抽象的公共逻辑放在PRO这个负类里面，很显然也是一个比较正常的一个设计思路。所以总的来说呢我认为这个设计上并没有什么值得特别去讨论的地方，因为我认为技术的方案的设计是解决特定的场景问题的。如果一定要去针对普通类来去做动态代理，我们可以选择c赖普这样的一个组件，它会动态生成一个被代理类的子类，子类重写父类的所有非friendly修饰的方法，在脂类中去拦截父类的所有方法的调用，从而去实现动态代理。以上呢就是我对这个问题的理解。我看到评论区啊有些小伙伴说面试问这些问题没有任何意义，我作为一个工作了14年做过开发架构的程序员最大的感受是越往上走，啊对于计算机的基础和底层的知识的理解越来越重要，上层的框架可能会随着业务的发展而变化，但是底层的技术原理和设计理念是不会变化的。所以我认为掌握了基础，就能够以不变应对万变。从另外一个角度来说，啊大家都停留在业务框架的使用上，短期也许能带来较大的收益，但是随着生产工具的升级，比如人工智能低代码、0代码、SAAS pass等逐步成熟和落地，那业务程序员的价值会被逐步的弱化，这就像曾经的工业革命工业革命之前的手工劳作，不管效率多高，技巧多么熟练，一旦由机器进行取代，那么传统手工劳动力必然会被淘汰。
	伴随而来的可能是技能的升级，从传统手工劳作转向了面向机器的操作。所以呢我认为底层逻辑啊还是对一个事物的本质上的一个认识，而不是停留在表面上。好的，本期的普通人vs高手的面试系列的视频就到这结束了，喜欢的朋友记得点赞和收藏。我是麦克。咱们下期再见。
379-【Java面试】高频面试题：如何使用Redis实现一个延时队列？-480P 清晰-AVC

	怎么使用release实现一个延迟队列呢？昨天一个工作了6年的粉丝去应ping一个年薪40万的工作，在第一面的时候被问到这个问题。屏幕前的小伙伴如果你知道这个问题怎么回答，那么你应该可以拿到40万年薪。这个问题啊在我之前整理的大场面试指南里面有一个标准的清晰的回答，大家可以在我的评论区的置顶中去领取这个文档。要回答这个问题，啊首先要明白什么是颜值队列，其次呢还得了解reds里面有哪些结构可以支持延迟队列这样一个特性。言辞队列是一种特殊类型的消息队列，他允许把消息发送到队列里面，但不立即投递给消费者，而是在一定时间以后再把消息投递给消费者去完成消费。所以它通常用于需要在未来的某个时间执行某个任务的场景，比如订单的超市处理，定时任务等等，在Lettice里面可以使用g赛的这个有序集合来实现列。具体的实现方式我们可以把它分成几个步骤，第一我们可以使用Ga的命令去把消息添加到这样一个GB sett里面，并且把当前的时间作为第二启动一个消费者县城，使用z软几百score命令去定时从z赛的集合中去获取当前时间之前的所有消息。
	第三，消费者处理完成以后，可以从有序结合中去删除这些消息。通过这种方式虽然可以实现延迟队列，但是消费端需要不断的向reds去发起轮巡，所以它会存在两个问题。第一轮循存在时间间隔，所以延迟消息的实际消费时间会大于设定的时间。第二，大量的轮巡动作会对ris服务器造成很大压力。所以如果我们需要去使用的研制消息，很多mq组件都支持这样一个能力。比如说罗q以上就是我的理解。
361-【Java面试】大厂高频面试题，Redis和Mysql如何保持数据一致性？看看Mic老师是如何为你解答的吧！-480P 清晰-AVC
	今天啊我们来分享一道一线互联网公司的高频面试题，他的题目是 ready和MAC如何去保证数据的一致性？这个问题啊难倒了不少工作5年以上的Java程序员，啊难的呢不是问题的本身，而是解决这个问题的思维模式。下面我们来看看普通人和高手对于这个问题的回答，普通人的回答。啊瑞迪斯和麦西口的数据一致性保证，啊麦西口的数据发生变化的时候，我需要同步去更新瑞丽斯我们我们可以通过就是再修改麦西口里面的数据之后，啊就是可以比如说嗯直接去同步去修改瑞丽斯或者我可以发一个异步消息去去去去通知啊 leds的数据的修改，高手的回答。一般情况下呢 radius是用来实现应用和数据库之间的一个读操作的缓存层，它的主要目的呢是去减少数据库的io，还可以提升数据的io性能，这个啊是它的一个整体架构，当应用程序需要去读取某个数据的时候，首先会先尝试里面去加载，如果命中了就直接返回，如果没有命中就直接从数据库里面查询，查询到数据之后，再把数据缓存到lads里，在这样一个架构里面呢会出现一个问题，就是一份数据同时保存在数据库和release里，当数据发生变化的时候需要同时去更新，瑞丽斯和麦西口由于更新操纵呢是有先后顺序的，并且呢它并不像MAC口中的多表事务操作，可以满足acad的特性，所以就会出现一个叫数据一致性的问题。
	在这样一个情况下呢能够选择的方法只有几种，啊第一种是先更新数据库，再更新缓存，第二种是先删除缓存再更新数据库。如果先更新数据库再更新缓存，那么如果缓存更新失败，就会导致数据库和瑞丽斯通的数据是不一致的。如果是先删除缓存再更新数据库，理想情况下是应用下次访问release的时候，发现瑞斯里面的数据是空的，那么就会从数据库加载保存到risk里面，沿着数据理论上是一致的，但是在极端情况下，由于删除瑞丽斯和更新数据库，这两个操作并不是原子操作，所以在这个过程中，如果出现其他县城来访问，还是会存在数据不一致的问题。所以啊如果需要在极端情况下，仍然去保证 ladies和max的数据一致性，就只能采用最终一致性的一个方案。比如基于洛克顿q的可靠性消息通信来实现数据的最终一致性，还可以直接通过肯定要组件监控麦c口里面的冰log日志，把更新后的数据同步到max里面，因为这里是基于最终一致性来实现的，如果业务场景不能去接受数据的短期不一致性，那么就不能使用这样的一个方案来实现。
	以上就是我对这个问题的理解。在面试的时候，啊面试官喜欢就问各种没有场景化的纯粹的技术问题，比如说你这个最终一致性方案还是会存在数据不一致性的问题，啊那怎么解决呢？先不用慌，啊技术是为了业务服务的，所有不同的业务场景，对于技术的选择和方案的设计都是不同的。所以在这个时候可以反问面试官，具体的业务场景是什么？一定要知道的是啊一个技术方案不可能卡卡住所有的场景，明白了吗？好的，本期的普通人vs高手的面试系列的视频就到这里结束了，喜欢的朋友记得点赞和收藏。另外最近从评论区收到了很多面试的问题，都有点太泛了。啊比如说啊你来说一下芒果TV，啊说一下卡夫卡，呀说一下病发，呀那么这些问题呢至少都要需要几个小时才能彻底说清楚，啊建议大家提问的时候可以具体一点。我是Mike。一个工作了14年的Java程序员，下期再见。

364-【Java面试】阿里一面，CPU狂飙800%后，心态直接崩溃！-480P 清晰-AVC
	面试过程中场景类的问题，更容易去检测出一个开发人员的基本能力。这不一个小伙伴去阿里面试，第一面就遇到了关于 CPU标高系统反应慢，怎么排查这个问题？对这个问题呢我们来看看，普通人和高手的回答，普通人的回答。那个 CPU飙高的原因就是因为就CPU它是用来去调入县城的，嘛所以就如果CPU比较高的情况下，那他应该是就现成资源创建过多，然后就是导致我我我CPU只有一直在处于运行状态，然后导致CPU的一个利用率过高。嗯排查的方法的话，我们之前公司都是有这种监控系统的，然后通过监控上报的方式，然后告诉我们大概哪个地方的哪个应用，CPU的这个阈值就比较高，那这种情况下我可能就是会去通过这个方式去定位。高手的回答。关于这个问题呢我从4个方面来回答。首先 CPU是整个电脑的核心计算资源，对于一个应用程序来说，CPU的最小执行单元是线程，导致CPU飙高的原因呢有几个方面，第一个是 CPU的上下文切换过多，对于CPU来说，同一个时刻下，每个CPU核心只能运行一个线程，如果有多个县城要去被执行怎么办呢？
	Cpu只能通过上下文切换的方式来执行调度不同的线程，上下文切换，呢需要做两个事情。第一个是保存运行中线程的执行状态。第二个，让处于等待中的县城恢复执行。这两个过程呢需要CPU执行内核相关指令去实现状态的保存和恢复。如果较多的上下文切换会占据大量的CPU资源，从而使得CPU无法去执行用户进程中的真正指令，导致响应速度下降。在Java中文件io网络io所等待，这些都会去造成线程阻塞，而线程阻塞就会去导致CPU的上下文切换，CPU资源过度消耗，也就是在程序中创建了大量的县城，或者有现成一直占据CPU资源无法被释放。比如说像死循环，CPU利用率过高之后，呢导致应用程序中的线程无法去获得CPU的调度，从而影响程序的执行效率。所以既然是这两个问题导致CPU利用率较高，于是我们可以通过Top命令找到CPU利用率较高的进程，再通过CF加h找到进程中CPU消耗过高的线程，这里呢有两种情况，第一种情况，CPU利用率过高的线程一直是同一个，也就是现成ID没有变化说明在程序中存在长期占用CPU没有释放的一个情况，那么这种情况呢直接可以通过js带获得现成的当铺日志，定位到线程日之后就可以找到问题的代码。
	第二个是CPU利用率过高的线程ID一直在不断变化，那么说明县城创建过多，需要去挑选几个县城ID，通过基stack去县城盗墓中去进行排查，最后呢有可能定位的结果是程序正常，只是在CPU标高的那一刻，用户访问量非常大，导致系统资源不够，那么这个时候呢我们需要采取的手段是去增加系统资源。以上就是我对这个问题的一个理解。从这个问题来看，呢面试官主要考察的是实操能力以及解决问题的思路。如果你没有实操过，但是你知道导致CPU标高这个现象的原因，啊先说出你的解决思路，通过面试是没问题的。好的，本期的普通人vs高手面试系列的视频呢就到这结束了，如果你在面试的时候呢遇到了一些比较刁钻和奇葩的问题，欢迎在评论区给我留言，我会在下一期的视频中去给大家做一个解答，我是Mike。一个工作了14年的Java程序员，咱们下期再见。
376-【Java面试】大众点评一面，Mysql索引的优缺点，来看看年薪60w的回答吧！-480P 清晰-AVC
	Hello大家好，我是麦克。今天分享的这道面试题呢是让一个工作了4年的小伙子去大众点评。拿了60万的年薪。这道面试题是请你说一下麦西口的索引的优点和缺点。关于这道题啊我们来看看普通人和高手的回答，普通人的回答。麦水口的索引的优点，优点的话，就是嗯我们加索引之后可以去提高数据的一个检索效率，嗯就很显然就是你加锁和没没呃加索引和没加索引的时候，它的一个查询效率是不一样的。然后缺点的话就是说嗯所以就如果就是索引的那个件数量太多，啊它会在嗯做那个索引的维护的时候，它会就是如果我的数据量很大，它会占用很长的一个时间。啊然后好像应该啊就还有就是不能在那个一些这个像姓名啊性性别类的一些字段上建立索引。高手的回答，所以呢是一种能够去帮助Michael高效的去从磁盘去检索数据的一种数据结构。在Mia seek的in DB引擎里面呢采用的是bea加速的结构来去实现索引和数据的存储。在我看来麦西口里面的索引的优点呢有很多，我简单罗列几点，第一个点，通过b加速的结构来存储数据，可以去大大减少数据检索时候的一个磁盘io次数，从而去提升数据的查询效率。
	第二个b加速索引在进行范围查找的时候，只需要去找到起始节点，然后基于叶子节点里面的链表结构往下去读取就行了，查询效率呢会比较高。第三个通过唯一所有的约束可以去保证数据表里面的每一行数据的一个唯一性。当然索引的不合理使用也会带来很多的一些缺点，比如说第一个数据在做增加修改删除操作的时候，需要涉及到索引的一个维护，当数据量比较大的情况下，所有的维护会带来比较大的一个性能开销。第二个一个表里面是允许存在一个聚集索引和多个非聚集索引的，但是索引的数量不能创建太多，否则会造成索引的维护成本过高。第三个，创建索引的时候，我们需要去考虑到索引字段值的一个分散性，如果字段一个重复数据比较多的情况下，创建索引反而会带来性能降低。在我看来任何技术方案都会有两面性，大部分情况下技术方案的选择更多的是看中它的优势和当前这个问题的匹配度。以上就是我对这个问题的一个理解。行业竞争加剧，再加上现在整个大环境不是特别好，各个一二线大厂呢都在裁员，带来的问题是啊人才的筛选难度同步增加。
	找工作会越来越困难。这题目考察的是求职者对于Michael的理解程度是不算难，卡住了很多人。好的，本期的普通人vs高手的面试系列视频呢就到这结束了，喜欢的朋友记得点赞和收藏。我是麦克一个工作了14年的Java程序员，咱们下期再见。
371-【Java面试】阿里一面，什么是消息列队（MQ） 堪比史诗级回答，请看Mic老师的最优解！-480P 清晰-AVC
	关于什么是消息队列，看普通人和高手是如何回答这个问题的。普通人嗯消息队列是指用队列的方式去发送消息，然后把要传输的数据丢到一个队列里面，嗯用来生产数据的这一端叫生产者，然后取中队列里面取出消息的这一段叫消费者。嗯对高手。好的，关于这个问题呢我从三个方面的解答，第一个是它的概念，mq啊就分布消息对它是一种应用之间异步通信的方式，主要是由三个部分组成，第一个生产者生产者也就是说生产消息的这一端，然后主要是负责消息所承载的业务信息的一个实例化，它是我们整个消息的发起方，然后中间的博客也是我们的整个消息的一个服务端，然后主要是去处理我们的这个消息单元，他负责消息的存储，投递以及我的这种队列的一些其他附加的功能的一些实现，它是整个消息队列里面最核心的组成部分。第三个消费者他主要负责消息的一个消费，具体是根据消息所承载的一个信息去处理各种业务逻辑。第二个呢我们来了解一下它的一个场景，它的场景呢很多，主要分为三种，第一种是异步处理，主要是应用在实时性要求不严格的一些场景，比如说用户注册发送验证码，下单通知、发送优惠券等，服务方只需要把协商好的消息啊发送到消息队列，剩下的是由消费者的消息服务去处理，不需要等待消费者的返回结果就可以直接返回给客户端，反馈业务层面。
	第二个应用解耦，婴幼解偶呢可以看作是可以把一些相关的，但是耦合度不高的一些系统关联起来。比如说订单系统与优惠券积分系统有关联度，但是没那么紧密。每个系统之前只需要去把一些约定的消息发送到mq，另外的系统直接去消费这个消息就行。它可以解决各类系统之间采用不同的一些框架语言来实现，从而大大增加了整个系统的一个灵活度。第三个是流量先锋，流量缺货一般是因为在大流量入口的一些短时间的业务需求处理不完的一些服务，为了去权衡高可用，把大量的一些病情任务发送的mq，根据mq的存储和分发的功能的平稳的去处理后续的一些业务，起到一个大流量缓冲的一个作用。目前呢市面上常见的消息队列的中间件主要有 actin Cui，拉别人q卡不卡罗QQ这一些，在架构技术选型的时候，啊一般会根据业务的需求来选择合适的中间件。比如说中小型公司，低吞吐量的一般会采用IQ，数据量较大，吞吐量要求较高的一般会采用卡卡或者罗QQ。以上呢就是我对mq的一个理解。
	好的，看完高手的回答之后，啊相信每位看完视频的小伙伴对于消息队列有了更深刻的理解。当然啊本期视频还有更多内容没有涉及到，比如说中间件的产品介绍，消息队列的实训原理等等，如果你还想听请在下方评论区给我留言，我会逐步安排。
368-【Java面试】蚂蚁金服一面，Integer a1=100 Integer a2=100，a1==a2的运行结果及原因？请看Mic老师的解答！-480P 清晰-AVC
	Integers a1=100into a2=100，请问a1=a2的运行结果以及原因，如果屏幕前的你们也同样不知道这个问题的答案，记得看完整个视频，下面我们来看一看面试官对于这个问题的考察目的。这个问题主要考察大家对于Java基础知识的牢固程度，涉及到知识点呢还挺多的，比如等于等于号表示内存地址的匹配，装箱拆箱，integer内部的设计原理等等，大部分同学啊能够熟练使用integer，但是不一定去了解过它的原理。而做一个三年以上的开发，对于Java基础必须要知其然，还得知其所以然。按照大家对于Java基础的认知，啊两个独立的对象用等于等于号进行比较是比较，两个对象的内存地址那得到结果必然是boss，啊但是在这个场景里面得到的结果却是two，为什么？呢首先intel就a1=100，把一个int数值啊赋值给一个封装类型，Java默认会进行一个装箱操作，也就是要intel点点value方法，把数字100包装成一个封装的一起，intel其次在integer内部的设计中啊用到了享元模式的设计，响应模式的核心思想是通过复用对象，减少对象的创建数量，从而减少内存的占用和提升性能。
	Intel就内部维护了一个intel9 case它缓存了-128~127这个区间的数值，对应的intel的类型。一旦程序调用value，方法，如果数字是在-128~127之间，就直接从k区里面去获取樱桃酒对象，否则就会创建一个新的对象。所以对于这个面试题来说，两个intel的对象因为值都是100，并且默认通过装箱机制调用了value方法，所以它会从英特case里面去拿到两个完全相同的intel的实力，因此使用等号去进行比较，得到的结果必然是two， a1=等于a2的直径结构呢是q原因是英特杰内部啊用到了一个响源模式的设计，也就针对于-128~127之间的数字呢做了一个缓使用intel是a1=100这个方式赋值的时候，Java默认会通过value这个方法对100这个数字进行一个装箱操作，从而触发了一个缓存机制，使得a一和a二指向了同一个intel的内存地址，以上就是我的理解。所以这样一个知识点呢非常重要，如果有些同学在工作中直接使用两个intel9封装类型用等号去比较，就有可能会导致生产事故。
	所以大家在写代码的时候，一定要对使用的API和技术框架的实现有一定的了解，不仅仅是为了面试，而是为了提升编码和架构设计的能力。好了，今天的视频就到这里结束了。
368-【Java面试】蚂蚁金服一面，Integer a1=100 Integer a2=100，a1==a2的运行结果及原因？请看Mic老师的解答！-480P 清晰-AVC
	Integers a1=100into a2=100，请问a1=a2的运行结果以及原因，如果屏幕前的你们也同样不知道这个问题的答案，记得看完整个视频，下面我们来看一看面试官对于这个问题的考察目的。这个问题主要考察大家对于Java基础知识的牢固程度，涉及到知识点呢还挺多的，比如等于等于号表示内存地址的匹配，装箱拆箱，integer内部的设计原理等等，大部分同学啊能够熟练使用integer，但是不一定去了解过它的原理。而做一个三年以上的开发，对于Java基础必须要知其然，还得知其所以然。按照大家对于Java基础的认知，啊两个独立的对象用等于等于号进行比较是比较，两个对象的内存地址那得到结果必然是boss，啊但是在这个场景里面得到的结果却是two，为什么？呢首先intel就a1=100，把一个int数值啊赋值给一个封装类型，Java默认会进行一个装箱操作，也就是要intel点点value方法，把数字100包装成一个封装的一起，intel其次在integer内部的设计中啊用到了享元模式的设计，响应模式的核心思想是通过复用对象，减少对象的创建数量，从而减少内存的占用和提升性能。
	Intel就内部维护了一个intel9 case它缓存了-128~127这个区间的数值，对应的intel的类型。一旦程序调用value，方法，如果数字是在-128~127之间，就直接从k区里面去获取樱桃酒对象，否则就会创建一个新的对象。所以对于这个面试题来说，两个intel的对象因为值都是100，并且默认通过装箱机制调用了value方法，所以它会从英特case里面去拿到两个完全相同的intel的实力，因此使用等号去进行比较，得到的结果必然是two， a1=等于a2的直径结构呢是q原因是英特杰内部啊用到了一个响源模式的设计，也就针对于-128~127之间的数字呢做了一个缓使用intel是a1=100这个方式赋值的时候，Java默认会通过value这个方法对100这个数字进行一个装箱操作，从而触发了一个缓存机制，使得a一和a二指向了同一个intel的内存地址，以上就是我的理解。所以这样一个知识点呢非常重要，如果有些同学在工作中直接使用两个intel9封装类型用等号去比较，就有可能会导致生产事故。
	所以大家在写代码的时候，一定要对使用的API和技术框架的实现有一定的了解，不仅仅是为了面试，而是为了提升编码和架构设计的能力。好了，今天的视频就到这里结束了。

372-【Java面试】面试突击Spring，Spring Boot中自动装配机制的原理是什么？请看Mic老师的最优解！-480P 清晰-AVC
	最近啊一位粉丝跟我说，他说面试了4家公司，啊有3家公司问他spring book中自动装配机制的原理是什么？对这个问题啊我们来看看普通人和高手该如何去回答？普通的回答。Win bottle里面的自动装配，就是 enable的咖啡类型这样一个注解来实现的。它的主要的作用就是可以去实现病的自动的注入，也就是说我如果依赖了就是在施工过程里面，如果我直接依赖了这种嗯就是大的这样的一个一个一个启动的依赖的话，就它会自动帮我们去把这个启动依赖里面相关的一些病装载到嗯容器里面，啊这样的话我就可以直接通过嗯 di的方式去完成它的一个依赖注入的这样一个动作。高手的回答。自动装配呢简单来说就是自动去把第三方组件的并装载到IOC容器里面，不需要开发人员再去写并相关的一个配置。在spring boot的应用里面，呢只需要在启动类上去加上springboard application注解就可以去实现自动装配 sporter application这样一个注解，它是一个复合注解，真正去实现自动装配注解是 enable auto configuration这样一个注解。
	自动装配的实现呢主要依靠三个核心的关键技术。第一个引入starter，启动依赖组件的时候，啊这个组件里面必须要包含一个congratulation配置类，而在这个配置类里面，我们需要通过being这个注解去声明，需要装配到IOC容器里面的病对象。第二个呢这个配置类是放在第三方的架包里面，然后通过springboard中约定，由于配置的这样一个理念，去把这个配置类的全路径放在class pass。麦塔Info刚spring点factory文件里面，这样的话视频boss就可以知道，第三方架包里面这个配置类的位置，这个步骤啊主要是用到了spree里面的spree，factory reload来完成的。第三个啊 springboard拿到所有第三方架包里面声明的配置类以后，再通过spring提供的import这样一个接口来实现对这些配置类的动态加载，从而去完成自动装配这样一个动作。在我看来呢 springboard是约定优于配置这一理念下的一个产物。
	所以在很多的地方都会看到这一类的思想，它的出现呢让开发人员可以更加聚焦的在业务代码的编写上，而不需要去关心和业务无关的配置。其实啊这种装配的思想在spring framework三点x版本里面的enable注解就已经有了实现的一个雏形。Enable注解呢是一个模块驱动的意思，也就是说我们只需要增加enable注解，就能自动打开某个功能，而不需要针对这个功能去做GB的配置。Enable注解的底层呢也是去帮我们自动去完成这样一个模块。相关病的注入的。以上就是我对于此 springboard自动装配的一个理解。发现了吗？高手和普通的回答并不是回答的内容多和少，而是让面试官看到你对于这个技术领域的理解的深度和自己的见解，从而让面试官在一大堆的求职者之中去对你产生一个清晰的影响。好的，本期的普通人vs高手的面试系列的视频就到这结束了，喜欢的朋友记得点赞和收藏，我是麦克。一个工作了14年的Java程序员，咱们下期再见。

374-【Java面试】得物二面，IO多路复用机制？99%以上的人回答不出！来看看Mic老师是如何解答的！-480P 清晰-AVC
	什么是io的多路复用机制？这是一道年薪50万的面试题，很遗憾，99%的人呐回答不出来。Hello大家好，我是麦克。一个工作了14年的Java程序员，今天呢给大家分享一道网络io的面试题，这道题的文字回答呢我已经把它整理到了一个15万字的面试文档里面，大家可以在我的主页去加v领取。下面呢我们来看看普通人和高手的回答，普通人的回答。呃我认为io多路复用机制，它的一个核心的目标是去实现呃服务端的连接的处理的一个数量。嗯他跟他跟嗯系统底层的那个54这个复利用机制的方法有关系。比如说像像那个 select，还有像伊珀，啊这些就是实现多路复用机的一个基础，也就是说嗯也就是说在服务端里面，我们可以通过通过这种一个单个线程去监控多个客户端的一个连接的状态，从而去实现这个连接的一个管理。吧高手的回答。好的面试官。Io多路复用机制，呢它的核心思想是让单个线程去监视多个连接，一旦某个连接就绪，啊那么也就是触发了读写事件的时候，那么就会去通知对应的应用程序，去主动获取这个就绪的连接去进行读写的操作，也就是在应用程序里面可以使用单个线程同时去处理多个客户端连接，在对系统资源消耗比较小的情况下，去提升服务端的连接处理数量。
	在io的多路复用机制的一个实现原理里面，呢客户端请求到服务端以后，此时客户端的传输数据的过程中，为了避免server端在read客户端数据的时候阻塞，那么服务端会先把请求注册到一个select的一个附录器上，服务端尺寸的不需要等待，只需要启动一个线程，通过select点select方法去阻塞轮巡，附录器上就续的签了就可以了。也就是说如果某个客户的连接的数据传输完成以后，那么select方法会去返回这个就绪的签了，然后呢执行相关的一个处理逻辑就可以了，常见的io多路复用机的实现呢有很多，比如说select破一破等等，这些都是Linux系统里面提供的io复用机制的一个实现。其中啊谁来和破都是基于轮巡的方式去获取就去连接的，而伊珀尔呢是基于事件驱动的方式去获取就去连接，所以呢从从性能的角度来看，基于事件驱动方式要优于轮训的方式。以上就是我对这个问题的理解。Io多路复用机制啊是一个非常重要的网络通信基础，啊在平时业务开发里面呢使用的比较少，但是在中间件里面作为一个基础的通信模型，是每个高级工程师必须要掌握的核心内容。
	好的，本期的视频就到这里结束了，大家记得点赞收藏加关注。我是Mike。我们下期再见。
366-【Java面试】阿里二面，如何解决INNODB幻读，来看看你与大佬之间的差距！-480P 清晰-AVC
	前面啊有个去快手面试的小伙伴私信我，他遇到这样一个问题，阴谋DB如何解决换毒问题？这个问题呢确实不是很好回答，因为在实际应用中，啊很多同学几乎都不关注数据库的事物隔离性。所有的问题基本上都是ciud一把梭。那么今天呢我们来看一下，关于一诺DB如何解决换读这个问题，普通人和高手是如何回答的？普通的回答。我我印象中啊就是银诺DB里面的换读是通过mvcc机制来解决的。Mvcc是一种乐观锁的机制，然后它能够在通过这种版本的方式去控制并发事物的这个竞争，然后从而去解决这种这种就是因为多多事物竞争的带来的一个一个一个换毒的一个问题。高手的回答。这个问题呢我会从三个方面来回答。第一个，麦西口的事务隔离级别，麦西口有4种事务隔离级别，这4种事务隔离级别分别代表当存在多个事物并发冲突的时候，可能会出现的张图不可重复读换读的一些问题。而一诺DB在r的隔离级别模式下，解决了换读这样一个问题。第二个，什么是换毒？呢换读是指在同一个事物中，前后两次查询相同范围的时候，得到的结果不一致。
	我们来看这个图，第一个事物里面我们执行了一个范围查询，这个时候满足条件的数据只有一条，而在第二个事物里面，他插入了一行数据，并且进行了提交。接着第一个事物再去查询的时候，得到的结果比第一次查询的结果多出来的一条数据。注意第一个事物的第一次和第二次查询都在同一个事物里面，所以啊换读会带来数据一致性的问题。第三，一朵DB是如何去解决换毒问题的呢？一朵地冰里面引入了间隙锁和next k lock机制去解决换毒问题。为了更清晰的说明这两种锁以及它是怎么样去解决换毒的。我来举一个例子，假设现在存在这样一个 b加速的索引结构，这个结构里面有4个索引元素，分别是一、4、7和10。当我们通过组件索引查询一条记录，并且对这条记录通过 for update枷锁的时候，像这样，这个时候呢会产生一个叫记录所也就是行所锁定ID等于一这个索引。像这样一个图，被锁定的记录在所释放之前，其他事物是无法对这一条记录做任何操作的。
	前面我们说过对幻图的定义，啊换毒是指在同一个事物中，前后两次查询相同范围的时候，得到结果不一致。这里强调的是范围查询，也就是说啊一诺DB引擎要解决换毒的问题，必须要保证一个点，就是如果一个事物冲过这样一条查询语句进行锁定的时候，另外一个事物在执行这样一条音色的语句需要被阻塞，直到前面获得所的事物被释放。所以在indie中设计了一种间隙所它的主要功能是锁定一段范围内的索引记录，像这样一个图，当对查询范围ID大于4and ID小于7这个范围枷锁的时候，会针对b加速中的4和7这个开区间的范围加间隙锁，意味着在这种情况下，其他事物对这个区间的数据进行插入，更新三组都会被锁住。还有另外一种情况，比如像这样这条查询语句是针对ID大于4这个条件枷锁，那么它需要锁定多个索引区间，所以这个情况下英诺DB引入一个叫next洛克机制，next k rock呢相当于间隙所和记录所的合集，记录所锁定存在记录的行间隙所锁住的是记录行之间的间隙。
	而next key呢锁住的是两者的和。像这样一个图，每个数据行上的非唯一索引链都会存在一把next。当某个事物持有这一行数据的 next look的时候，会锁住一段左开右闭区间的数据。因此啊当通过ID大于4这样一个范围查询枷锁的时候，一诺DB呢会去加一个next洛克索，锁定的区间范围是477和10，十到正无穷大，记住是左开右闭区间，间隙锁和next look的区别是在于枷锁的范围，间隙锁锁定的是梁哥索引之间的间隙，而next look呢会锁定多个索引区间，它包含记录所和见习所。当我们使用范围查询，不仅仅命中record记录，还包含了get间隙的时候，在这种情况下，使用的就是零件锁，也就是x洛克，它是Mexico里面默认的行锁算法。第四，简单总结一下，虽然呢一诺DB里面通过间隙锁的方式解决了换毒的问题，但是枷锁之后一定会影响到并发的性能。因此啊对于性能较高的一些业务场景，我们可以把隔离级别设置成RC，那么这个级别中就不存在借机所也就不存在这样的一个性能的影响。
	以上呢就是我对于一诺DB如何解决换读问题的一个理解。好的，通过这个面试题啊可以发现，大场面是对于基本功的考核。还是非常严格的。不过呢。不管是为了应付面试，还是为了以后职业规划的一个铺垫，技术能力的高低都是你在这个行业的核心竞争力。本期的普通人vs高手系列的视频呢到这里就结束了。我是Mike。一个工作了14年的Java程序员，咱们。
369-【Java面试】腾讯一面，Eureka server数据同步原理是什么？请看Mic老师的最优解！-480P 清晰-AVC
	Hello大家好，我是麦克。昨天啊一个工作了4年的粉丝去一个互联网公司面试，在面试的时候啊面试官一个劲的去问他spring cloud net flex组件的一些底层原理，开始的时候还能回答出来，越到后面啊越懵逼，最后面试没有过。他有点不理解面试官怎么会问这么深。当他把简历发给我的时候，我看到他简历上写了精通spring cloud以后瞬间明白了原因。Spring cloud the net flex里面的组件呢可以考察的方向太多了，比如今天分享的这张片视野，啊尤瑞卡斯嘛它的数据同步的原理，相信80%的同学都不一定能够回答出来，不过没有关系，啊我已经把这个问题的答案呢整理到了一个10万字的面试文档里面，大家可以在我的主页去加v领取。下面我们来看看普通人和高手对于这样一个问题的回答，普通人的回答。呃 U卡的数据同步，我记得好像是一个AP模型，吧然后就是就是每个节点他们是一个两两注册的一个状态，然后就我我收就某任何一个节点收到了这样一个数据之后，它都会直接同步给其他节点，然后它不需要保证一致性。
	是说我只是类似于一个通知的一个一个状态，去保证数据的一个同步。高手的回答。好的，面试官。U瑞卡是一个服务注册中心，在u瑞卡的设计里面，呢为了去保证u瑞卡的一个高可用性，啊提供了集训的部署方式，而优乐卡集群的部署呢是采用两两相互注册的方式来去实现的，也就是说啊每一个优瑞卡serve的节点都需要去发现集群里面的其他节点，并且建立一个连接，然后呢通过心跳的方式去维持这样一个连接的状态。用瑞卡生物集群节点之间的数据同步方式啊是非常简单粗暴的，也就是说它是使用了一个对等复制的方式来去实现数据同步。什么意思？呢就是在优瑞卡生活集群里面呢不存在所谓的主从节点，而是说任何一个节点都可以去接收和写入数据。一旦集群里面的任何一个节点啊收到了数据的变更的动作，那么它会直接同步到集群的其他节点上。那么这种无中心化的节点数据同步呢需要考虑到一个数据同步的一个死循环的一个问题，也就是说需要去区分u卡server收到的数据是属于客户端传递过来的数据请求，还是集群里面的其他节点发过来的同步数据的一个请求。
	在优瑞卡seven集群里面呢使用了一个时间戳的标记，来去实现类似于数据的版本号，来解决这样一个问题。另外啊从尤瑞卡数据同步的方案来看，与卡集群其实采用了一个AP的模式，也就是说啊他只提供高可用的保障，而不提供数据的一致性保障。之所以采用AP，啊我认为是在注册中心里面，它只是维护服务之间的一个通信地址，数据的是否一致性，对于服务之间的通信影响并不大。而住中心啊对优瑞卡高可用性的要求会比较高，不能因为说优瑞卡社保出现故障，导致服务之间无法通信的问题。以上呢就是我对这个问题的理解。尤瑞卡呢虽然已经闭园了，但是在国内呢依然使用比较广泛，当然有些公司逐步迁移到拉cos上面，但是优瑞卡的整个框架的设计上面呢还是有非常多值得我们去学习的思想。比如说多级缓存的设计，集群之间的数据同步方案，多区域隔离以及就近法案的一些设计方案等等。对于一个优秀的技术框架来说，我们能够去获取这些优秀的设计理念，对我们未来的职业发展是很有帮助的。
	好的，本期的普通人vs高手的面试系列的视频啊就到这结束了，大家记得点赞收藏加关注我是麦克，我们下一期再见。
378-【Java面试】京东一面，简述雪花算法的原理！你能回答上吗？-480P 清晰-AVC

一个工作了4年的粉丝去京东面试，啊遇到这样一个问题，请你简述一下雪花算法的实现原理。屏幕前的小伙伴们，如果你遇到这个问题知道怎么回答吗？Hello大家好，我是麦克这道面试题的文字版本，我已经整理到了一个20万字的面试文档里面，有需要的小伙伴可以去看我置顶的第一条视频去领取。下面我们来分析一下面试官的考察意图，雪花算法是一个生成全球唯一ID的一个算法，它主要出现在像分库分表场景中作为业务组件，或者说作为一些像订单号这一类的ID生成器，那么这个问题啊就是考察求职者对于雪花算法的了解，而且面试官问的是实现原理，那么意味着至少要说明雪豹算法的整体设计以及实现方式。雪花算法一般是用来实现全局唯一的业务组件，解决分户分表之后组建ID的唯一性问题，所以就单纯全局唯一性来说，其实有很多的解决方法，比如说像uid release的原子递增，数据库的全局表的自证ID等等，但是在实际应用中，我们的ID除了唯一性以外，还需要去满足有序递增，高性能高可用，以及需要带一些时间戳等这样一些特征。
	而雪花算法就是一个比较符合这一类特征的全局唯一算法。在美团内服这样一个组件里面也有用到，它是一个通过64个比特位组成的一个long类型的数字。它分为这样4个部分，第一个部分用1个比特位来表示1个符号位，一般情况下却是0。第二个部分用41个比特位来表示一个时间戳，这个时间戳，呢是系统时间的毫秒数。第三个部分是用10个比特位来记录工作机器的ID，这样就可以保证在多个服务器上生成ID的微信。如果存在跨机房部署的情况下，我们还可以把这10个比特位拆分成2个5bit，那么前面的5个贝特呢可以去表示机房ID，后面的5个贝特可以表示机器的ID。第四个部分用12个比特位来表示一个递增序列，用来实现同毫秒内产生不同ID这样一个能力。雪花算法就是根据这4个部分的组成规则，生成对应的贝特位的一个数据，然后组装在一起，形成一个全局唯一的ID。雪花算法是一种生成分布式全局唯一ID的一个算法，它会得到一个64位长度的long类型的数据，其中啊这64位的数据呢由4个部分组成，第一个比特位是一个符号位，因为ID不会是负数，所以它一般是0。
	接着用41个比特位来表示毫秒单位的时间戳，再用10个比特位来表示工作机器的ID，最后用12个比特位来表示递增的序列号，然后把这64个比特位拼接成1个long类型的数字，这就是雪花算法的一个实现。其实啊雪花算法本身呢不是特别复杂，它更多的是在整个的设计理念和思想上这个点能够回答出来，就能够获得面试官的一个认可。好的，今天的视频呢就到这结束了。

381-【Java最新面试题】字节一面：JVM 为什么使用元空间替换了永久代？-480P 清晰-AVC
	Gbm为什么使用圆空间来替换了永久贷？这是一个工作了6年的同学去字节的第一面遇到的问题。你看呢他没有回答出来。Hello大家好，我是麦克。一个工作的14年的Java程序员，关于这样一个问题，啊我们应该怎么去思考，怎么样去回答？呢面试官到底想关注和考察我们什么？我们都知道在Java8以及以后的版本里面，呢 Gm运行时数据区的一个结构在慢慢的调整和优化。但实际上这些变化对于业务开发的小伙伴来说没有任何的影响，因此我可以说99%的人都回答不出这个问题，但是互联网大厂的面试就是去筛选那1%的优秀人才，因此呢通过这道题目，啊既可以考察求职者对于GPS原理的理解程度，又能够去考察求职者的基本功的扎实程度，还能够去实现高级人才的筛选。在Java7里面，GM运行时的数据区是这样的，在hot spot虚拟机中啊方法区的实现是在永久带里面，它里面主要存储、运行时、常量池、class内源信息等等，永久贷属于gpm运行时数据区内的一块内存空间。我们可以通过这样一个参数去设置永久代的大小，当内存不够的时候就会触发垃圾回收，在gdk点8里面呢 GM运行数据区是这样的，在hold on的虚拟机里面呢取消了永久贷，由圆空间来实现方法区的数据存储，圆空间不属于gpm内存，而是直接使用的是本地内存，因此呢不需要考虑GC的一个问题。
	不同情况下，圆空间是可以无限制的使用本地内存的，但是我们也可以使用Gmail参数来限制内存的一个使用大小，为什么要使用原空间来替换永久袋？背后必然有他的道理，但是如果求职者能够回答出来，必然是对GM的底层原理有一定了解的。我们来看看高手是如何回答这个问题的。我认为呢有三个方面的原因，第一个是在1.7版本里面的永久贷内存是有上限的，虽然我们可以通过参数来设置，但是 cvm加载的class总数大小是很难去确定的，所以很容易出现om的一个问题。但是原空间呢是存储在本地内存里面，内存的上限是比较大的，可以很好的去避免这个问题。第二个，永久贷的对象是通过富尔GC进行垃圾回收的，也就是和老年代同时实现垃圾回收。替换着原空间以后啊简化了富尔基c的这样一个过程，可以在不进行暂停的情况下，据并发的释放类的数据，同时呢也提升了GC的一个性能。第三个oracle要合并或者sport和g的一个代码，而其rock里面的没有永久带。
	以上呢就是我对这个问题的理解。好了，今天我们的分享就到这结束了。

386-【Java面试】冷门面试题：什么情况下不需要建索引？-480P 清晰-AVC

	什么情况下不需要建索引？嗨大家好，我是麦克。一个工作了14年的Java程序员，今天给大家分享一下面试过程中遇到这个问题，我们应该怎么去正确回答。关于这个问题的文字回答，我整理到了一个50万字的面试文档里面，有需要的小伙伴可以在评论区的置顶中去领取。一般情况下，面试官问的索引都是卖c口里面一诺DB引擎的b加速索引。所以大家首先要知道所有的原理，大家都知道b加树是一棵多路平衡树，它的特点是非叶子节点指存储索引，叶子节点存储数据，从而减少b加速层高，降低磁盘io次数，去提升数据的检索效率。通常情况下加索引是能够直接提升数据的检索效率的，但面试官反其道而行，问你什么时候不见索引，所以这个问题考察候选对于索引的理解深度，如果你期望这次面试有一个好的反馈，候选人需要能够分析出不见索引的原因和影响，并根据具体情况进行详细说明。下面我们来看一下这个问题的回答。我认为有几种情况不射箭索引。第一数据量太小的情况下，即使没有，所以查询的速度也比较快，这个时候建索引反而会增加维护的成本和查询时间。
	第二数据离散度不高的列，比如说性别年龄这种创建索引呢反而会降低检索效率。从底层原理来说，相当于增加了b加速的扫描范围，从而去提高了查询的时间。第三，存在函数操作情况下，如果查询条件包含函数操作，那这个时候可能不会走索引，所以见索引的意义不大。最后频繁变更的表也不适合见索引。比如说经常需要更新删除和插入操作那这种情况下，对表现力索引的开销就会很大，甚至可能影响到整个数据库的性能。以上就是我的理解，如果你喜欢我的作品，记得点赞和关注，我是麦克，我们下期再见。
375-【Java面试】字节一面，如何在不加锁的情况下，解决线程安全问题！-480P 清晰-AVC
	对于如何在不加锁的情况下去解决现在安全问题，啊看看普通人和高手是如何回答的。普通人的回答。布加索如何去解决现在安全问题？一般解决现在安全问题的方式，呢我们都是需要去枷锁的。护枷锁，布加索好像不是特别清楚，高手的回答。好的，对这个问题呢我会从三个方面来回答。第一个，所谓的线程安全问题啊其实是指多个线程，同时对于某个共享资源的访问，导致的原子性、可见性和有序性的问题。而这些问题呢会导致共享数据存在一个不可预测性，使得程序在执行过程中呢会出现一些超出预期的一个结果。第二个，一般情况下，解决现在安全问题的方式是增加同步所，常见的是像辛苦nice rock等等。由于导致现成安全问题的根本原因啊是多线程并行访问共享资源，对共享资源枷锁之后，呢多个线人在访问这个资源的时候必须要先获得锁，也就是先获得访问资格，而同步锁的特征是在同一个时刻，只允许一个县城访问这样一个资源，直到所谓四方，虽然这种方式呢可以解决现在安全性的一个问题，但同时带来的是枷锁和释放锁所带来的一个性能开销，因为枷锁会涉及到用户空间到内核空间的一个转换以及上下文切换。
	第三个，啊如何在性能和安全性之间去取得一个平衡，这就引出了一个无所并发的一个概念。一般来说呢会有以下几种方法。第一个啊是通过自学所，所谓自旋锁是指现成在没有抢占的锁的情况下，先自选指定的次数去尝试获得。所第二个是乐观所给每个数据去增加一个版本号，一旦数据发生变化，则去修改这样一个版本号，那在Java里面呢有一个叫CS的一个机制可以去完成了关锁定功能。第三个在程序设计中尽量去减少共享对象的一个用从业务上去实现隔离，避免并发。以上呢就是我的一个回答。好的，看完高手的回答之后，呢相信每一位看完视频的小伙伴对于现成安全问题呢有了更深刻的一个理解。本期的普通人vs高手系列的视频就到这里结束了，喜欢的朋友呢记得一键三连加个关注。
395-【Java面试】ConcurrentHashMap的size()方法是线程安全的吗？-480P 清晰-AVC
	Hello大家好，我是麦克。一个没有才华，只能靠颜值混饭吃的Java程序员，一共做了5年的粉丝，啊最近去蚂蚁面试，在第一面的时候被问到了几个Java基础问题，其中有一个问题呢比较有意思，啊面试官问 com Karen Hashman，它的一个size方法是不是限制安全的？为什么？另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的主页去加v领取。下面我们看看普通人和高手对这样一个问题的回答，普通人的回答。嗯看看哈希迈克的赛事方法是不是现参选的。呃 Sars方法呢本身是现成安全的，因为在那个元素统计的过程中，啊就是我们比如添加数据的时候，它是通过那个 case的方式来去更新那个一个一个成员变量的，吧所以我拿的时候应该是安全的，但是但是那个那有可能说我拿到赛事方法的数据可能跟那个跟那个我实际的数据元素可能对不上。因为因为赛车方面它没有加藤木索。
	高手的回答。好的，面试官。我认为康康是赛制方法本身的实现是现在安全的，但是我们调用的方法获取元素个数的时候，它是一个非线程安全的。也就是说啊当有现成店铺的方法去添加元素的时候，吉他现在调赛的方法去获取元素的个数和实际存储元素个数是不一致的，原因是set方法是一个非线程同步的方法，put方法和SAAS方法之间并没有实现同步锁，当这样put方法去实现数据的添加或者修改的时候，我们只是把所控制在当前的需要修改的某个数组的节点上，而对于后续的数据的一个累加，他并没有加同步锁。所以这个时候如果调用size方法去获取元素的时候，那么当前添加的这个元素我是无法统计到的。康康的哈希脉搏里面数组元素的累加方式用了两个方案，第一个当县城竞争不激烈的时候，啊直接用一个case的方式对一个long类型的变量做原子递增。第二个当县城竞争比较激烈的时候，使用了一个康德赛尔的一个速度，然后使用分而治之的一个思想去减少多线程的一个竞争，从而去实现元素个数的原子递增。
	而赛事方法的一个实现逻辑是便利这个康德赛尔数组里面的每一个value值进行累加，再加上best com汇总得到一个数据结果，所以很明显啊赛事方法得到的数据和真实数据必然是不一致的，因为有可能我拿到这个数据的时候，此时当前正好有一个元素添加到这个数组里面，但是我没有统计上去，因为它们之间并没有保证它的一个原子性，因此呢从膳食方法本身来看，它的整个计算过程是限制安全的，因为这里用到了一个case方式来解决并发的一个更新问题，但是站在康康纳哈希迈普的一个全局角度来看，put方法和set方法之间的数据是不一致的，因此也就不是现场安全了。之所以不像哈希table那样直接在方法级别去加同步锁，在我看来呢有两个考虑点，第一个直接在赛事方法上去枷锁就会造成数据写入的一个并发冲突，对于性能的影响呢会比较大。当然啊有些朋友会认为唉我可以加读写锁，啊但同样也会造成put方法的锁的力度会扩大，性能影响呢非常大。第二个，在康康的哈希迈普的并发集合里面，对于SAAS的数据一致性要求并不高，并发集合更多的是去保证数据存储的安全性。
	以上呢就是我对这个问题的理解。关于这个问题啊其实很多的理解都比较片面，导致了大家去找资料学习的时候，很容易被各种不完整的理解所误导，而且啊这个问题的切入角度还挺有意思的。有些同学可能没有往这个方向去思考过，所以也导致无法去很好的回答出这个问题。好的，本期的普通人vs高手的面试系列视频就到这结束了，大家记得点赞收藏加关注，啊我是麦克。我们下一期再见。
380-【Java面试】阿里一面：谈一谈分布式锁的理解与实现？-480P 清晰-AVC
	一个工作了7年的Java程序员，啊他私信我说关于分布式锁的问题，一上来就两个灵魂拷问，release所超时了怎么办？瑞丽丝主从切换导致所失效了怎么办？我说别着急，啊这些都是小问题。那么关于分布式所的理解和实现这个问题，啊我们来看看普通人和高手的回答，不断的回答。嗯分布式锁分母所应该就是它可以具备这种跨进程的锁的一个分布性，也就是说就是我们我们以前传统的那种锁，嘛就是像县城级别锁它只能锁住，单个县城嘛就多个县城，但是县城它是属于进城范围内的，所以如果我我我想就是在整个的分布式架构下，我如果想要去锁定多个进程，对某个资源的访问的情况下，那跨进程的这种锁的话，就是单线程里面是没办法实现，所以会需要用到分布锁。然后实验分布所的话，用reads里面的CS命令就是可以去实现。高手的回答。啊分布所呢是一种跨进程跨机器节点的一种互助锁，啊它可以用来去保证在多个机器节点对共享资源访问的一个排他性。我觉得啊分布所和线诊所的本质上是一样的，啊线诊所的生命周期是单进程多线程，而分布式锁的生命周期呢是多进程多机器节点，他们都需要满足所的几个基本的重要特性。
	首先是排他性，也就是说在同一时刻只能有一个节点去访问共享资源，其次就是可重复性。它允许一个已经获得所的县城在没有释放锁之前重新去获得爽。第三个是锁的获取和释放的方法。第四个是锁的失效机制，也就是说避免死锁的一个问题。所以啊我认为只要能够去满足这些特性的技术组件，都能够去实现分布式。首先第一个啊是关系型数据库，它可以使用到唯一的约束来去实现锁的排他性。如果要针对某个方法枷锁，就可以去创建个表，去包含方法名称的一个字段，并且把方法名称这样一个字段设置成唯一的约束。那么抢占所的逻辑就变成了往表里面去插入一条数据，如果已经有其他的线程获得了某个方法的锁，那么这个时候再去插入数据的时候，一定会失败，所以从而去保证了锁的互斥性，那么这种方式虽然看起来很简单，但是实现比较完整的分布锁还需要考虑到宠物性啊所得失效机制，啊没有抢占的所得县城要等待阻塞等等，都会比较麻烦。所以第二个呢就是Edyth，它里面提供了sett，annexe命令，去实现锁的排他性，p不存在的时候就返回一存在就会返回您。
	然后呢还可以使用explain命令去设置所得失效时间，从而去避免死锁的问题。当然有可能存在锁过期的，但是业务逻辑还没有执行完，怎么办？呢所以这种情况下我们可以写一个定时任务，对指定的key去进行续期。瑞迪显呢这个开源组件它提供了一个分布所的封装实现，并且内置了一个叫 watched dog的极致来对key去做学习。所以我认为瑞迪斯里面这种分布所的设计呢已经能够解决99%的问题了。当然如果在lads搭建了高可用集群的情况下，去出现主从切换导致k失效的问题，也可能会导致多个县城或者京城抢占同一个所资源的一个情况，所以瑞士官方呢也提供了一个叫red rock的解办法，但是时间上会相对复杂一点。所以在我看来呢啊分布所它应该是一个CP模型，啊瑞丽斯呢它是一个APP模型，所以在集群架构下，由于数据的一致性问题导致极端情况下出现的多线程或者多线程抢占锁的情况，很难避免。那么基于CP模型又能实现分布所特性的组件有哪些呢？
	我认为可以选择出keep或者etcd。首先啊在数据一致性方面，猪keep用到了Java协议去保证数据的一致性，而etcd呢用到rap的算法去保证数据一致性。第二个是在锁的互赐方面做keep，它可以基于有序节点，再结合watch机制来去实现复制和唤醒。啊而etcd呢它也可以基于prefix的机制和watch机制来实现互斥和唤醒。以上呢就是我对分布所的一个理解。我认为啊回答这个问题的核心本质还是在技术底层的深度理解和基础的一个思考上，可以从高手的回到中明显的感受到，对于排他所的底层逻辑的理解是很深刻的，同时啊在技术的广度上也是有足够的积累。所以在回答这个问题的时候，呢面试官可以去抓到求职者在回答这个问题的时候的一个技术关键点和技术的一个思考。我认为当具备体系化的技术能力的时候，是很容易应对各种面试官的各种刁难的。好的，本期的普通人vs高手面试系列的视频就到这结束了，喜欢的朋友记得点赞和收藏，另外啊有任何技术上的问题，职业发展的规划的问题，都可以来私信，我我会在第一时间给大家回复。
	我是Mike。一个工作了14年的Java程序员，咱们下期再见。
377-【Java面试】网易二面遇，线程安全问题的理解？面完当场破大防！-480P 清晰-AVC
	一个工作了4年的小伙伴啊遇到一个非常抽象的面试题，他说请你说一说你对县城安全性的理解。这一类问题呢对于临时去刷面试题来准备面试的小伙伴往往是致命的。一个是不知道从何说起，也就是说你的语言组织会比较困难。其次啊就是如果你对县城安全性没有一定程度的理解，一般也很难说出你的理解。Ok我们来看看这个问题的一个回答，普通人的回答。怎么理解县城安全？我认为现成安全性它应该是说在多线程里面，嘛然后有就如果多个县市区对于某些变量的修改或者工厂变量修改，它会导致我的结果的一个不确定性，啊这个就是限制安全，然后。
	高手的回答。简单来说啊在多个县城去访问某个方法或者对象的时候，不管通过任何的方式的调用或者县城如何去交替执行，在程序中啊不做任何同步干预的情况下，这个方法或者对象的执行或者修改都能够按照预期的结果来反馈。那么这个内我们认为它是建设安全的，实际上现在安全问题的具体表现，它有三个方面，也就是说原子性、有序性和可见性。原则性呢就是说一个县城执行的一系列程序指令操作的时候，它应该是不可中断的，因为一旦出现了中断，站在多线程这样一个角度来看，这一系列的程序指令会出现前后执行结果不一致的一些问题，那么这个和数据库里面的原则性是一样的。简单理解就是说一段程序只能有一个线程完整的执行完成，而不能存在多个线程的一个干扰。Cpu的上下文切换呢是导致原则性问题的一个核心，而GM里面呢提供了一个synchronize，关键字来去解决这样一个原则性问题。可见性呢就是说在多线的环境下，呢由于读和写是发生在不同的县城里面的，有可能会出现某个县城对共享辩论的修改，对其他县城不是实时可见的。
	导致可见性问题的原因呢有很多，比如说像CPU的高速缓存，CPU的指令重排序，编译器的指令重排序，而有幸呢说的是程序编写的指令顺序和最终CPU运行的指令顺序，可能会出现不一致的这样一个现象。这种现象呢我们可以称为指令重排序，所以有序性它也会导致可见性的这样一个问题。可见性和有序性，呢我们可以通过GM里面提供的arleta关键字来解决，在我看来啊导致有序性原则性和可行性问题的一个本质是计算机工程师为了最大化地提升CP导致的，比如说为了提升CPU的利用率，设计了3级缓存，设计了缩8份，设计了缓存行的这种预读机制。在操作系统里面设计了线程模型，在编译器里面设计的编译器的深度优化机制。以上呢就是我对这样一个问题的理解。可以发现啊从高手的回答里面可以很深刻地感受到它对于计算机底层的原理和线程安全性相关的底层实现，是理解得很透彻的。对我来说，这个如果去写业务代码，我根本不用担心它滥用线程导致的一些不可预测的线程安全问题了，这就是这道面试题的一个价值。
	好的，本期的普通人vs高手的面试系列的视频就到这结束了，喜欢的朋友记得点赞和收藏。另外这些面试题我都已经整理好了，笔记大家有需要的可以私信我获取，我是麦克。一个工作了14年的Java程序员，咱们。
385-【Java面试】高频面试题：如何提升接口性能？看完血压飙升！-480P 清晰-AVC
	如何提升一个接口的性能？昨天啊也工作了7年的粉丝去高德面试，被问到这个问题的时候回答有点混乱，今天正好有空给大家分享一下这个问题的回答思路，文字版本的回答，我整理到了一个50万字的面试文档里面，有需要的小伙伴可以在我的评论区的视频中去领取，这是一道比较开放性的问题。面试官希望通过这一类的问题呢去打开面试过程中的沟通话题，并且尽可能的让候选人多去表达，从而去更好的了解候选人的技术能力，所以针对这一类的问题啊可以打开回答思路，从宏观到微观，把自己能知道的点全部说出来就好了。下面我们来看一下这个问题的回答方式，影响接口讯能的因素有很多，我基于自己的理解，分别从几个维度来回答。一从接口本身的实现维度来说，可以从几个方面来优化。一如果在接口中有操作数据库层面的代码，可以优化数据库的io的效率，比如说c口优化，数据库层面的优化等等，如果存在部分频繁访问数据库的热点数据，我们可以采用缓存机制来提升数据库io的效率。如果涉及到远程调用或者耗时的方法调用，可以采用异步的方式去避免同步左侧，从而提升程序的运行效率。
	第四，代码本身的优化，可以利用合适的算法减少时间复杂度，避免一些很明显的重复计算等等。第二，从宏观列入的维度来说，可以关注几个方面，第一网络带宽带宽的大小或影响数据的传输效率。第二，服务器的硬件资源，比如说CPU内存会影响到接口中代码的执行效率。第三，单个部署节点的计算能力，瓶颈也会影响接口的性能。我们可以采用分布式部署的方式来进行优化。总的来说一个接口的性能的影响涉及的因素非常多，如果真的出现性能问题，可以根据系统日志以及压测的情况去去分析瓶颈点，再针对性的进行优化。以上就是我的理解。
384-【Java面试】平安一面：数据量达到多少的时候要开始分库分表？-480P 清晰-AVC
	昨天一个工作了7年的粉丝啊去平安面试，在第一面的时候被问到这个问题，没有回答好，最后呢比较遗憾错过了这个 offer，数据量达到多少的时候，开始分不分表这个问题，接下来我说一下我的观点。如果你需要文字版本的完整回答，可以在评论区的置顶中去领取50万字的大场面试指南，这其实是一个比较开放性的问题。因为决定分库分表的因素有很多，比如说查询性能下降或者业务解耦，另外如果单纯基于数据量来推导分不分别的行为呢它是不严谨的。因为里面涉及到变量特别多，比如数据行的大小、索引大小会决定b加速的成高，而层高又间接决定了不同数据量级的一个查询性能。其次对这个表的查询维度，查询条件的复杂度，即便在几十万的数据表中，也可能会出现查询性能低等问题，还有硬件资源的配置性能，比如说带宽、内存、磁盘，也同样会影响到查询效率，甚至啊是表结构设计不合理，也会影响，比如说如果建立的是宽表，也就是一个表中包含太多的链，也会影响查询效率，所以面对这个问题的时候，建议大家可以发散思维去分析，通过知识的宽度来获得认可。
	这个问题需要结合具体业务场景和系统架构来考虑，基于我的理解通常有几个考虑因素，第一单表的数据量，如果单个表的数据量已经非常大，比如说超过百万级别，就需要开始去考虑分表了。第二数据库的性能，当单个数据库的性能无法满足业务需求的时候，就需要开始去考虑分库。第三数据库的访问频率，如果某些表的数据访问频率非常高，单个数据库节点又无法满足高并发需求，就需要考虑把这些表分到不同的数据库节点上，去提高整个数据库的io性能。第四，业务拆分，当系统的业务逻辑越来越复杂，不同业务之间的数据耦合度越来越低，就需要考虑对整个系统进行拆分，以方便管理和扩展。以上呢就是我的理解。
388-【Java面试】春招必刷题：Mysql的事务隔离级别？-480P 清晰-AVC
	一个工作了6年的粉丝去阿里面试，在第一面的时候被问到Michael事务隔离级别的一个问题，他竟然没有回答上来，啊一直在私信我向我诉苦，我只能安慰他，我说以后还有机会的啊慢慢来。好了，关于这个问题我们来看看普通人和高手的回答。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，普通的回答。呃麦塞口的事物隔离级别它有4种，啊第一种是独立提交。第二个是可重复读？啊第三个是串行话，第四个是未提交读。嗯这4种隔离级别代表的是说我在在不同的那个就是我多个事物竞争的时候，啊那么我每一个就是我我的这个事物并罚执行的时候并行执行的时候，我对数据的一个影响，比如说我事物之间的一个隔离性，所以通过嗯不同的这种隔离级别，它可以去解决所谓的这个换毒，啊或者不可重复读，啊以及说那个。读读未提交啊这样一些问题。嗯然后我记得就是这个住最安全的是那种就创新化创新化，就是说它不会存在任何的这个这个什么患毒不可重复读的一些问题。
	高速的回答。好的，啊关于这个问题呢我会从几个方面来回答。首先呢事务主义级别是为了解决多个并行事务竞争导致的数据安全问题的一种规范，具体来说呢多个事物竞争可能会产生三种不同的一个现象。第一个啊假设有两个事物，t一和t二同时在执行，那么t15有可能会读取到7月25未提交的数据，但是未提交的失误，t二有可能会出现回滚，也就导致t15读取到一个最终不一定存在的数据，从而产生一个脏腑的一个现象。第二个是说假设两个事物t一t二同时在执行，那么事物t一在不同的时刻读取的同一行数据的时候，有可能结果会不一样，主要导致一个不可重复度的一个问题。第三个呢是说假设有两个事物t一t二同时在执行，那么事物t一在执行范围查询或者专门修改一个时候，15t2呢插入了一条属于15t一范围内的数据，并且提交了那么这个时候事物t一查询的时候发现多出了一条数据，或者说t一事物发现这条数据并没有被修改，那么看起来像是产生一个幻觉，这种现象呢我们称为患毒。
	而这三种现象在实际应用里面呢可能有些场景不能接受某些现象的存在。所以在CK标志里面呢定义了4种隔离级别，第一种是读未提交，在这种隔离级别下，呢可能会产生脏、毒、不可重复毒以及贩毒。第二组是足以提交在这种隔离级别下可能会产生不可重复毒和患毒。第三种是可重复读，那么在这种隔离级别下可能会产生混合。第四种是那么在这种合理级别下，呢多个变形事物呢会串行化直径不会产生任何安全性问题。在这4种隔离级别里面，呢只有串行化解决了全部的问题，但也意味着呢这种隔离级别的性能是最低的。在max里面啊一诺DB引擎默认的隔离级别是r二，也就是可从不读，因为它需要保证事物acip特性中的隔离性。以上呢就是我对这个问题的理解。关于这个问题，啊很多用了Mexico很长时间的程序员都不一定能够回答得很清楚，这其实啊是非常不正常的，因为虽然啊一诺DB的默认隔离级别能够去解决90%以上的问题，但是有些公司或者某些业务可能会去修改事务隔离级别，而如果你不去注意或者你不知道，就很可能在程序中去出现一些莫名其妙的问题。
	好的，本期的普通人vs高手的面试系列视频，呢就这结束了。如果你有任何的面试问题或者职业发展的问题都可以私信我，我是麦克。一个工作了14年的Java程序员，咱们下期再见。

382-【Java最新面试题】为什么阿里禁止直接使用日志系统的API？-480P 清晰-AVC
	为什么阿里要禁止直接使用日志系统的API呢？Hello大家好，我是麦克。一个自认为把八股文刷到炉火纯青的粉丝，在面试的过程中突然被这个奇葩的问题给难住了，心想阿里为啥要禁止，我怎么知道我又没去过阿里，关于这个问题的回答，呢在我之前整理的大厂面试指南里面其实也有，你们可以在评论区的置顶中去领取这个文档。其实这个问题我认为在面试过程中会问到的可能性会比较小，因为不同的公司啊有自己的开发规范，开发规范的目的是为了提高代码的可维护性，稳定性和安全性。所以不同规模的公司啊在制定这类规范的时候，考虑的方向和规范的要求会有一点差异的，但这个差异我认为不足以去验证一个候选人的技术水平。如果希望通过这个问题去了解候选人的真实水平，我认为可以直接通过去问，直接使用日志API和直接使用门面模式的区别和好处就好了，没有必要去带上阿里这个字眼。不过如果大家后续遇到类似的问题，通常的回答一般可以直接说一下开发规范本身的价值就好了。或者说我没有了解过阿里的开发规范，那你可以去把这个问题描述更详细一点吗？这样的话我也能够更好的去展示我的真实水平。
	在Java生态中涉及到日志的框架有很多，比如说logo Forgey logged back，Lague Forgey二以及cai Forgey等等，如果在我们的开发过程中直接使用具体的日子API，那么在未来如果需要去实现日志组件的升级和切换，就会变得很困难，基本上是属于牵一发而动全身。一般情况下我们会建议直接使用门面模式，也就是说提供一个统一的接口去访问多个子系统的不同的时间内，这样的话对于应用程序来说，无论底层的日志框架如何变，都不需要有任何的感，只要门面服务做得足够好，随意更换另外一个日子框架，应用程序不需要修改任意银行代码，直接上线。即使有一天要更换代码的日志框架，只需要修改一个假包，最多再改改日志输出相关的配置文件就可以了，这个设计有一个很好的点就就是解除了应用和日子框架之间的耦合，以上就是我的理解。
383-【Java最新面试题】业务开发面试：什么叫阻塞队列的有界和无界-480P 清晰-AVC
	昨天有一个三年加我经验的小伙伴私信我，他说现在面试怎么这么难？啊我只是面试一个业务开发，他们竟然问我什么叫阻塞队列的有界和无界。如果你也遇到过类似的问题，那么我们来看看普通人和高手对于这个问题的回答，吧普通人的回答，嗯有些队列是说队列元素的一些个数是有一个限制的，而无界就是表示我对这种元素它没有任何的限制，像像艾瑞斯的 broken cued，就是一个有界的队列，就是我们可以在iOS里面去设置就元素的个数，因为iOS它是一个数组结构的队列，嘛所以就可以通过这个就是设置，通过这个构造方法去设置一下这一列的长度，高手的回答。我们来看这个图，主车队列呢是一种特殊的队列，它在普通队列的基础上呢提供了两种附加的功能。第一个，当队列为空的时候，获取队列中元素的消费者象征它会被阻塞，同时会唤醒生产者宣传。当队列中的元素满了的时候，向队列中去添加元素的生产的线程会被阻塞，同时会唤醒消费者县城，其中左侧队列中能够容纳的元素个数通常情况下是有限的。比如说我们去实地画一个air block list，可以在构造方法中去传入一个整形的数字，表示这个基于数组的组成队列中能够容纳的元素个数，这种我们称为有界队列。
	第三而无界队列就是没有设置固定大小的队列，不过它并不像我们理解的那样元素中没有任何限制，而是它的元素存储量很大。像linked的cue，它的默认队列长度是因特点马克思Valeo，所以我们感知不到它的长度限制。最后无界队列存在比较大的潜在风险，如果我们在并发量比较大的情况下，线程池中几乎可以无限制的添加任务，容易导致内存溢出的问题。以上呢就是我对于这个问题的理解。主色队列在生产者消费者模型的场景中呢使用的频率是非常高的，比较典型的是在现成池中通过阻塞队列来实现现成任务的生产和消费的功能。基于阻塞队列实现生产者消费者的模型比较适合在异步化的性能提升的一些场景，以及做并发流量缓冲类的场景中，在很多开源中间件中都可以看到这种模型的一个使用，比如说在猪keep的源码中就大量用到了组织队列来实现生产者和消费者的模型。好的，那么本期的普通人vs高手面试系列的视频呢就到这结束了，喜欢的朋友记得点赞和收藏。我是麦克一个工作了14年的Java程序员，咱们下期再见。
387-【Java面试】场景面试题，线上几百万的消息积压如何处理？-480P 清晰-AVC
	线上环境几百万的消息积压应该如何处理呢？Hello大家好，我是酷跑科技联合创始人麦克，今天给大家分享一下这个面试题的回答思路，另外想要文字版本答案的小伙伴可以在我的评论区的置顶中去领取30万字的面试文档。这个文档呢不仅仅包括各个一线大厂的面试真题，而且对每道题目呢都进行了详细的解释，能够帮助你们提升至少80%的面试通过率，没有任何边界的场景问题，啊基本上都是开放性的面试题。所以这一类问题更多的是考察求职者解决问题的思路。求职者可以根据这样一个消息队列的一个架构，按照请求到消费的顺序啊去提供解决思路，这样既能够保证回答思路的逻辑性，又能更好的去梳理回答思路，确保回答内容的完整性。下面呢我们看一下完整的回答。首先我们需要确定是什么导致的消息积压，可能是消费者处理消息速度太慢，也可能是生产者产生消息的速度太快，这可能是由于代码的问题，比如说异常处理不当，或者县城管理不合理等等，找到问题以后可以针对性的进行优化。优化的方式呢主要有以下几种，第一，如果是消费者处理速度过慢，我们可以尝试增加消费者的数量，比如说增加消费单处理消息的线程数量，或者扩展出更多的实力来处理消息。
	第二，如果是消费的业务逻辑处理上有问题，可以优化消费的业务逻辑，提升处理效率。比如说提升算法效率，节省io操作，优化数据库的访问性能等等。第三，如果消息队列中存在大量无效消息或者不重要的消息，可以在生产端或者消费端进行过滤，减少处理消息的数量。第四，优化mq本身的参数配置，正确设置对应的参数，可以帮助系统在保持高吞吐量的同时减少系统的延迟。以上就是我的理解，我是麦克感谢大家的点赞和关注，我们下期再见。
390-【Java精选面试题】网易一面：Java中的单例模式如何实现？-480P 清晰-AVC
	在Java里面啊实现单例模式有哪些方法？屏幕前的你们是不是感觉这个问题很简单？但实际上呢有一个同学曾经去快手面试的时候，啊被更进一步的问到，写一个性能最好的单立模式，结果很显然没有回答上来。Hello大家好，我是麦克。一个工作了14年的Java程序员，关于这个问题的解析和高手部分的回答，我已经把它整理到了一个20万字的面试文档里面，大家可以在我的主页去领取那这个问题，面试官想考察什么呢？这是属于设计模式里面的一个问题，我们知道Java有23种设计模式，但是真正在实际开发中能够去熟练使用设计模式的很少，很多人说没有场景，但其实只是因为他们只理解了设计模式的概念，这个问题考察求职者对于设计模式的理解和应用，本质上来说还是考察基本功。当然啊针对不同的工作年限，考察的深度有所不同，对于刚工作的同学来说，只需要去了解什么是单例，以及如何写出一个单例就行。对于工作年限比较长的同学，还需要考察单列模式的性能，以及避免破坏单列的一个情况等等。丹利模式就是一个累，啊在任何的情况下绝对只有一个实力，并且提供一个全局访问点来获取这样一个实例。
	要实现单例啊至少需要满足两个点。第一个私有化构造方法，防止被外部实际化造成多实际的问题。第二个提供一个静态方法，作为全局访问点来获取这个唯一的实力对象，在Java里面至少有6种方法来实现单例。第一种是最简单的一个实现，通过延迟加载的方式来进行实例化，并且增加了同步锁的一个机制，去避免多线程环境下的一个线程安全问题，但是这种枷锁方式呢会造成性能问题，而且同步锁只有在第一次实例化的时候才会产生作用，后续就不需要了，于是就有了第二种改进的方案。通过双重检查手的方式，减少锁的范围来提升性能。第三种通过饿汉式的方式去实现单利，这种方式在内加载的时候就触发了一个实例化，从而去避免多线程同步的问题。还有一种与这个方式类似的实现，通过在静态块里面去实例化，而金太快是在类加载的时候触发执行的，所以也只会执行一次。下面两种方法呢都是在类加载的时候，说实话没有达到延迟加载的一个效果，当然本身影响也不大。但是其实还是可以更进一步的去优化，就是可以在使用的时候去触发，说实话。
	像这种写法，把inside的实例啊写在一个静态的内部类里面。由于静态内部类，只有在调用静态内部的方法，静态域或者构造方法的时候，才会加载静态内部内，所以single被加载的时候不会初始化instant，从而去实现延时加载。另外我们还可以使用枚举类来实现这种写法，既能避免多线程的一个同步问题，又能够去防止反序列化重新创建新的对象，也是一个比较好的方案。当然除了这些方案以外，也许还有更多的写法，只需要去满足丹利模式的特性就好了。我认为可以通过三种方式来去实现单例。第一种是通过双重检查所的方式，它是一种现存安全，并且是延迟实力化的方式，但是因为枷锁，所以它会有性能上的一个影响。第二种是可以通过静态内部类的方式来实现，它也是一种延迟实力化，由于它是静态内部类，所以只会在使用的时候加载一次，不存在现场安全问题。第三种是可以通过霉菌类的方式来实现，它既是现在安全的，又能防止反序列化导致破坏单列的问题。但是多线程克隆反序列化反射都有可能会造成单粒破坏。
	而我认为通过枚举的方式去实现单例，是能够去解决所有可能被破坏的一个情况的。以上就是我的理解。好的，大家知道在下次面试的时候应该怎么回答了吗？如果你喜欢的作品记得点赞收藏加关注，我是麦克。咱们下期再见。
389-【Java精选面试题】Java的垃圾收集器有哪些，各有什么特点？-480P 清晰-AVC
	昨天啊一个工作两年的粉丝去一个外包公司面试，被问到Java垃圾收集器有哪些？各有什么特点？当时他没有回答上来，老是错过了这样一次机会。Hello大家好，我是酷泡科技的联合创始人麦克，今天就给大家分享一下这个问题的原理和回答。另外我把往期的视频内容整理成了一本面试突击手册，一共有35万字，里面包含各个一线大厂的面试真题的解析，并且对每个问题有非常详细的文字解析，有需要的小伙伴可以在我的评论区的置顶中去免费领取。Java垃圾收集器啊是Java运行时环境中最重要的一个部分，它帮助我们自动去处理内存的释放问题，从而去降低了程序员在开发过程中啊对内存的管理和回收商的负担，这也是Java语言被广泛应用的原因之一。Gps中提供了不同类型的垃圾收集器，每一种都有它的优势和特点。面试官问你这个问题啊主要是想知道你对家务垃圾收集器的理解程度，你是否了解各种垃圾收集器的工作原理和使用场景？理解这部分内容，呢它会对你解决内存问题，优化程序性能方面有很大的帮助。
	下面我们来看一下这个问题的回答。在Java中呢有几种主要的垃圾收集器，第一，虽然收集器这个是最基本历史最悠久的收集器，他在进行垃圾回收的时候会暂停所有的用户线程，直到他完成垃圾收集，所以通常呢在单核CPU或者较小的应用中去使用。第二，海瑞收集器也称为吞吐量优先收集器，他的目标是获取最高的吞吐量，即最大限度的去减少垃圾收集的总的时间。凯瑞收集器在垃圾收集的时候也会去暂停用户线程。第三，CMS收集器也称为并发标记清除收集器。他的目标是去获取最小的垃圾收集的停顿时间，它主要是通过并发的方式去减少垃圾收集的停顿。最后是g望收集器，它是一种面向于服务器的垃圾受气，它主要应用于多核或者大内存的环境，他能够预测垃圾收集的停顿时间，尽可能的去减少停顿。以上就是Java的主要垃圾收集器以及它的特点。在实际开发过程中，使用哪一种收集器，取决于你具体的业务需求。以上就是我对这个问题的理解。
392-【Java精选面试题】请你说一下线程池的线程回收？-480P 清晰-AVC

Hello大家好，我是麦克。一个工作了14年的Java程序员，最近啊很多小伙伴来私信我，让我说一下现成吃相关的一些面试题。现在持这个方向的考察点啊其实还是挺多的，如果只是靠单纯的刷面试题，面试官呢很容易能够识别出来。我随便举几个问题，啊比如说现成池是如何实现现成回收的，核心线层是否能够回收，呢当调用线能持着下蛋方法的时候，会发生什么样的一个事情？面试啊一定是连环问，从而去确定求职者对这个领域的理解程度。关于现成池回收的相关问题，呢高手部分的回答，我已经整理到了一个20万字的面试文档里面，大家可以在我的主页去加v领取。下面我们来看看普通人和高手的回答，普通人的回答。就现成池它是在就是在那个任务空闲的情况下那个限制就会被回收，然后回收的方式，呢就是因为县城工作县城是从组织队里面去拿任务，嘛然后然后这个时候空闲空闲的话应该是是过了，等待一定时间没有没有任何任务过来的时候就那个这个县城当前这个县城就会自己销毁掉。高手的回答。好的，面试官，这个问题啊我需要从三个方面来回答。
	首先线程池里面分为核心线程和非核心线程，核心县城啊是常驻在县城池里面的工作县城，它有两种方式来初始化，第一种是向线程池里面添加任务的时候被动初始化，第二种是主动调用priest噢 cosplay的方法，然后去完成中石化当县城池里面队列满了的情况下，呢为了增加现实池的任务处理能力，啊现实池呢会增加非核心县城核心县城和非核心县城的数量，是在构造线程池的时候去设置的，也可以动态进行更改。由于非核心县城是为了解决在任务过多的情况下呢临时增加的，所以当任务处理完成以后，啊工作线程处于空闲状态的时候呢就需要进行回收，因为所有工作线程都是从阻塞队列里面去获取要执行的任务，所以只需要在一定时间内阻塞队列，没有任何可以处理的任务，那么这个线程呢就可以结束了。而这个功能是通过组织队列里面的破方法来完成的，这个方法里面提供了一个超时时间和超时时间单位这两个参数。当前县城在指定的时间没有从主车队里面获取任务的时候，那么破方法呢会返回，那从而去终止当前的县城，完成县城的回收。默认情况下，呢线程池只会回收非核心线程，如果我们希望核心线层也要能回收，那么我们可以设置噢落cos太帽子这样一个属性设置为to就可以了。
	一般情况下我们不会去回收核心线层，因为线程池本身就是实现线程的一个复用，而且啊这些核心线程在没有任务处理的时候呢是处于阻塞状态，并没有占用CPU资源，以上呢就是我对这个问题的理解。关于线程池啊是每一个Java程序员必须要深度掌握的内容，它很重要。在我们的应用系统里面无处不在，体现县城，包括在应用开发里面也难免会用到县城时，掌握好它呢能够去写出更加健壮性和稳定性的程序。好的，本期的普通人vs高手的面试系列视频就到这里结束了，大家记得点赞收藏加关注，我是Mike，我们下期再见。
391-【Java精选面试题】秋招高频：什么是链路追踪？-480P 清晰-AVC
	关于面试题什么是列入追踪？我们应该怎么回答？Hello大家好，我是麦克一个工作了14年的Java程序员，我最近把高手的回答整理到了一个20万次的面试文档里面，大家可以在我的主页去领取。这个问题啊面试官想考察什么呢？列入追踪是分布架构下的一种监控方式，对于一些规模比较大的分布系统来说，一个用户的请求啊可能需要涉及到多个子系统的一个流转，而且随着业务的不断增长，呢服务之间的调用关系也会越来越复杂。在这样一个背景下，呢我们一方面需要去了解整个请求列入的调用关系，去定位到性能和故障的一些问题。另外一个方面，我们还需要从整体到局部去展示各项系统的一个指标，快速实现故障的定位和恢复，所以产生了列入追踪的这样一个需求，最早的列入监控系统呢是Google的搭配。在2010年的时候，Google发布了一篇论文，介绍了dubb整体设计，目前市面上所有的链路监控系统都是在它的理论模型下衍生出来的，包括阿里的鹰眼，大众点评的cat，Twitter的GP等等，有了全链路监控工具，解决了以下几个方面的问题。
	第一个请求列入追踪，故障的快速定位，可以通过调用链路结合业务日志去快速定位搜狐信息。第二个可视化，我们可以通过一个可视化的界面去了解整个请求链路中各个阶段的耗时去进行性能的分析和调优。第三个依赖优化，我们可以了解各个调用环节的可用性，梳理服务依赖关系以及进行相关优化。第四个数据分析，我们可以得到用户的行为路径去汇总分析应用在很多业务场景中的一些价值体现。考察这个问题的公司呢一般都是有一定规模的中大型互联网公司，因为一些小型企业本身的技术架构并不复杂，因此呢没有必要去做一些链路追踪方面的设计，有点浪费资源，而且这个问题考察点一般不会太深入，除非是面对比较资深的求职者，而且可能还会去继续了解链路追踪的一些实现原理。建议求职者。根据自身的情况去简单明了的把这个问题表达清楚就好了。下面我们来看一看面试过程中高手是怎么回答这个问题的。列入追踪呢是一种针对分布式架构下实现请求列入可视化监控的一种技术。那核心目的啊是去了解分工系统中的一些请求调用的一个行为，从而去从整体到局部去详细展示各个系统的一个指标，去实现故障快速定位和缩短故障的排出的一个时间，常用的内容追踪工具呢有像CK把我给看突破等等。
	不过列入追踪呢只是分布式列入监控工具里面的核心之一。除此之外呢还包括可视化，服务依赖关系的梳理，数据分析能力等等。以上就是我对这个问题的理解。好的屏幕前的你。学费了吗？如果你喜欢我的作品，记得点赞收藏加关注我是麦克。咱们下期再见。
394-【Java面试】什么是时间轮，请你说一下你对时间轮的理解？-480P 清晰-AVC
	Hello大家好，我是麦克。一个没有才华，只能靠颜值混饭吃的加入程序员。一个工作了7年的程序员啊去字节面试的时候被问到石杰伦的问题，他面试回来的时候跟我说这个问题啊超出了他的知识面，自己也在网上找了一些文章去学习，但是呢理解不是很深刻。想让我去出一期关于石杰伦的面试视频，谁叫我这么善良，呢立刻就给他安排了。关于什么是石杰伦，以及请你说一下你对于石杰伦的理解，另外我把网签的内容都打包在了Java面试，里面，包含了35万字的面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的主页去加v领取。啊下面我们看看普通人和高手的回答，普通人的回答。啊石杰伦。直接轮。我记得好像是一种数据结构。吧它可以用来存储数据，存储那个定时任务的具体的话我记得在那个在那个 Net里面好像是有一个这样的叫石杰伦的一个代码，好像不太高手的回答。好的，面试官。石杰伦啊简单理解就是一种用来存储一系列定时任务的环状数组，它的整个工作原理和我们的钟表的表盘类似，啊它有两个部分组成，第一个是环状数组，另外一个是便利整个环状数组的一个指针。
	首先定一个固定长度的环状数组，然后数组的每一个元素代表一个时间刻度，假设是一秒，那么如果是长度为8的一个缓冲速度，那么代表8秒钟时间，然后有一个指针，这个指针呢按照顺时针无限循环这个速度，每隔最小的时间单位前进一个数组索引，那么这个指针转一圈代表8秒，转两圈大约16秒。假设从零点零分零秒开始，转一圈以后就到了00:00:09，环状素组里面的每一个元素都是用来去存储定时任务的一个容器，当我们向时间轮里面去添加一个定时任务的时候，啊我们会去根据定时任务的执行时间，计算出他所在的一个存储数组一个下标，有可能在某个时间刻度上存在多个定时任务，那么这个时候我们会采用双向列表的方式来进行存储。当指针啊指向某个数组的时候，就会把这个数组里面存储的任务去取出来，然后遍历这个链表逐个去运行里面的每个定时任务，如果某个定时任务的执行时间大于环状数组转一圈所表示的长度的时候，那么一般可以使用一个圈数来表示这个任务的延迟执行的一个时间，也就是说啊如果是第十六秒要执行一个任务，那么意味着这个任务应该是在第二圈的数组下标0的位置去执行，使用石杰伦的方式来管理多个定时任务的好处呢有很多。
	我认为有两个点是很关键的，第一个是减少定时任务的添加和删除的时间复杂度，提升性能。第二个啊可以保证每一次执行定时任务的时候都是一个常量的时间复杂度，在定时任务比较密集的一个情况下，性能的优势是非常明显的，当然它有缺点，对于执行时间非常严格的任务，石杰伦呢并不是非常适合，因为石杰伦的算法的精度取决于最小的时间单元，假设以一秒作为一个时间刻度，那么小于一秒的任务就无法被时间人去管理。实际人算法在很多地方都有用到，比如说像double啊媒体啊卡夫卡里面都有。以上就是我对这个问题的理解。实际的算法呢是一个比较有意思的设计，使用的范围呢也比较广，啊大家在实际应用中可能大部分同学接触比较少，我认为啊这种设计思想或者这种数据结构，在我们实际应用中呢某些特定场景是可以去借鉴和使用的，比如说定时从事啊衰减从事啊等等。好的，本期的普通人vs高手的面试系列视频就到这里结束了，大家记得点赞收藏加关注。啊我是麦克。我们下期再见。

398-【Java面试】说一下你对CompletableFuture的理解？-480P 清晰-AVC
	什么是cumbly的feature？嗨大家好，我是麦克。一个工作了14年的加号程序员，其实给大家分享一下面试过程中遇到这个问题我们应该怎么回答。另外我把网签的内容都打包在了加我面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在评论区的置顶中去领取。卡雷的future是家要把illu的一个它可以解决异步执行任务和处理异步任务的结果。康普顿future呢确实是一个很实用的组件，面试官想通过这个问题去考察候选人是否熟悉异步编程的概念，是否能够编写异步代码。另外compleat bruecher可以优化系统的性能和响应速度，所以面试官想要考察候选人是否能够设计和优化高性能高并发的一些系统，并且能够使用complied的future等工具来实现优化。下面我们来看一下这个问题的回答。Comply的feature呢是Java吧里面引入的一个组件，它提供了一种简单且强大的方式来处理异步任务和处理异步任务的结果。
	在康普顿需求出现之前，我们只能使用 callable future这样的一个机制来去获取一波线程的执行结果，但future是通过阻塞等待的方式来实现的，对性能不是很友好，而使用comply的future可以让我们将一个耗时的任务提交给现存池呢进行异步处理，然后可以继续执行其他任务，等到异步任务雏形结束以后，会触发一个回调方法，我们可以在回调方法里面去处理异步任务的执行结果，相当于优化了future的阻塞等待的问题。类似于一种响应式编程方式，compleat QQ提供了一些便捷的方法，比如说 then apply，then accept，先run等等。可以让我们以链式的方式来处理异步任务的执行结果，从而更加灵活的去编写异步代码。以上就是我的理解。如果你喜欢这个作品，记得点赞和关注，我是麦克，我们下次再见。
397-【Java面试】腾讯二面，Kafka怎么避免重复消费？-480P 清晰-AVC
	嗨大家好，我是Mike。一个工作了5年的粉丝找到我，他说麦克老师你要是能回答出这个问题，我就佩服你，我当场就懵了。现在打赌都这么随意了吗？我问他这个问题是什么？他说卡夫卡如何去避免重复消费的一个问题。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图。如果你需要可以在我的主页价位去领取。下面我们看看普通人和高手对于这个问题的回答，普通人的回答，卡夫卡怎么去避免重复消费？我们可以通过嗯就我们我们可以在那个消息消费的这个这一端，就是我们可以用类似于分布式锁的这样一个设计，吧就是说嗯我我消费一个消息的时候，我可以直接用比如说用ready里面的set，那是这样一个这样一个指令，然后去把那个嗯消息保存到那个瑞丽丝的没保证lady里面，然后我后面再再如果重复发送的话，那我就直接只要去判断，这个约定是没有没有存在就好了，嗯这样的话就可以避免吧高手的回答。好的，观众问题呢我会从几个方面来回答，首先卡夫卡的broke上存储的消息都有一个offset的一个标记，然后卡夫卡的消费者是通过office这个标记来维护当前已经消费的一个数据的，然后消费者每消费一批数据，呢卡夫卡布洛克就会更新office的一个值，避免重复消费的一个问题。
	那么默认情况下消息消费完成以后会自动提交offset这样一个值，避免重复消费。卡夫卡的消费端的自动提交的逻辑里面有一个默认5秒的一个间隔，也就是说在5秒之后的下一次向博客去获取消息的时候，来实现office的一个提交，所以在consumer的消费过程中，应用程序强制被care掉或者宕机的时候，可能会导致office没有提交，从而会产生重复消费的一个问题。除此之外呢还有另外一种情况也会出现重复消费。在卡夫塔里面呢有一个叫part一个机制，就是把多个pet均衡的分配给多个消费者，那么康薛某端呢会从分配的protection里面去消费消息，如果康薛某在默认的5分钟以内没办法处理完这一批消息的时候，就会触发卡夫卡的瑞贝ns的一个机制，从而导致office自动提交失败。而在重修率班的c以后，呢康宣布端还是会从之前没有提交的offset的位置开始去消费，从而导致重复消费的一个问题。那么在这样一个背景下，我认为去解决重复消费的问题呢有很多方法，第一个啊我们可以提高消费端处理性能，去避免触发白s比如说我们可以用异步的方式来处理消息，那么缩短单个消息的缴费时长，或者还可以调整消费端消息处理的一个超时时间，我们可以把它拉长一点，对不对？同时还可以减少一次性从block上获取的消息条数。
	第二个我们还可以针对每一条消息啊去生成一个MD5的一个值，然后保存在数据库或者reds里面。那么在处理消息之前，我们先去卖水果或者ready里面去判断是否已经存在相同的消息的MD5值，如果存在，那么我就不需要去再消费了。那么这个方法其实就是利用幂等性的这样一个思想来实现。以上呢就是我对这个问题的一个理解。重复消费这个问题啊其实很重要，如果没有考虑到就会出现线上的数据问题。所以在面试的时候，呢这些问题也能够考察求职者的技术能力和实践能力。另外关于幂等性的问题，呢我在前面的视频里面有讲，大家可以去自己找一找。好的，本期的普通人vs高手的面试系列的视频呢就到这里结束了。喜欢我的作品的小伙伴记得点赞和收藏加关注。我是Mike。一个工作了14年的加号程序员，我们下期再见。
396-【Java面试】京东二面：关于Synchronized锁升级的原理？-480P 清晰-AVC
	Hello我是Mike。一个工作了7年的粉丝啊来找我，他说最近被各种所给搞晕了，他说有什么共享所啊排，他所啊偏向所啊轻量级、所啊自选、所啊重量级、所建系、所零件、所意向、所读、写所乐观锁、悲观锁、表锁、行锁，他说这么的锁到底应该怎么去学习？然后前两天去面试，又被问到偏向锁轻量级锁，结果没有回答上来。Ok啊关于Segal的锁升级的原理，以及说偏向锁轻量级锁，我们看看普通人和高手的回答，另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图。如果你有需要，可以在我的主页加v去领取。啊普通人的回答，我觉得引入这些锁的目的应该是考虑到应该是考虑到那个性能问题。吧因为我记得好像是说呃辛苦net里面它去加这个嗯锁的时候，就是如果它加重点律所的话，它的这个县城会存在这个主就是会影响性能。嗯所以才引入了沿线索的一个机制。然后升级的话就是说啊就是说我我们的获取所的时候，它就是按照偏向锁轻量级锁和和和重量所的方式去去竞争说吧高手的回答。
	好的，面试官。辛苦奈子呢在gdk1.6版本之前，啊是通过重量级锁的方式来实现线程之间的一个锁的竞争的。之所以称它为重量级锁，是因为它的底层依赖操作系统层面的马克思洛克来去实现互制锁的一个功能。马泰克呢是系统方法，由于权限隔离的关系，啊应用程序调用系统方法的时候需要切换到内核状态来执行，那这样就涉及到用户态向内核态的一个切换这个切换会带来性能上的一个损耗。所以啊在gdk1.6版本之后，呢辛苦nice增加了锁的升级这样一个机制，来平衡数据安全性和性能的一个关系。简单来说就是县城去访问sink同步代码块的时候，辛苦nice，根据县城的竞争情况先去尝试，在不加重量级锁的情况下去保证现场的安全性，所以呢引入了偏向锁和轻量级锁这样一个机制。偏向锁就是直接把当前的锁偏向于某个县城。简单来说就是通过 case机制来修改偏向锁的一个标记，这种锁啊适合在同一个县城多次去申请同一个锁资源的情况，并且没有其他县城竞争的一个场景中，轻量级所呢也可以称为自旋锁，它是基于自适应自旋的机制，通过多次自旋去从事竞争所，自选锁的优点在于它可以避免了用户态到内核态切换带来了一个性能损耗。
	辛苦nice呢引入了所升级这个机制之后，啊如果有县城去竞争所，那么首先啊辛苦奈子会尝试使用偏向左的方式去竞争所资源，如果能够竞争到偏向锁，那么表示枷锁成功，直接返回就好了。如果竞争偏向锁失败，说明当前已经有其他线程占用了偏向锁，那么就需要将锁升级到轻量级锁。在轻量级锁的状态下，竞争锁的线程会根据自适应自旋次数去尝试自旋占有锁资源，如果在轻量级锁状态下还是没有竞争到锁，呢那我们只能是升级到重量级锁。那么在重量级锁的状态下，没有竞争的锁的线程会被阻塞，那么这个时候限制的状态叫block，也就处于所等待的一个状态，处于所等待状态下的县城啊需要等待，获得锁的线程释放锁之后触发唤醒。总的来说啊辛可奈子的所得升级的设计思想，在我看来本质上是一种性能和安全性的一个平衡，也就是说啊如何在不枷锁的情况下去保证现成的一个安全性。这种思想在编程领域是比较常见的，比如说麦水口里面的mvcc使用了版本链的方式来解决多个并行事务的竞争问题。
	以上就是我对这个问题的理解。关于锁在程序中是一个非常常见的内容，我们几乎每天都与锁打交道，比如说max里面的表锁和行锁，因此啊它的重要性是不言而喻的。我们从高手的回答里面可以很明显的看到，高手对于single那种理解的层次是非常高的。好的，本期的普通人vs高手的面试系列视频呢就到这结束了。如果你喜欢我的视频，记得点赞加关注加收藏，啊我是麦克一个工作14年的Java程序员，我们下一期再见。
399-【Java面试】网易一面：Mybatis中#{}和${}的区别是什么？-480P 清晰-AVC
	一个工作了两年的粉丝啊被问到一个my best里面的一个基础问题。他反过来调戏我，他说麦克老师你要是能把这个问题回答出来，就请我喝一个月奶茶。我说好吧，那这个问题我们来看看是什么，是my best里面的警号和多了号的区别，对于这个问题啊我们来看看普通人和高手的回答，普通人都回答。另外我把网签的内容都打包在了加我面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图。买贝利斯里面的井号和多了号的区别，多乐号它是一种可以动态替换的。嗯也就是说就是它是就是如果我要对那个 CQ语句去做一些动态的，比如动态表明或者动态的一些这个呃查询条件的情况下，它是可以通过多了号的。而井号是一种站位服，站位服务的话，就相当于我是针对一个直的替换，那么他嗯更多就是它会去用在这种参数层面，去比如说一些参数的一个属性值上面，他没有办法去提供提供这种动态的一个替替换。啊他在设置这个值的时候，就是它会去自动加一些嗯这个这个双引号或者是做以字符串的方式去拼接进去。
	高手的回答。好的，关于这个问题呢我会从几个方面来回答。首先 my business里面提供了井号和多了号两种占位符，都是去实现动态c口的一种方式，通过这两种方式可以把参数传递到xm里面。那么在成立以后，呢在执行操作之前，MAC律师会对这两个占位符进行动态的解析，井号站位服呢等同于GDP里面的一个问号，站位服，它相当于像属于配套的statement里面的预处理语句设置参数，而拍的里面的CQ语句呢它是预编译的，那么CQ语句里面呢使用了占位符，规定了CK语句的一个结构，并且在设置参数的时候，啊如果有特殊字符会自动进行转印，所以井号占位符可以防止血液注入，而使用多热号的一个方式传菜，呢相当于直接把参数拼接到了原始机构里面。My business呢不会对它进行任何的特殊处理。所以多了和井号最大区别在于前者是动态参数，后者是占位符动态参数无法防止c可注入的一个问题，所以在实际应用里面呢尽可能的应该去使用井号站位服。
	另外多了符号的动态传参可以适合应用在一些动态接口的场景里面，比如说动态传递表明啊或者动态设置排序字段等等。以上就是我对这个问题的理解。一个小的细节如果不注意，就可能会造成巨大的一个损失。比如现在还是会有一些网站会出现CQ注入，导致信息泄露一些问题，对吧？那这个影响是很大的。好的，那么本期的普通人vs高手的面试系列视频呢就到这结束了，如果你喜欢这个视频，记得点赞和收藏，如果有任何的面试问题或者职业发展的问题，都可以来私信我，我是麦克。一个工作了14年的Java程序员，咱们下期再见。




393-【Java精选面试题】谈谈常用的分布式ID设计方案？-480P 清晰-AVC

	请你谈一谈常见的分布式ID设计方案。一个工作的青年同学呢被问到这样一个问题，问题呢并不难，但是在实际回答的时候，如果只是回到了123，是很难通过面试的，因为作为一个高级程序员来说，还需要有自己的理解和思考。Hello大家好，我是麦克一个工作了14年的加号程序员，这个问题的高手回答，呀我已经把它整理到了一个15万字的面试文档里面，大家可以在我的主页去加v领取。下面我们看看普通人和高手的回答，普通人的回答。呃 Id设计方案的话有像可以用ready r一s里面它本身提供的那个原子递增的一种方式叫recommend，它就可以去实现，然后呢还可以使用mic的一个全局表，就通过一个全局表来去生成ID。还有。就是对，就悠悠ID也可以。就 Java里面的一个uid可以去生成全局ID的一个方式。高手的回答。好的，这个问题呢我需要从几个方面来回答，首先啊分布式全局ID的解决方案呢我认为有很多，比如说像可以使用MAC口的一个权限表，或者使用猪keep的一个有序节点，或者呢使用芒果DB里面的object，ID或者是ready里面的一个自增ID，以及优于ID等等。
	那么这些方案呢只是解决基础的ID唯一性的一个问题，在实际生存环境里面呢我们需要去构建一个全局唯一的ID，那么还需要考虑很多的一些因素，比如说像有序性，那么有序的ID能够更好的去确认数据的一些位置，以及在b加速的一个存储结构里面，呢范围查找的效率会更高一些，并且呢可以提升b加速的一个数据维护的一个效率。第二个是安全性，那么它可以避免恶意去扒取数据造成数据泄露的一些问题。第三个是可用性，那么ID生成系统的可用性的要求会非常高，一旦出现故障的时候会造成大部分业务不可用的一个问题。最后一个是性能，那么全局ID的生成系统需要去满足整个公司的一个业务的需求，像涉及到e级别的一个调用，那么对性能的要求呢会比较高。因此如果我们假设选区数据库的全局表来作为一个全局ID的设计系统，那么你每获取次ID就需要去更新数据库，它的性能上线是比较明显的，而且其余数据库去构建一个高扩展和高性能的一个解决方案，它的难度是很大的，所以目前市场上主流的解决方案呢都是基于推特早期开源那个叫斯诺fact雪花算法，它呢是一个由64位长度组成的一个全局ID的一个生成算法，它是通过对64位进行一个区间划分来表述不同含义，来实现唯一性的一个算法。
	它的好处呢是算法的实现非常简单。第二个呢是它不存在太多的一个外部依赖。第三个它可以生成一个有意义的有序编号。第四个呢它是基于未运算性能也比较好，推的特色的峰值是10万个每秒。另外美团公司呢开源了一个全局唯一ID生成系统叫类，它里面也用到了一个血换算法去生成一个全局ID，并且啊它在高性能和高可用方面，他做了很多的一些优化，为美团的内部业务啊提供了每天上亿次的一个调用，以上就是我对这个问题的理解。很明显啊这是一个热点问题，并且在实际应用中呢也是使用比较广泛的一个技术，建议各位粉丝在这个领域上去做一些更深层次的一个思考和研究，从而去应对面试官的更进一步的追问。记住啊全局ID的本身设计方案和实现细节是非常重要的。好的，本期的视频就到这结束了，大家记得点赞，收藏加关注，我是麦克。咱们下期再见

3-【Java面试】请描述你将如何实施蓝绿部署以确保零停机时间？-480P 清晰-AVC

	嗨大家好，我是酷跑科技的联合创始人麦克，在企业界开发中如何避免新版本发布的时候导致停机的问题带来的影响是一个非常重要的机制。今天啊我们将深入探讨一下蓝绿部署，这是一种零停机时间的部署策略。在本期视频的最后，呢我会详细的说明如何轻松的达到这个目标。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享，免费去联系一下。蓝绿部署啊是一种常见的持续部署策略，目的是最小化新版本发布时系统停机的时间，并确保可以快速的安全回滚。在这种模式下通常会有两个相同的环境，一个是蓝色环境，运行当前在生产中的代码，一个是绿色环境，准备运行新版本的代码，面试官通常会问这个问题，来考察求职者三个方面的能力。第一，理解持续部署和持续集成的基本概念。第二，具备使用现代部署策略，确保服务稳定的能力。第三能够有效的规划和执行部署操作，包括回滚计划。下面我们来看一下这个问题的完整回答。
	关于这个问题我的解决思路是首先我会确保有两个完全相同的生产环境，也就是蓝色和绿色环境，然后呢我们可以使用负载均衡或者DNS来控制流量，可以轻易的把用户从一个环境切换了另外一个环境，在绿色环境中部署新版本，并先让一小部分用户访问，已进行实际测试。在新版本上线以后，密切的监控系统表现和各项指标，确保一切运行正常。如果新版本运行比较稳定，就把所有用户的流量都切换到绿色环境中，而一旦发现问题，呢就可以迅速的通过调整负载均衡器的流量切回到蓝色环境，进行回滚。每一次部署以后，及时更新文档，记录这一次部署中所有的关键操作，蓝绿部署呢是一种常见的有效部署策略，但他也需要精心的规划和执行，希望今天的视频能够帮助你更好的理解和应用这个方法。如果你觉得今天的内容对你有帮助，别忘了点赞和分享。我是麦克。我们下期再见。
1-【Java面试】订单表每天新增500W数据，分库分表的方案应该如何设计？-480P 清晰-AVC
	最近啊碰到一个很有意思的题目，题目是这样的，说有一个订单表，每天新增订单数据是500万，在实际的业务场景中存在两个比较多的查询。第一个是根据订单ID去查询订单信息，第二个根据用户ID查询订单列表，请你设计一个可行性比较高的技术方案。Hello大家好，我是孤豹科技的联合创始人麦克，今天我就和大家分享一下这一道问题的回答思路和可行方案，我整理了一份2024年最新的面试，打有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享你一下，有需要的小伙伴可以在我的评论区置顶中去领取。面试官问这个问题的意图啊很明显，就是考察你对分库分表的理解，特别是多增加了两个条件，涉及到多个分辨键查询的问题，给求职者呢设置了一定的困难。更重要的一个点是每天有500万的增量数据，一个月就有1.5个亿，数据库单表支撑1亿数据的快速检索，性能上一定是很差的。因此呢基于这样一些问题，我们可以提出一些比较合理的解决方案。
	要注意的是这种没有任何边界的问题，主要考察的是求职者的思路，解决方案能不能落地不重要。下面我们来看看这个问题的回答思路，这个问题要从两个方面来回答。第一个部分就是分库分表的方案，分库分表这个事情很简单，但是要分多少个表，多少个库，是要做好提前的规划的。由于数据的增量比较大，我们要避免分库分表之后又出现容量满了的情况，或者单表数据量过大的问题。如果这个时候再去做容量扩充，数据迁移和扩容的成本会非常高，一天500万的增量，一年大概有18亿的数据，啊我们按照保留两年的热数据量大概是接近40亿，然后我们做一些空间的预留，算50亿的数据，那我们可以按照32个库，每个库32张表来规划，一共1024张表，每个表里面存放500万数据量，那么就可以满足50亿数据的容量规划。在这个方案中我们可以选择o的ID作为分片键，采用一致性哈希算法来进行路由。在性能层面，假设每个库正常写入的并发量是1000，那32个库可以承载32,000的并发量，如果每个库的血性能再优化到1500，就意味着这个方案能够支持接近5万每秒的血病发，这个已经能够满足大部分互联网公司的并发需求了。
	第二个部分需要考虑的问题，这个方案并不能完整的满足面试官的需求，还有几个问题需要考虑。第一，业务需要根据用户ID查找，而用户ID不是分配件导致查询的时候呢变得很。对于这样一个问题，呢我们可以采用基因算法来确保用户ID对应的订单ID路由到同一个库或者同一个表。在生成订单ID的时候，把用户ID的基因片段拼接到订单ID中，从而保证不管是通过订单ID查询，还是根据用户ID查询，都能路由到同一个表。第二，虽然我们设计了32个库和32个表，但是也只能存储50亿的数据，也就是差不多三年时间，那三年之后这个方案就不满足了，该怎么办呢？其实也很简单，通常订单类的业务，我们频繁访问的数据一般在一年以内，超过一年的数据基本上就不用关心了，所以我们可以设计冷热数据分离的方案，热数据保持一年一年以后的数据迁移到历史库，沥石库也就是冷库只保存两年，超过这个时间的数据直接归档，从而实现1+2的存储方案。除了我上面讲的方案以外，我们还可以采取如今比较主流的HTTP存储方案，比如太DB，喝了DB等等，这类数据库的好处是可以支持在线扩容，比如分片切移，这种扩展对业务完全无感知，同时支持强一致性分布事务的方案，也就是跨分片跨节点的事物一致性，可以跨机房部署，实现跨机房容灾，知识多捡点血路。
	以上就是我对这个问题理解，面试题只能帮助大家在有限的时间内去快速提升应试能力。大家还可以选择像箍炮架过掌心班之类的系统化课程，去提升实际解决问题的能力。如果大家对课程中任何内容有疑惑，可以在我的评论区留言咨询。


4-【Java面试】腾讯一面：Callable和Runnable接口有什么区别？-480P 清晰-AVC

	嗨大家好，我是麦克。有14年加我开发架构经验，现在是酷跑科技的联合创始人，今天来分享一道Java多线程编程中经常会遇到的问题，clip和roundtable接口有什么区别？这个问题看起来很简单，但是呢要回答的关键点以及突出个人优势却有一定的难度。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我们评论区留言求分享，免费去联系一下。当我们谈到Java多线程编程，啊无论是在项目开发中还是面试中，啊 wonderful和call接口经常会被提到，这两个接口都代表了可以被现场执行的任务，但它们有一些重要的区别。明白这两者的区别和各自的适用场景，对我们进行多线程编程非常重要。面试官提出这个问题可能是想要了解你对于Java并发编程的理解程度，以及你是否能够根据不同的需求选择合适的工具。回答这个问题的时候，你不仅要明确指出这两个接口的区别，还要能够去给出实际开发过程中应该如何选择的建议。
	下面我们来看一下这个问题的完整回答。Clip和l的区别主要有三个方面，runnable接口指定了一个无返回值的run方法，而caulome接口呢定了一个有返回值的quir方法，所以如果你的执行任务中需要返回计算结果，那么应该使用call的接口，runnable接口的run方法不会抛出任何检查型异常，而callable接口的kah方法会抛出异常。所以如果你的任务中可能会出现需要处理的异常，那么call up接口将是一个很好的选择。从使用的角度来看，软弱实力通常和three的对象一起使用，而collo接口呢通常与excute servis来配合使用，也做线程池。总的来说如果需要执行一些无需返回结果，且不需要处理检查异常的简单任务，run接口是一个不错的选择，啊如果你需要执行一些更加复杂的任务，需要获取执行结果或者可能抛出的异常，那么应该选择call的接口。以上就是我对这个问题的理解和回答。如果你有任何疑问或者有其他想要了解的编程知识，欢迎在评论区给我留言，我们会在后续的视频中给你解答，如果你觉得今天的内容有用，记得点赞分享给你的朋友们。我是Mike，我们下期再见。
2-【金九银十】解释一下Java的内存模型和happens-before规则？-480P 清晰-AVC
昨天我收到一个工作4年的粉丝的私信，他成功拿到了阿里的offer，然后他把阿里的面试题整理了给我，其中有一个问题是解释一下Java的内存模型和happy before的规则。Hello大家好，我是麦克。有14年的Java开发经验，现在是酷爆科技的联合创始人，今天我就和大家深度的去解析一下这个问题，希望对大家有所帮助，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享，免费去理解一下。Java内存模型，啊也就是GM他主要关注的是多线的环境下，呢如何以安全的方式在主内存和工作内存之间的信息交换。首先我们都知道Java程序是运行在Java虚拟机上的，同时啊我们也知道 gbm是一个跨语言跨平台的实现，也就是red ones。Run anywhere。那么jvm是如何实现在不同平台上都能达到现成安全这样一个目的的。所以这个时候GM这个概念出来了，Java内存模型，也就是Java memory model，是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证Java程序在各种平台下对内存访问都能保证效果一致的机制及规范。
	加我内存模型规定的所有变量都存储在组内存中，每条线程有自己的工作内存，现成的工作内存中保存了这个线程中用到的变量的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写组内存。不同线之间也无法直接访问对方工作内存中的变量，线程之间的变量传输都需要通过主内存进行一个同步，而happy before规则呢是Java内存模型中定义的一种可见性和有性关系的一个模型，他用来描述两个操作的先后执行顺序。面试问问这个问题呢主要是考察你对Java多线程并发控制以及内存模型数据同步等底层原理的理解。他们希望看到的是你对这些复杂概念的深入理解和能够清晰表述的能力，以此来评估你在实际工作中处理并发问题的能力。在回答这个问题的时候，你不仅要能够清晰的解释GM和happy before规则，还应该能够举例说明啊这些概念如何在实际编制中去使用，并解决病房问题。下面我们来看一下这个问题的回答。Java内存模型主要定义了Java虚拟机在计算机内存中的工作方式，GM决定了一个线程对共享变量的写入，何时对另外一个线程可见。
	Havis biffle规则呢它是一个能够帮助我们理解内存可见性和有序性的一个原则。如果操作a happens b4操作b那么a的结果必须对b可见，而a的执行顺序应该在b之前，这规则可以帮我们确保在多线程开发中没有额外的同步的情况下，不会读取到旧的数据，也就是不会产生可见性问题。嗨粉丝before规则有很多，下面我举几个常见的一个规则，第一，程序顺序性规则。在单线程环境中，按照代码的顺序书写在前面的操作，还不是逼迫于书写在后面的操作。第二，同步锁规则，对一个锁的释放一定还不是before于随后对这个锁的枷锁操作。第三one的变量规则，对一个value的变量的写的操作，还不是before于任意后续对这个弯的变量的读的操作。第四传递性规则，如果a happens before b且b happens before CEA，那么 a一定happen before于c以上就是常见的happy before的一个原则。
6-【Java面试】阿里一面：Spring Boot和传统的Spring有什么区别？-480P 清晰-AVC
	Springboard和传统的spring有什么区别？你更倾向于使用哪一个？Hello大家好，我是麦克。有14年的Java开发经验，现在是国宝科技的联合创始人，今天分享的这道面试题呢是针对3年到5年的Java程序员用来考察对生态的理解，面试出现的频率几乎达到了80%以上。很多粉丝遇到这个问题的时候，呢不知道从什么点去切入进行回答。今天呢我就给大家分享一下这个面试衣的考察意图和备货的工作原理，最后呢我会给出一个完整的回答，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我们评论区留言求分享免。我们知道生命的配置非常复杂，导致呢给初学者带来一定的学习难度，同时在企业级开发中也导致食品变得越来越重，而是并不止的出现就是为了解决这个问题的，它采用了约定，由于配置的设计理念，让开发者不需要去编写繁琐的x秒配置文件，使得spring应用的开发变得更加简单。在面试过程中遇到这个问题，啊面试官可能想去从以下几个方面去了解你的能力。
	首先你对spring和simple中的特性和使用经验有多深，其次你是否能够理解并权衡技术选型时的取舍和决策过程。最后你在实际项目开发过程中，是如何根据项目的实际需求去选择使用spring或者实名获得者。下面呢我们看一下这个问题的完整回答。对于spring boat和传统spring的区别，我认为主要体现在以下几个点。首先springboard采用了约定，由于配置这样一个理念，大大简化了spring应用的初期搭建以及后期的维护工作，它提供了大量的这种配置，开发者不需要进行繁琐的xm配置，就可以专注于核心业务的开发。其次此并put内置了他们cat的应用服务器，让项目的部署呢也变得更加方便。同时啊斯宾波特还提供了许多star的组件，方便集成各种长的框架和中间件，比如说GPA ready、sm cue等等。相比之下传统的spring配置更加灵活，可以适应各种复杂项目的需求，但是相应的配置也更加复杂。
	对于我个人而言，啊我更加倾向于使用时间put，因为它能让我更加专注于业务代码编写，而不需要花费大量时间在配置和环境搭建上。以上就是我对这个问题的理解，希望的回答能够对你有所启发，如果你有更多关于家务的问题，记得留言告诉我，我是麦克。我们下期再见。
7-分库分表怎么设计分片,后期如果需要扩张表，如何自定义路由规则-480P 清晰-AVC
	嗨大家好，我是麦克。有14年的Java开发经验，现在是固炮科技的联合创始人，今天我要给大家分享的是一位粉丝在面试一家知名互联网公司的时候遇到的问题，分库分表该怎么设计分片，后期如果需要扩张表，如何自定义路由规则？今天我就给大家分享一下这个问题的回答思路以及这个问题背后的工作原理。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和855万字的就是面试与分析，可以在我的评论区留言求分享，免费去履行一下。这个问题主要考察两个方面的知识，一方面是数据分辨策略的设计，包括分库分表的原则，常用的分辨方法等等。另一个方面是关于数据库的扩容问题，如何在数据增长的过程中去灵活的调整数据的存储和路由规则。数据库分片是大规模高并发、高数据量的互联网公司必须要面对的问题。随着业务的快速增长，单个数据库可能会遭遇到瓶颈，这个时候我们就需要进行分库分表，分不分辨以后，啊数据存储在多个数据库和表中，这时候啊如何去设计分辨策略，使得应用程序能够快速的找到所需要的数据，就显得非常重要。
	另一个方面，随着业务的不断发展和数据量的不断增长，可能需要对数据库进行扩容。扩容以后，原来的路由规则可能不再适用，需要设计新的路由规则，并且需要对原有的数据进行迁移。这一部分内容可能就涉及到一些数据库中间件，比如说my cat鲜的GDP等等。面试官通过这个问题啊主要是想去考察你是否理解数据库分片和扩容的原理，以及你是否具备解决实际问题的能力。下面我们来看一下这个问题的回答。首先啊在设计分库分表的时候，我们需要考虑几个因素，第一，根据业务特性来进行分库分表，比如我们可以根据用户ID来分，也可以根据地理位置来分，也可以根据时间来分，这主要取决于你的业务特性和查询的模式。第二，我们需要选择合适的分辨算法，常见的算法有一致性，哈希取模范围分片等等，我们需要根据业务特性和数据分布的要求来进行选择。第三需要考虑数据和负载均衡，我们希望每个分片上的数据量和访问压力尽可能是均衡的。然后如果后期需要扩容，比如说从原来的8个分片扩容到16个分片，这个时候我们就需要进行数据迁移和路由规则的修改，数据的迁移过程啊需要保证服务的高可用，不能影响线上业务。
	这个时候我们可以使用一些数据库中间件来帮助我们做这个事情。比如说像麦凯的限定GDP等等，至于制定路由规则，其实就是自定分辨策略，大部分的数据库中间件都支持自己分辨策略，只需要实现对应的接口去输入分配件，出对应的分片，就可以实现自定义的略规则。总的来说，设计分片和进行数据库的扩容是一个需要根据业务特性，数据特性以及当前系统状态的综合考虑的一个问题。以上呢就是我对这个问题的一个理解。

8-【Java面试】字节一面：如果业务突然增长10倍，你会如何快速地扩展你的后端服务？-480P 清晰-AVC
	嗨大家好，你有没有想过啊如果有一天你的业务突然暴增10倍，你会怎么做？别担心，今天我们就来详细聊一聊这个话题。这个问题啊经常出现在技术面试中，也是在实际开发过程中可能会遇到的一个问题，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论根据留言求分享免费去领取一下。当业务暴增10倍的时候，快速的扩展后端服务，以提高并发性能成为了非常紧迫的问题，这个问题的复杂性在于如何维持系统的稳定性和高可用性，如何快速的扩展硬件和软件资源，如何在不影响现在用户体验的情况下进行扩展。面试官提出这个问题的主要目的啊是考察你对系统设计可扩展性和高可用性的理解和经验，作为一个开放性的场景题，但在回答的时候呢可以做更多的思维发散。下面我们来看一下这个问题的完整回答思路，对这个问题要快速的支撑超过10倍的流量，最简单的方式就是堆机器，把性能压力较大的服务器快速的进行横向扩容，来分担该节点的流量压力。
	等到流量高峰过去以后，我们再接下来就需要从几个方面去对后端的整个架构进行一个优化。首先进行代码和数据库的性能审查，查看是否有可以优化的地方。其次增加更多的服务器节点，并通过负载均衡分发流量来提高横向扩展的能力。接着从数据库层面对数据库进行分片，并合理的使用缓存来减轻数据库的压力。从应用架构层面来说，我们可以把单一的大型服务拆分成多个小的微幅，用于满足特定的功能和需求。另外对于实时性要求比较低的场景，可以使用消息队列来进行异步处理。如果在云原生的环境下，我们可以在k8s上设置自动扩容和缩容规则，从而让整个系统具备弹性伸缩的能力。同时在扩展之前进行压力测试，并逐渐进行滚动更新，以减少风险。最后建立全面的监控体系，一旦有问题可以立即响应。业务突增啊是每个企业的梦想，对于技术人员来说呢却是一个巨大的挑战。好的架构设计和应急预案是解决这个问题的关键，如果你觉得今天分享的内容对你有所帮助，别忘了点赞和分享。
	我是麦克。我们下期再见。
5-被问麻了！抖音集团一面 限流策略有哪些，滑动窗口算法和令牌桶区别，使用场景？【金九银十】-480P 清晰-AVC
	昨天我收到一个粉丝的私信，他在国内某知名互联网公司面试的时候，啊被问到一系列有关限流策略的问题，包括滑动窗口算法和令牌桶的区别以及他们的使用场景，这个问题对于我们在设计高并发系统的时候是非常关键的。因此今天我就和大家一起深度的解析一下这个问题，希望对大家有所帮助。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享，免费去联系一下。在高并发系统中啊为了防止因为突发流量过大导致系统崩溃，我们通常会使用一些限流算法来控制请求的速率。常见的线路算法主要有固定窗口、滑动窗口、漏桶和令牌桶等等。固定窗口的原理就是对一段固定时间窗口内的请求进行一个计数，如果请求数量超过阈值，就会舍弃这个请求。如果没有达到设定阈值，就直接接受这个请求。滑动窗口算法是在一个固定窗口的基础上，将一个计时窗口分成了若干个小窗口，然后每个小窗口维护一个独立的计数器。
	当请求的时间大于当前窗口最大的时间的时候，则会将计时窗口向前平移一个小窗口，评议的时候会将第一个小窗口的数据丢弃，然后将第二个小窗口设置为第一个小窗口，同时呢在最前面新增一个小窗口，将新的请求放到一个新的小窗口中，同时要保证整个窗口中所有小窗口的请求数量不能超过设定的阈值，肉桶算法的原理也很容易理解，请求来了之后会首先进入到漏桶里面，然后肉桶以恒定的速率将请求流出进行处理，从而去起到一个平滑流量的作用。当请求流量过大的时候，肉桶达到最大容量的时候会溢出，这个时候请求会被丢弃。从系统的角度来看，我们不知道什么时候会有请求来，也不知道请求会以什么样的速率来，这个就给系统的稳定性造成了隐患。但是如果加了一层漏桶算法去限流以后，呢就能够保证请求以恒定的速率来处理。在系统看来，请求永远是以平滑的传输速率过来，从而起到了保护系统的作用。像我们常见的mq，其实就是类似一种漏桶算法的一个实现，另一排种算法是对漏桶算法的一种改进，除了能够起到限流作用以外，还允许一定程度上的流量突发，在令牌桶的算法中存在一个令牌桶，算法中存在一种机制，可以恒定的速率向令牌桶中放入令牌，令牌桶也有一定的容量，如果满了令牌就无法放进去。
	当请求过来的时候，会首先到令牌桶中去拿令牌，如果能够拿到令牌，说明这个请求可以被处理，并消耗拿到的令牌数量。如果另外一种为空，那么这个请求就会被丢弃。不同的线路算法适用的场景也不同，对于平滑性和精准性的要求也不一样。面试官通过这个问题主要是想考察你是否对常见的限流策略有深入的理解，以及你是否能够根据不同的业务场景去选择合适的限流策略。下面我们来看一下这个问题的回答。在日常的项目开发中主要会使用以下几种限流策略。第一固定窗口，它的算法比较简单，但是会有流量的突刺现象。第二滑动窗口，相比固定窗口，它在时间轴上添加了一个滑动效果，可以有效的平滑流量突刺。第三漏桶，肉桶是以固定的速度出水，当水流入的速度过大的时候会直接溢出，可应对突发流量，但无法应对短时间的大流量。第四令牌桶，另一排桶允许一定程度的突发流量，当有大量请求流露的时候，可以使用堆积的令牌去进行应对。我认为滑动窗口算法和另一排种算法的主要区别体现在滑动窗口算法关注的是单位时间内的请求总量，而另100种算法更加关注的是请求的平均速率，令牌桶允许一定程度的突发流量，当令牌重组的时候可以应对短期内的突发流量，而滑动窗口则是对突发流量进行的一个限制，而在选择使用场景的时候，如果系统对流量突刺的容忍度较高，我们可以使用另外一种算法，如果希望流量更加平滑，我们可以选择滑动窗口算法。
	以上就是我对这个问题的理解。如果你有任何问题，或者想要去了解更多面试技巧，记得留言告诉我。
9-【Java面试】当项目出现性能问题时，你通常会采取哪些步骤进行诊断和解决？-480P 清晰-AVC
	Hello大家好，我是麦克。有14年Java开发经验，现在是孤豹科技的联合创始人，昨天收到一个工作5年的粉丝的私信，啊在面试的时候呢被问到一个开放性的问题，当项目出现性能问题的时候，你通常会采取哪些步骤进行诊断和解决？今天我就和大家深度解析一下这个问题，希望对大家呢有所帮助。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和855万字的进入面试与分析，可以在我的评论区留言求分享，免费去联系一下。项目出现性能问题啊是工作中常见的情况，这种问题可能会涉及到多个层面，包括代码优化、数据库优化、系统配置优化等等。面试官提出这个问题，很可能是想看你解决这个问题的思路方法以及你对性能优化的理解程度，这不仅涉及到你的技术功底，还包括你解决问题的能力，这也是我们每个程序员必须要掌握的技能。下面我们来看一下这个问题的完整回答。如果遇到这个问题，呢我会采用以下几个步骤来进行诊断和解决。第一确定问题，我需要明确性能问题的表现，是程序运行响应慢，还是CPU使用率过高等等。
	第二，我要找出瓶颈，我们可以使用一些工具，比如说这块发呀 v秀vm，现在double GC日志分析等等，去分析性能问题出现的原因，找出系统瓶颈。如果是数据库的问题，呢我可能会去检查CK语句，查看执行计划，或者说去分析慢查询日志。第三制定优化方案，找到问题以后呢我会制定针对性的优化方案，可能会包括代码优化，比如优化算法，减少不必要的io操作。数据库优化，比如说修改是一个语句，添加索引，调整数据库配置等等。如果说系统问题啊可能需要调整GM参数或者服务器的硬件升级，执行优化并且验证，在优化方案制定好以后我会进行实施，并且通过对比优化前后的性能测试结果来验证优化方案的效果。第五，持续监控，优化完成以后，呢我还会继续对系统运行情况进行监控，以防止新的性能问题的出现。以上啊就是我对这个问题的理解，希望我的回答对你有所帮助。如果你有更多关于Java的问题，记得留言告诉我我是麦克，我们下期再见。
11-【Java面试】在Spring Boot中，如何自定义Starter？-480P 清晰-AVC
在视频步骤中啊如何去制定star的组件。Hello大家好，我是麦克。有14年的Java从业经验，现在是国宝科技的联合创始人，今天我就和大家深度解析一下这个问题，希望对大家有所帮助。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析可以在我的评论区留言求分享，你可以去复习一下。在视频步骤中啊它的启动依赖是一个非常重要的特性，他提供了第三方组件中being的自动装配机制，依赖包的版本的统一管理以及模块化的方式来实现架包的统一管理的这样一个能力，很好的去帮助开发人员减少了配置项的管理。在视频过程中创建一个制定的是它的组件，可以让我们把一些通用的代码逻辑和自动配置抽离出来，形成一个可以复用的模块，这样在其他项目中就可以直接使用这个 start组件，极大的提高了代码的复用性和开发效率。面试官提出这个问题呢主要是考察你是否理解司令部的它的组件的一个原理和作用，以及你是否有实际编写制定是他的组建的经验，他们希望看到的不仅是你能够清晰的解释它的组件的概念和作用，还希望看到你如何实际操作来创建一个自定义的start，这个需要你具有扎实的是并不的基础知识，同时也需要你具有一定的实践经验。
	所以当你在回答这个问题的时候，啊要尽可能详细的去介绍你是如何创建制定它的组件呢？包括你需要创建哪些类，如何配置这种装配，如何使用这个自定义star的等等。在视频步骤中创建制定是它的主要包括几个步骤，第一创建一个man项目，这个就是我们所谓的star的项目，在这个项目的pop文件中需要引入这两个包。第二在项目中去创建一个自动配置类，自动配置类是springboard自动装配的核心，它可以使用configuration这样一个注解进行标注，并且在类中使用病这个注解来声明，需要自动装配的病。第三创建 spring点factor文件，spring发个文件是spring自动装配的一个关键，这个文件需要放在资源路径的matter in，four目录下，并且把你的自动配置内填写到这个文件里面。第四个如果你的其他的组件需要一些外部化配置属性，那么你可以创建一个配置属性类，并使用configuration property这一个注解来进行标注，最后在其他项目中直接引入你的star的组件就好了。
	那么Super Bowl呢会自动去进行一个配置。以上呢就是我对这个问题的理解，希望我的回答对你有所帮助。如果你有更多关于Java的问题，记得留言告诉我我是麦克，我们下次再见。
10-当场问懵！腾讯一面 什么是单点登录，以及单点登录的实现流程？-480P 清晰-AVC
	嗨大家好，我是麦克。有14年家伙开发架构经验，现在是孤豹科技的联合创始人，昨天一个粉丝在面试的时候呢遇到这样一个问题，什么是单点登录以及单点登录的实现流程？很多人对这个问题的回答呢不是很完整，甚至有些粉丝不明白这个问题的底层原理，正好今天给大家分享一下这个面试题的考察意图和背后的工作原理。最后我会给出一个完整的回答，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享免费去吃一下。单点登录是一种身份验证的解决方案，它允许用户在多个应用之间共享身份信息，也就是说用户只需要登录一次，就可以在多个系统或者应用之间无缝访问，那这大大提高了用户的体验，并且还能提高安全性。面试官提出这个问题的目的啊可能是想去了解你对web安全和身份验证的整体理解，回答这个问题的时候需要阐述sso的基本概念和它的工作原理以及可能的实现方案。下面我们来看一下这个问题的回答。
	在企业的发展初期啊系统设计不多，可能只需要一个系统就可以满足业务的需求，用户呢也只需要用账号密码登录就可以完成验证。但是随着业务迭代的发展，系统架构也会随之迭代，演变越来越多的子系统，用户每进一个系统呢都可能需要登录一次才能进行相关的操作。为了解决这一类问题，就产生了单点登录，也就是在一个多系统共存的环境下，用户只要在任何一个系统登录以后，就不用在其他的系统再次登录，就可以得到其他所有系统的信任。而单点登录是一种身份验证的解决方案，可以让用户通过一次性用户身份认证，登录多个应用程序和网站。Sso的工作流程是这样的，假设用户访问APP系统，APP系统呢需要登录，但这个时候用户假设没有登录，那么系统会触发一个302的重定向请求，转到case server，也就是sso登录系统，sso系统呢发现当前没有登录，就弹出用户登录页，用户只要在这个页面填写用户名和密码，那么sso系统就会进行一个验证，验证以后把登录状态写入到sso的c区里面，浏览器呢也会写入sso，域下的cookie，sso登录系统完成以后会生成一个ST，然后跳转到APP系统，同时把SD作为参数传递给APP系统，ab系统拿到SD以后，呢从后台向SSL发送请求验证ST是否有效，验证通过以后，APP系统把登录状态写入到c型中，并设置APP下的cookie，这样跨域的单点登录就完成了。
	以后我们再次访问AP系统的时候，ab就是一个登陆状态。接下来还需要考虑一个问题，就是如果这个用户访问APP二系统或者APP三系统，那么APP二或者APP三怎么去判断它是一个登陆肽，这个时候就进入了第二个流程，用户访问APP二系统的时候，AP二系统没有登录就会跳转到sso。由于sso在前面已经是登录态了，所以不需要重新登录验证。这个时候sso也会生成一个ST，浏览器会跳转到APP二系统，把ST作为参数传递给APP二，APP二拿到SD以后呢后台访问sso，验证ST是否有效，验证如果成功了，那么APP二就把登录状态写入了c区，并在ab2的域下显露一个cookie，这样AP二系统不需要再走登录流程，就已经是一个登录状态了。Sso，APP和APP2不同的玉，他们之间的c型不共享也没有任何问题。Sso解决方案的具体实现，可能会因为具体的需求和技术站的不同而有所不同。比如os2.0和open ID connect，经常被用作以实现sso的标准协议，单点登录不仅提高了用户体验，还有助于减少密码泄露的风险，了解他的工作机制和实践方式，呢对于任何从事web开发和系统集成的工程师来说，都非常有价值。
	以上就是我对这个问题的理解和回答。如果你有任何疑问或者有其他想要了解的编程知识，欢迎在评论区给我留言，我会在后续的视频中为你解答。如果你觉得今天的内容对你有帮助，记得点赞和分享给你的朋友们，我是麦克，我们下次再见。
12-【Java面试】雪花算法时钟回拨问题怎么解决？-480P 清晰-AVC

	昨天一个工作4年的粉丝去面试，面试官提了一个这样的问题，如何解决雪花算法中时钟回拨问题？他当场愣住了，思考了半天也没有回答上来，遗憾的错过了这样一次机会。嗨大家好，我是酷泡科技的联合创始人麦克，今天我就给大家完整的解析一下这个题目，给你们提供一个更加完善的回答思路和参考，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论根据留言球分享免费去领取一下。在大型的分布式系统中如何生成全局唯一ID是一个非常棘手的问题。Snowflake雪花算法是Twitter开源的一个分布式唯一ID的生成算法，它具有简洁高性能、低延迟，ID按时间趋势有序的特点，得到了广泛的应用。学画算法生成的ID是一个64位的整数，它整体结构是这样的，第一位是一个符号位，始终为零表示正数。第二个，接下来的41位是一个毫秒级别的时间戳，表示从特定时间到现在的毫秒数，41位的时间搓可以表示约69年的时间。
	接下来的10位是用来记录工作机器的ID，可以部署在1024个节点，包括5位的戴德森的ID和5位的worker ID，最后的12位是一个序列号，表示毫秒内的计数，12位的计数顺序号支持每个节点每毫秒产生4096个ID序号。但是雪花算法有一个很大的问题，就是如果服务器的系统时间被调回到了过去，那么就有可能会生成重复的ID。这就是这个面试题关注的雪花算法的时钟回拨问题。面试官通过这个问题可能想要去考察你对分布的系统，时间同步技术和ID生成算法的理解，以及你在面对实际问题的时候，能否提出有效的解决方案，理解这个问题的背后原理，会让你的回答更有信心和清晰。下面我们来看一下这个问题的回答，这个问题呢有几种解决思路，第一异常处理，当检测到时钟回拨的时候，可以抛出异常，停止ID的生成，等时间恢复以后再继续生存。但是这种方法会暂停，ID生成的服务也会影响系统的可用性。第二，等待时间恢复，当检测到时钟回拨的时候，可以选择让县城睡眠等待，直到时间恢复，生成备用ID。
	当检测到时钟会播的时候，可以选择生成备用的ID，比如说使用随机数或者其他方式，但是这种方式需要额外的机制来保证it的唯一性。第四多时钟法，既然系统已经发现了时间回拨，那我就认为原先的时钟已经不可用了，我们可以用一个新的时钟，并且把新的当前时间认为是新的时钟时间。总的来说解决雪花算法的使用回拨问题，呢需要我们去根据具体的系统需求和环境来选择最合适的策略。以上就是我对这个问题的理解和解答。如果想要学习更多知识和技能，也欢迎大家来酷跑云课堂去观看我的直播分享课。每晚8点我都会在这个平台解析技术要点，分享职场干货，并且通过大量的案例去培养架构思维，帮助大家更容易的去实现程序那架构师的一个跨越。感兴趣的小伙伴可以在评论区抠视听，获取课程路径。今天的视频就分享到这里，感谢大家的观看，我们下期再见。

13-【金九银十】请说一下MySQL索引失效场景？-480P 清晰-AVC
	嗨大家好，我是麦克。一个拥有14年从业经验的Java架构师，也是菇泡教育的联合创始人。前几天有一位粉丝去一家顶级互联网公司面试，被问到Michael索引失效的场景这个问题，他当时觉得自己胜券在握，但没有想到这一波还是没有通过面试。这个问题看起来很简单，其实呢却非常考验我们对max口运行机制的理解，今天我就给大家深度解析一下这个问题。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享，免费去履行一下，有需要的小伴可以在我的评论区的置顶中去免费领取。麦c口的索引是我们提高查询效率的重要工具，Maxey中采用了bea加速作为索引结构来减少磁盘io次数，去提高数据的检索性能。但是在某些场景下，由于查询语句设计不合理，或者对麦西口的理解不够深入，所以呢有可能会失效。这个时候我们的查询语句就会变成一个全标扫描，这对于大数据量的数据库来说是一个非常低效的了解这些索引的失效场景，能够帮助我们更好的利用索引去提高c口的查询效率。
	因此这个问题主要考察的是面试者是否对麦西口有深入的理解，以及在实际开发中是否能够正确的使用索引。下面我们来看一下这个问题的回答。在卖c口中索引失效的场景有以下几种，第一，在while语句中使用一些逻辑操作服务，比如说not in或者不等于这样的一些操作，因为这些操作会导致MAC无法进行索引查找。第二，对索引字段进行计算或者函数操作。比如说我们对一个日期字段做一个一页函数的操作，那么卖c狗就无法使用索引。第三，使用那个操作符进行模糊查询的时候，如果通配符在前面，那么就会导致索引失效。因为麦c口无法去确定查找的起始点。第四，如果max口估计全表扫描比索引速度更快，那么他会选择全表扫描，比如数据量小或者大部分行都满足where子句的时候。第五个在复合索引中，如果没有按照索引最左前缀的顺序来查询，那么也可能会导致索引失效，避免这些场景所有事件的场景，能够帮助我们更好的利用索引提高c口查询效率。以上呢就是我对这个问题的理解。
	如果想要学习更多知识和技能，也欢迎大家来酷跑云课堂去观看我的直播分享课。每晚8点我都会在这个平台解析技术要点，分享职场干货，并且通过大量的案例去培养架构思维，帮助大家更容易的去实现程序员到架构师的一个跨越。感兴趣的小伙伴可以在评论区抠视听，获取课程路径。今天的视频就分享到这里，感谢大家的观看，我们下期再见。
14-【金九银十】Redis持久化AOF和RDB区别，分别解决什么场景问题？-480P 清晰-AVC
	昨天在我的粉丝群里面有一个工作三年的粉丝去面试，被问到readus句话的aof和RGB的区别，以及分别解决什么样的场景问题，他不知道从哪个地方开始去总结，导致回答过程很混乱，所以呢他希望我能够给他梳理一下这道题的逻辑。嗨大家好，我是酷爆科技的联合创始人麦克，今天我就给大家一起分享一下这个问题的原理和回答思路。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享，免费去领取一下。大家都知道啊 radius是一款非常流行的内存数据库，它的性能非常高，但是数据是存储在内存中的，这就意味着如果服务器宕机了，数据有可能会丢失。为了解决这个问题，呢瑞利斯提供了两种持续化策略，are DB和lf啊 DB持久化是指在指定的时间间隔内，把内存中的数据集快照写入到磁盘，也就是只保留某个时间点的数据，它的实际操作过程是 fork一个紫禁城，先把数据集写入到了一个临时文件，写入成功以后再替换之前的文件，用二进制进行压缩存储。
	而aof句话会记录服务器接收的所有写操作命令，并且把这些命令追加到一个文件里面，持久化到磁盘上。在服务器启动的时候，通过重新执行这些命令来还原数据。面试官通过这个问题啊是想考察你对于release持续化机制的理解程度，以及你对不同的持续化策略，在实际应用中的选择和优化，这对一个后端开发者来说非常重要。因为只有深入地理解了这些，才能更好地利用readus更有效的去保证数据的安全性和一致性。下面我们来看一下这个问题的回答。啊 Db职业化和aof画有各自的优缺点，适用于不同的场景，are DB的优点是恢复大数据集的速度要比aof快，对CPU和内存的影响比较小，它更加适用于需要做冷备份，或者对数据恢复要求不是特别高的场景，因为它是间隔一段时间继续持续化，如果在这个时间段内release发生宕机，那么这些数据就会被丢失。Elf的优点是更加稳定，数据的完整性更好，因为它记录了每一个写操作，但是随着数据的增加，lf的文件会越来越大，可能会影响到ready的性能，因此啊 aof更加适用于对数据安全性要求较高的场景，比如购物车、订单等关键业务。
	同时在实际应用中也可以同时开启rdb和AOL进行持续化，以便结合两者的优点，具体采用哪种持久化策略，需要根据业务需求和系统环境进行权衡。至于如何优化aof直接画，威利斯提供了几种策略，比如每秒同步一次，每修改一次数据就同步一次或者不同步，我们可以根据实际业务的性能和数据安全性需求进行一个选择。以上就是我对这个问题的理解。如果想要学习更多知识和技能，也欢迎大家来酷跑云课堂去观看我的直播分享课。每晚8点我都会在这个平台解析技术要点，分享职场干货，并且通过大量的案例去培养架构思维，帮助大家更容易的去实现程序员的架构师的一个跨越。感兴趣的小伙伴可以在评论区抠视听，获取课程路径。今天的视频就分享到这里，感谢大家的观看，我们下期再见。
19-【金九银十】Java程序员背它！这套面试作弊SOP，绝对算捷进！-480P 清晰-AVC
	10次面试9次，过工资都还不低，全靠这套面试做sop，今天分享的全是干货，记得收藏起来以后一定用得上。首先面试一共6个环节，绿色环节有题库，橙色环节有满分，思路评论区分享打包带走。我们先从必问的项目，今天开始找两个和岗位要求相关，你认为最有亮点的项目，套用我的思路提前准备好故事就行。需要重点包装的模块老规矩标红了，接下来是场景题，52万字的面试题我也整理好了，最新结合技术场景题，满分回答思路请直接背诵，再到通用问题，百分百命中的问题我也整理好了。方法直接套用，接下来是反问环节，这里有进阶问法，可以体现你抓核心的能力，还能帮你套出面试反馈的重要信息，提高面试官的认可度，然后是技术问题，这里也有题库，但因为每个岗位不一样，需要你自己做功课，功课方法也很简单，只需要一个小时，您经验也能成为面试高手，首先提取激励关键字把和技能相关的词圈出来，就是我们要提前准备的知识，像这份洁丁就需要准备double ready是mq的技术，然后走捷径的方法找一个1~5年以上经验的朋友约他一个小时喝咖啡把关键词丢给他，让他直接把方法讲给你，如果没有合适的朋友也可以私聊我。
	一位辅导我的学员已经拿到了好几个大of，你只需要提问录音整理背诵高手的经验，立刻变成你的最后自我介绍，其实很多人忽略了这个环节的重要性，这里你给面试官的第一印象甚至可以直接决定面试结果，面试的过程就是不断考察4个点，所以满分自我介绍就是打直球，直接把面试官想听到的答案说出来，我的方法拿走，记得准备1分钟3分钟2个版本。最后我想说心态上别怕麻烦，花一两周准备多拿几个offer多值，啊也别觉得自己不行，既能知道就是会经验沾边，就是有程序员找工作没有那么难，按照我的方法准备见到面试官勇敢，眼神沟通自信表达，相信吸引力法则，你一定能够拿到offer，别忘了评论区领取一部送面试。
16-【Java面试】一个定时任务，执行周期很长，如何做到优雅启停？ 金九银十！-480P 清晰-AVC
	如何在执行周期长的定时任务中去实现优雅的启停。这个问题是一个粉丝在一家知名互联网公司面试的时候遇到的，当时他绞尽脑汁想了半天才回答上来，但是回家以后越想越觉得不对劲，所以希望我能够说一下我对这个问题的理解。嗨大家好，我是哭泡教育的联合创始人，拥有14年Java开发经验的麦克，这是一个在我们设计系统，尤其是在需要处理大量长时间任务系统的时候，需要特别关注的问题。所以今天我就和大家深度的去解析一下这个问题，希望对大家有所帮助。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享，免费去复习一下。在生产环境中我们经常会遇到一些长周期任务的情况，比如说数据分析、日志处理等等，这些任务通常需要持续运行很长一段时间才能完成。当我们需要对这些系统进行升级或者维护的时候，如何去确保正在执行的任务能够正常完成，同时新的任务在适当的时候开始执行，这就是优雅挺起要解决的问题。
	优雅启停主要意味着在服务需要停止的时候，能够确保已经开始任务能够完成，新的任务不会被启动，以及所有的资源能够正常的被释放。这不仅仅需要对并发控制、任务调度、资源管理有深入的理解，还需要考虑到系统的健壮性、稳定性和可维护性。通过这个问题，面试官想要考察的是你对于复杂系统运维的理解和应对能力，你是否考虑到执行长时间任务可能会遇到的各种问题，并能提供合理的解决方案？这不仅仅是技术能力的考察，也是对你问题解决能力和项目管理能力的考察。下面我们来看一下这个问题的回答。解决这个问题的方法有很多，最简单的方式就是使用标记来控制任务的启动和停止。我们可以定义一个全局标记，并且把这个标记呢存储在环境变量或者分布式配置中心上，并设置为启动状态的初始值，然后在定时任务执行体中读取到这个标记，根据这个标记的执行状态来决定是否要停止。在需要停止服务的时候，我们直接把这个标记置为停止，然后再启动新的任务的时候，呢检查这个标记如果标记为停止则不启动新的任务。
	从另外一个角度来说，啊如果定时任务还在执行中，没有办法去获取到标记状态的时候，我们需要保证这个任务执行的完整性，也就是避免中途被中断，造成数据不完整的问题。因此我认为还可以使用锁或者其他同步工具来等待任务完成。比如说我们可以使用盘子当lunch，赛克戴瑞cell phone等工具来等待所有任务的完成。当所有的任务完成以后，我们可以安全的停止服务，或者我们可以直接继承aks来去实现一个锁的标记，通过这个标记来判断当前是否能够停止这个服务。以上就是我对这个问题理解，如果你有任何问题或者想要了解更多面试技巧，记得留言告诉我。
17-【Java面试】秋招面试：线程池中的工作线程出现异常怎么办？-480P 清晰-AVC
	县城池镇的工作县城出现异常应该怎么办？这个呢是一个工作三年的粉丝在蚂蚁金服二面的时候被问到的一个问题。他当时就这个问题没有回答上来，导致这个面试没有通过，今天我就给大家分享一下这道问题的回答思路，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我们评论区留言求分享免费一下，有需要的小伙伴可以在我的评论区置顶中去领取。这个问题问的比较巧，如果对仙人池的实现源码不熟悉的同学不一定能够回答出来，面试官通过这个问题可以考察求职者对于县城市使用过程中的异常处理能力。县城执行任务出现异常是一个非常常见的情况，求职者在编写代码的时候是否会考虑到异常问题，并做出应对策略，处理现实中的异常，需要对Java多线程有深度的了解，包括现成的生命周期，异常的传播方式，以及如何优雅的终止一个线程。下面我们来看一下这个问题的完整回答。在Java中，县城池的工作线出现异常的时候，末日会把异常往外跑，同时这个工作线程会因为异常而销毁，我们需要自己去处理对应的异常。
	异常处理方法呢有几种，第一，在传递任务中去处理异常，对于每个提交到现实中的执行的任务，可以提前通过异常进行补。这样即便是出现异常，也不会影响现任池这种工作线程。第二，使用future来获取异常结果，在现实中提供了一个杀猪妹的方法，这个方法呢会返回一个future，我们可以通过调用future点get的方法来获取任务的结果。如果任务执行过程中出现异常，也会抛出一个xq选x选，其中包含了任务执行过程中的时间异常。第三，我们可以制定一个three的factory，设置一个叫Ann cage，XP、黑豆，我们可以通过实现所有的factory的接口来自定义创建线程的方式，然后为每个新创建的县城设置一个on Coach一个c圈很多，这个处理器会在县城由于未捕获异常而即将终止的时候被调用。以上呢就是我对这个问题的理解。刷面试题只能帮助大家在有限的时间内去快速提升应试能力。但是有可能在面试过程中，我们准备的问题面试官没有问到，我们没有准备的问题，面试官正好问到了，所以我们要尽可能的去把技术的体系化做一个深度的梳理，然后再结合面试文档进行一个整体的梳理，从而确保自己一定能够通过当前的面试，对于Java技术的系统化梳理，大家可以选择酷跑科技的架构，掌心班课程，去提升解决问题的能力。如果大家对课程中的任何内容有疑惑，也可以在我的评论区去留言咨询。

21-【Java面试】金九银十必刷：什么是SPI，它有什么用？-480P 清晰-AVC
	昨天下午我收到一个粉丝的私信，他问我spi是什么？它有什么作用？她说啊在读了一些开源项目的代码后，他发现很多地方都使用了spa，但是他对SP的概念不是很清楚，这个问题让我想到作为Java开发者，我们真的理解spi吗？在面试场景中我们应该如何去回答这个问题呢？Hello大家好，我是酷跑科技的联合创始人麦克，今天给大家分享一下这个问题的回答思路。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享，免费去履行一下。Sp I全称是serviceprovider interface，翻译过来就是服务提供者接口，这 Java提供的一套用于被第三方实现或者扩展的API，它可以用于向现有的Java内部中添加第三方提供的功能，或者改变现有的内裤的行为，加入s片的核心思想就是面向接口的编程，以插件的方式动态替换或者添加新的实现增加程序的灵活性。在Java中，spa的实现主要是通过Java点用特点servis lode类来完成的，当我们调用servis lode的方法的方法的时候，他会查找matter in for杠service目录下的配置文件，这个配置文件的名称就是接口的全名，文件中的每一行就是接口的实现类的全名，service load会把这些时间内加载到gpm中，并且在需要的时候时间画出来。
	面试官通过这个问题啊可能想去了解你对于Java里面的扩展机制的理解程度，以及你是否在实际开发过程中使用spi进行功能扩展的经验。下面呢我们看一下这个问题的完整回答。Sp I它是GD内置的一种动态扩展的实现，简单来说，就是我们可以定一个标准接口，然后第三方库里面可以去实现这个接口。那么程序在运行的时候，会根据配置信息动态加载第三方实现的类，从而去完成功能的动态扩展机制。在Java里面，spa机制呢有一个非常典型的实现案例，就是数据库驱动，Java点GPS点Java，gdk里面定义了数据库驱动类，Java它是一个接口，具体的实现呢是由第三方数据库厂商来完成的，在程序运行的时候会根据我们声明的驱动类型来动态加载对应的扩展实现，从而去完成数据库的连接。除此之外，呢在很多开源框架里面都有借鉴加入spa的思想，提供了自己的spa框架，比如dubl里面定义了extension lode去实现动态扩展机制，实况中提供了10分fashion show等，它去实现了外部功能的集成。
	以上就是我对spa的理解。最后我想跟大家强调一下，面试题只是用来做面试突击的，不能用来作为系统学习的资料，想要提升硬技能，还是要选择我们的大课进行学习。今天的视频就分享到这里，如果你想要去了解我们的课程，可以在我的评论区去留言咨询。
20-【Java面试】金九银十必刷：使用一个不可变对象作为key，红黑树怎么比较大小？-480P 清晰-AVC
	昨天有个粉丝在我的群里面问了一个他在平安银行二面遇到的问题，如果我们在Java中使用一个不可变的对象作为k比如string，那么在红黑树中我们应该怎么去比较大小呢？当他把这个问题发出来以后，瞬间引起了群里面很多的讨论，因为这个问题看起来简单，但是背后呢却涉及到Java集合红黑数不可变对象等多个概念的理。嗨大家好，我是酷爆科技的联合创始人麦，今天我就给大家分享一下这个问题的回答，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论根据留言球分享免费去领取一下。回答这个问题之前，呢首先我们需要明确一个概念，在加我的集合类中，比如说去卖或者去sat，它们内部都是使用的红黑素来存储元素的。在红黑树中为了维持树的平衡性，采用了左旋和右旋的方式来实现节点的重平衡。而左旋和右旋又依赖于节点的大小的比较，也就是满足二叉查找术的基本条件。对于使用不可变对象作为key的问题，我们需要知道这并不影响我们比较大小，因为比较大小是通过调用对象的compare to方法来实现的，而这个方法的实现并不依赖对象本身是否可以改变，因此呢面试官通过这个问题可能是想去了解你对Java集合类不可变对象以及红黑素的理解，看你是否能够正确分析和处理这种情况。
	下面我们来看一下这个问题的回答，对于使用不可变对象作为k的问题啊实际上是可以的，因为比较key的大小并不依赖于k本身是否具有可变性，而是依赖于k实现的比较大小的方法。在Java中，如果我们想要把一个对象作为Kae存储再去卖或者去sett这样的一个有序结合中，那么这个对象必须要实现compatible这个接口并重写compared方法，这个方法就是用来比较两个对象大小的，比如实训这个类就实现了comparable这个接口，所以我们可以用4G作为k而在红黑树中，节点之间的大小关系是通过调用quay的compare compared方法来确定的。如果我们把一个对象作为key存入到红霉素，那么在插入或者查找的过程中，会不断的调用computer方法来比较节点的大小，以此来维护树的平衡。所以无论PEA是否是不可变的，只要他实现了compared方法，就可以作为红黑素的t在我看来不可变性主要是为了确保在key被用来查找的过程中，它的值是稳定的，不会出现因为key的值变化导致查找失败的问题。
	以上就是我对这个问题的理解。如果想要学习更多知识和技能，也欢迎大家来酷跑云课堂去观看我的直播分享课。每晚8点我都会在这个平台解析技术要点，分享职场干货，并且通过大量的案例去培养架构思维，帮助大家更容易的去实现程序员的架构师的一个跨越。感兴趣的小伙伴可以在评论区抠视听，获取课程路径。今天的视频就分享到这里，感谢大家的观看，我们下期再见。

18-还在被洗脑？转行学Java，4年工作经验，现如今到底怎么样？【Java面试】-480P 清晰-AVC
	我是啊全日制大专学历，然后有个开放大学的本科啊是转行做Java的，今年已经29了，已经有4年这样子的工作经验。转行Java到底推不推荐？看看这位老哥就知道了。喂你好。啊喂你好，麦老师听得到吗？听得到。啊你好，啊我先说一下我的情况。吧这样子我是啊全日制大专学历，然后有个开放大学的本科嗯啊是转行做Java的，今年已经29了，已经有4年这样子的工作经验。嗯然后今年2月份呢从上家上家公司离职之后，呃到现在将近两个月时间都没有找到工作，所以就有点迷茫，是不是？说我们这样子说学历的问题说一嗯这行可能走没办法走下去了。你你我理解你投投了以后完全没有。噢对，完全没有面试邀约。
	没有外包，只有两个外包的邀约。那两个外包你去。开发的岗。就应该偏向管理，那个就没有去，另外一个外包是没有过。嗯然后昨天啊面试了一个是同事内推的一个一个公司，然后拿到offer了，但是属于降薪入职，所以心里有点啊心心有不甘，所以唉再犹豫要不要去。噢目前上一家公司的话是拿到13k这样子，然后这一家公司是给12k。我准备了一份秋招高频场景题与一份大厂进阶学习路线图，200家精选简历模板，需要的小伙伴评论区一键领取。噢你你现在在哪个城市来着？我忘忘记了。在广州。广州。广州怎么说？呢就现在找工作，又做很多准备工作。呃比如说你的简历的优化，嗯简历优化之后，其实你是能够去获得很好的一个比如说我们是为了去获得面试机会，那我的优化层面上我怎么去做，包装怎么去做这个事情，确实要做的。然后第二个我有了面试机会或怎么通过面试，现在的整个大环境，就是就是这样的就是你你不去就会有人去市场的招ping需求，实际上是远远小于市场供应的程序员的需求的。
	我在我自己在boss手机那岗位我现在每天能够收到很多offer，噢也不是噢不是说错了，很多的简历，然后横向比较以后，你会发现一个岗位能够每天有20分到30封简历。什么概念？所以这里面就想相当于就是企业有更多的选择。所以同时对于客个人端来说也难确实很难。所以这个时候如果你有一份工作，先干着，未来会好一点，但不要有过大的一个期待，未来会好一点。啊再想了解一下。就是因为拿到offer那家公司它还是属于一个单体架构，嘛是没有微微服务一个架构的。我在想如果是继续做单体架构的一个方面的话，会会会对往后的。就不建议去了。如果这样的话我不愿意去，我觉得你还可以去找一下。你你这种情况我我现在从1月份开始我就一我现在这边一一直到现在接接了160个人。就是从1月份开始，因为我们在不是有个斑，嘛就接了一现在只有1160个。那现在已经解决了多少个呢？大概还有40个没有解决，还解决120个。有送外卖的就不在广州跑外卖的。
	还有就是空挡了，比如说大专学历空了一空窗一年的在深圳的，呃也有在很多去做。对，就是两三年经验的就有很多这样的一一个情况。就这这些我们都都已经搞定了。所以在这里面呢就是如果你知道怎么去如果你不知道。对你们可以去找一下那个助教去了解一下。这个事情是就原来你的简历可以但现在你要变得很专业，就大概这个意思。好了解。也很难确实很难，我我每天收到的我没觉得很多都是这样的。我每天要你知道我每天包括还有一个学员，现在我还在给他投简历，今天晚上我我是正好刚给他在那个这个前程无忧上投了简历，才帮他把简历优化，投了简历没有办法。现在就是这样一个情况。但是难归难，但是嗯没不是不是完全没有出。好好的好的了解了解嗯行。嗯拜拜嗯拜拜。叮叮叮。这个视频这三年大家觉得合不合适？合适的不得了得了。
23-【金九银十】Java程序员抄这个简历模板 面试接到手软，和十个大厂hr聊过之后，才拿到的Java满分简历秘籍！-480P 清晰-AVC
	和10个大厂hr聊过之后才拿到的Java满分简历秘籍，原来这才是他们最喜欢的简历，前前后后花了1个月时间整理，不管是初中高级开发工程师还是8年以上的架构师，照抄我的简力模板，让hr疯狂邀约你简历，一共分4个部分，要点b坑和具体写法，今天都交给你，还有简历自查和大场面试流程，评论区求分享打包全部带走，找工作必定能用得上。首先是工作经历，这是最重要的模块，工作经历倒序排列3年5年8年不同年鉴简历模板已经整理好了，方法直接套用，这里有4个要点，第一精力写清楚岗位和项目经验，第二内容拆解要有框架，可以按照我的方法写，突出自己的综合素质和能力。第三要有故事细节，避免只写通用方法，让面试官有记忆点。第四删掉废话极简表达，实在不会写也没有关系，直接来找我帮你梳理项目亮点，分析目标岗位的基地，写出有竞争力的简历。其次是专业技能这个模块，让hr一眼看出匹配度正确的写法，超级低，把岗位要求和自我优势匹配，按照技术在专业领域行业经验、软实力、经验4个点进行归纳，并且用独特亮点作为钩子。像这份简历标红部分详细有特点，抓人眼球，hr首先会锁定你接下来是个人资料、姓名、电话、邮箱、求职岗位必放，央企要放政治面貌，外企别放照片，星座兴趣千万别放，接着教育背景，学校好的放前面，不好的放后面，课程不需要放，有专业学历时间就行，挑1~2个你有的亮点，证明自己持续优秀，最后分享简历自查方法，用极简模板步喧宾夺主，简历不要超过两页，注重细节，避免错别字，只发PDF，保持排版正确，还有不同大厂的面试流程，都在评论区，别忘了求分享，免费领取面试，接到手软。
24-【Java面试】秋招面试必刷：为什么要使用Spring框架？-480P 清晰-AVC
	一个工作了4年的小伙伴，用了6年时间的spring框架，自认为呢对spring很精通，结果面试官问他为什么要使使用视频框架？他之前没有想过这个问题，导致呢这个问题没有回答好。Hello大家好，我是孤豹科技的联合创始人麦克，今天给大家分享一下这个面试题的正确回答思路，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我们评论区留言求分享点。任何一个技术框架一定是为了解决某些特定问题的，只是呢大家忽视了这个点，为什么要用？再往高一点来说，其实就是技术选型。能回答这个问题，意味着面对业务场景或者技术问题的解决方案上，会有自己的见解和思考。回答这个问题的时候，呢大家可以讲一下three框架的核心特性，然后呢可以谈一谈在实际项目中如何使用spring，包括你是如何利用食品特性来解决问题的，以及呢你在使用过程中遇到了哪些问题，又是如何解决的。下面呢我们看一下高手的回答。
	Spring呢是一个轻量级的业务框架，它提供了IOC和ALP两个核心功能，它的核心目的啊是为了简化企业级应用程序的开发，使得开发者只需要关心业务需求，不需要关心病的管理，以及通过切面增强的功能来减少代码的侵入性。从spring本身的特性来看，我认为有几个关键点是我们选择spring框架的原因。第一是轻量级，spring呢是一个轻量级框架，它的基本版本大约是两兆。第二IOC和di spring通过IOC容器来实现bean的生命周期的管理，以及通过DNA来实现依赖注入，从而实现了对象依赖的松藕和管理。第三，面向切面编程aop，spring呢只是面向切面编程，从而把应用业务逻辑和系统服务分开。第四，mvc框架，SPIE mvc提供了功能更加强大且更加灵活的外部框架支持。第五，事务管理，Spreen通过ALP实现了事务的统一管理，对应用开发中的事务处理提供了非常灵活的支持。最后啊 spring从第一个版本发布到现在，它的整个生态已经非常庞大了，在业务开发领域，啊 spring生态几乎提供了非常完善的知识，更重要的是社区的活跃度和技术成熟度都非常高。
	以上呢就是我对这个问题的理解。面试题主要是解决大家求职需求的，是为了帮助你们在短期内通过冲刺达的目标，所以如果你们想去提升自己的硬技能，建议还是可以选择报名菇泡的架构掌心班去进行系统化学习。好了，今天的视频呢就到这里，如果你想要去了解我们的课程，可以在评论区留言咨询。
22-【Java面试】九月秋招必刷：TCP协议为什么要设计三次握手-480P 清晰-AVC
	今年的面试也太难了，一个工作三年的程序员竟然要问TCP协议为什么要设计三次握手？我写了三年的ciod根本就不需要用到网络编程了。Hello大家好，我是酷跑科技的联合创始人麦克，今天呢给大家分享一下这个面试题的正确回答思路，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论根据留言球分享免费去补习一下。传输协议啊通常有TCP和udp两种，TCP是面向连接的协议，在收发数据前呢必须要和对方建立可靠的连接，建立连接的三次握手，段凯连接了4次挥手，为数据传输打下1个可靠的基础。Udp是一个面向无连接的协议，数据输出前源端和终端不建立连接，发送端尽可能快的把数据扔到网络上，接收端从消息队列中读取消息段，恰恰是这两种协议的差异性，导致了TCP协议多了很多确认连接的步骤，也就是这个面试问题的考察背景。网络通信协议这块的内容还是比较重要的。面对一些线上网络故障排查的时候，可以快速的去帮助我们定位问题，并找到解决办法，特别是在分布式架构中，网络通信已经变成了一个很重要的基础设施，所以网络这一块的知识点大家还是需要做一些准备的。
	下面我们来看一下这个问题的高手回答。关于这个问题呢我会从三个方面来回答。第一，TCP协议它是一种可靠的基于字节流的面向连接的传输协议，它的可靠性体现在TCP协议通信的双方的数据传输是稳定的，即便是在网络不好的情况下，TCP都能保证数据传输到目标端，而这个可靠性是基于数据包的确认机制来实现的。其次，TCP协议双方的数据传输是通过字节流来实现传输的，最后这里面说的面向连接是说数据传输之前啊必须要建立一个连接，然后基于这个连接进行数据传输。第二个点，因为TCP是面向连接协议，所以在进行数据通信之前呢需要建立一个可靠的连接，TCP采用了三次握手的方式来实现连接的建立。所谓的三次握手呢就是通讯双方一共需要发送三次请求，才能确保这个连接的建立。具体是客户端向服务端发送连接请求，并携带同步序列号syn服务端收到请求以后，发送s1和ack。这里的s1表示的是服务端的同步序列号，ack呢表示对前面收到请求的一个确认，表示告诉客户端我收到了你的请求。
	客户呢收到服务端请求以后，再次发送ack。这个 Ack是针对服务端连接的一个确认，表示告诉服务端我收到了你的请求。之所以TCL设计三次握手，我认为有三个方面的原因。第一，TCP是一个可靠性通信协议，所以TCP协议的通信双方都必须要维护一个序列号，去标记已经发送出去的数据包，哪些是已经被对方签收的，而三次握手就是通信双方相互告知序列号的一个起始值，为了确保这个序列号被收到，所以双方都需要一个确认的动作。第二，TCP协议需要在一个不可靠的网络环境上去实现可靠数据传输，意味着通信双方必须要通过某种手段来实现一个可靠的数据传输通道，而三次通信是建立这样一个通道的最小值，当然还可以4次5次，只是没有必要去浪费这个资源。第三，防止历史重复连接初始化造成混乱问题。比如说网络比较差的情况下，客户端连续多次发送建立连接的请求，假设只有两次握手，那么服务端只能选择接受这个连接，但是服务端并不知道这次请求是不是之前因为网络堵塞过期的请求，也就是说服务端不知道当前客户端的连接是有效还是无效。
	以上呢就是我对这个问题的理解。最后我想跟大家强调一下，面试题只是用来做面试突击的，不能用来作为系统学习的资料，而且单纯通过刷面食仪找到工作，这个工作也一定不符合你职业发展的一个提升需求。所以如果你是对自己的职业发展是有预期的，我建议大家系统化的去学习一下我们的菇泡架构师掌心般的一个课程。今天的视频就分享到这里，如果你想去了解我们的课程，可以在评论区留言咨询。
15-不想35岁被裁必看！程序员如何构建架构思维，形成自己核心竞争力？【IT职场】-480P 清晰-AVC
	从宏观层面的角度来去构建架构思维。那么宏观层面理解的架构思维跟我们的架构有什么区别？我前面给大家讲到软件的发展是从有序到无序的，那我们架构师要做的就是怎么样去让这个无序变成有序，我们需要一个干预。所以我们在整个过程中，架构师需要做很多事情，它不是仅仅是技术，但技术又是很核心的能力，但是你不仅仅只是依赖技术，你还需要有很多的经验的沉淀，需要有管理能力，还有沟通能力，业务能力这些东西都需要能力，但是单纯从软件层面来说，我们要去思考的是说软件架构或者说我们的这个业务架构，架构师怎么样去构建这样一个能力，或者架构师应该具备哪一方面的思考？我们说老板要你做个电子系统，如果你是公司的架构师，如果你是公司的CTO，你是公司的技术总监，你怎么做？你一定是有一套方法论。这个方法论很重要，因为你们很多时候一上来就写接口，很多东西别人都已做好了，所以大家会觉得自己没什么成长，那实际上你们发现公司里面有很多机会是可以成长的，至少说公司里面如果架构师你可以去跟着他模仿，所以这里面你需要有一个方法论。
	这方面就是你要知道一个软件架构到最终落地中间会有很多过程，这个过程有很多部分是你需要参与的。所以在整个的设计过程中，啊我们要去知道宏观层面东西到微观这两个部分是一个很重要的能力，就是我们一定要能够从宏观理解架构到微观理解技术。因为宏观层面架构设计好之后，我们的微观层面需要去开始去进行落地的时候，你要有对应的能力。所以在这个层面来说，每一个人都需要建立这样一个思维，即便你是刚工作，这个思维，在这个领域行业内不管接下来未来的行情怎么变化，你都能够去获得很有利的竞争力。因为这个能力并不是每个人都有，因为我们其实太有局限性了，局限在哪里面，我们很多时候是在这个层面。这么多年我接触的很多同学遇到过这个问题，就是我能够写业务代码，我能够很快去完成交互，但是我就是会遇到一个问题，就是我觉得我在做一些重复工作，我觉得重复工作对我来说没什么成长，但是我想跟大家讲就是你一定要跳出来，你不要把你的眼界局限在这。我之前从开发总的架构师最大的一个特点是什么？就是跳出来站在宏观视角去看问题。
	所以很多时候我们说成为架构这个事情，它不是靠你们在这个点，我没有经验，为什么不能没有经验的人就不能成为架构师，谁是从一开始就有经验的呢？不是，我们所有的经验是怎么来的，就是你现在这个公司里面的项目，这个项目你是不是理解了？我问过面试过无数的人，我问这个项目的宏观的一个理解，很多人不知道，所以你的视野太局限了，就是我跑过去面试老师我什么都会，结果一问啥都不知道。除了我写的这个接口写的业务部分以外，所以这个东西其实就是大家的一个短板。然后这个部分具体到技术层面面的落地，他又是件很明显，就技术层面你会发现我们现在需要长sm什么call？Spring cloud阿里巴巴。这是应用架构。但是除了应用架构以外，我们还需要掌握基础，很多同学一上来就是写CEO的，因为很多的软件培训公司，线下培训公司做的第一件事情就是教你怎么去使用，怎么去解决公司的CRM问题。所以你会发现很多人在应用框架层面用起来很熟练，但是基础懂不懂？呢比如说计算机原理，GPS并发编程，数据结构。
	网络io，磁盘io，这些基础你会发现它在整个宏观设计上或或者在软件的学习过程中，应用框架学习过程中，它起到很大的作用。所有的业务框架是不是来自于底层？我们再往上层的包装其实都是这样的。它是这样的，你看硬件硬件上面是什么？这个操作系统，操作系统上面，再是我们一系列的基础技术，比如说我们的数据结构，GM并发io，这个是针对于包装，就针对我们的这个语言的包装，然后再往上面就是框架，比如说spring，spring but等等这些东西的应用框架，在用框架之上还有一个中间件，所以这个是整个软件的一个金字塔，所以有的时候我们一接触的时候，噢老师我接触这个东西的时候，我发现什么东西理解不了，为什么？这东西理解不了的底层原因是因为首先你得理解，spring里面涉及到设计模式，涉及到软件的设计方案，Java基础，包括数据一个算法，这些内存等等这些东西。所以这个部分如果你不理解，那你就看不懂。所以你会发现为什么大家学起来会很累，学了以后容易忘，因为你们没有形成这样一个体系，你没有按照一个方法论去学习，所以这个东西中间房又很重要，因为你们在做软件架构的底层的细节设计的时候，你得需要掌握这个东西。
	所以呢如果你们想要在这个软件行业发展的更远一点，走得更长久一点，我建议大家是系统化去学习一个课程。因为非常简单一点就是什么？呢就是我们真的花了大量时间去学软件，学技术体系的这个时间太少了，我们把很多精力放在了CID和一些无效的沟通上，没有真正去为自己的未来去生根，扎扎实实的去去努力一次，然后最后到了工作三五年之后，然后说自己好像这个行业被淘汰，然后怪自己能力不行，但是你去回顾一下自己的一个过往的一个经历啊是不是真的努力了。因为如果你不希望自己未来的职业发展没有任何选择，然后担心淘汰担心各种大逆危机的时候，你还不如现在沉下心来去学习。我跟你大家讲这个东西很重要，就是我自己在这个行业干了14年，我自己从一个高中学历参加培训班，然后进入这个行业的，然后一步步走到成为架构师，一步步到青年创业，就是我这么发展过来的，这些经验我特别希望去分享给大家。就是技术这个路径的发展没有捷径，如果你想在这个行业内，你的职业发展的前景更长一点，你只能耐着心直在学习，所以我给大家讲的这个东西是我们的一个课程架构师课程，就是帮助在职的同学实现技术的系统提升。
	如果你在职希望自己的技术上有一个生长提升，然后能往架构师方向发展，或者能够去让自己薪资高一点，那么这个课程非常适合你们，这过程是什么方式？呢就是每周三次直播，每次直播两个小时，通过这种方式去给他上课，这个直播呢4个月4个月时间去交付完整个课程，如果想要了解我们的课程，可以在评论区留言咨询。给大家看一下。报完名之后怎么去交付的这个过程，我给你讲清楚，你就知道这课程值不值了，我们很多同学是没有一个很明确的方向和学习的一个路径，也不知道学完以后到底能够解决什么问题，甚至有些人自己学过，学了以后就唉发现学完以后就忘记了，没有一个明确的学习的一个体系方法。因为这里面首先我们的老师是找的是在职的互联网大层架构师，这些人的年薪都很高，这是第一个点。第二个点，你们报名之后，我们会先给你办理入学，生成一个电子档案，这个档案会跟踪你们整个学习过程，你们学习过程中的学习辅导，每一次指导，每一次的评测我们都会记录起来，这样的话后续给大家升级学习报告的时候，你们可以看得到。
	而且未来我们去做内推的时候，注意我们是内推的做内推的时候，我们会有这个凭证去给到我们的内推老师去做一个参考，这样的话能够增加内退的通过几率。然后第二个我们每一个学生报名之后，他会加个50人的一个班级，这个班级是小班制，因为很多同学基础并不是特别好，就是我干了两三年干了三四年的开发，但是基础不是特别好，能够去享受更多的一些服务。所以我们把这个班级弄小一点，那个获得老师的服务就更多一点，然后每个班配备一个班主任，这个班主任会跟踪大家学习情况，然后第三个就是老师会做VV的电话沟通，这个因为多少次？呢6次。6次Eva沟通，就是在你的整个报名的整个学习权益里面，权益是2年，啊你可以继续这两天看这个我们的视频学习。好，那么在这两年内，你可以去找到老师去参与6次VV沟通，这沟通不限于说面试指导，检定指导职业规划，所有你需要一个专业的在这个行业内资深架构师去帮你做咨询的，都可以。然后你报名之后会有一个定制化的学习规划，就是如果你是在职，如果你是工作3年或工作5年，你不同的工作年限有一不同的问题，你都可以去根据你的情况做定制化的一个方案。
	然后学习过程中你们会有辅导，不是说报名之后没人管，你啊报名之后我们会有老师去跟踪的，你们学习过程中班主任跟踪，我们会有学习辅导，这些辅导你们都是可以看得到的。你看就是你们遇到的问题，我们都会有老师在这边去给你们做辅导，这些同学都是报了VIP课程同学，并且我们为了保证按学习效果，我们会去给大家安排作业，这作业是去帮助大家更好的掌握我学到的内容。还有就是阶段性的评测，学习的效果怎么样？我们需要一个评测的过程，所以我们会给大家安排一个题库，去给大家做评测，你评分多少，就能够验证你的学习的一个水平。这个事情我们已经做了6年了，所以这个能够很清晰的去考核出大家的一个学习情况，包括阶段性的学习评测和智慧的直播集训，看到没？直播其实这么直播的。好，然后就是我们的面试辅导，简历优化、就业反馈，这是我们整个服务体系里面这个课程已经有5万名学员选了，而大家在这里面可以看到学员故事和课程服务，就你们可以看到他们的一个反馈，比如说公司涨了涨了11，整了1万，至少得3万左右，还没想好，今天行情不是很好，你看。
	然后工作一年到新公司涨了，从11k涨到14k就你们可以看到他们询问之后的一个反馈，产生这个结果的原因就是因为我们在这个过程中，啊其实整个服务这个过过程呢是做得很细，所以如果你现在是在职，如果现在对这个技术觉得有提升的空间，但自己又没有一个很好的一个约束的方式或者一个提升方式，这个课程可以帮助你们。
25-【Java面试】8月秋招必问：CPU飙高系统反应慢怎么排查？-480P 清晰-AVC
	昨天一个工作6年的粉丝去阿里面试，当场就怀疑人生了。另一面刚开始面试官就问他，CPU标高系统反应慢，怎么去排查和解决？Hello大家好，我是酷爆科技的联合创始人麦克，今天我就给大家分享一下这道场景题的解决方案，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享，你正在准备面试的小伙伴可以在我的评论区置顶中去领取。Cpu是整个电脑的核心计算资源，对于一个应用进程来说，CPU的最小执行单元是线程，因此关于这个问题呢可以从三个方面来回答。第一CPU上下文切换过多，对于CPU来说，同一个时刻下每个CPU核心只能运行一个线程，如果多个线程要执行，CPU只能通过上下文切换的方式来执行不同的线程，上下文切换呢需要做两个事情，分别是操作系统需要保存当前任务状态，以及加载新任务的状态，这个过程需要消耗一定的时间和计算资源，因此呢频繁的上下文切换会导致CPU花费更多的时间在任务切换上，而非任务执行上，从而影响了整体的性能。
	在Java中文件io网络io所等待线程阻塞等操作都会造成线程阻塞，从而触发上下文切换。第二，CPU资源过度消耗，也就是说程序中创建了大量的县城或者县城一直占用CPU资源无法被释放，比如死循环 CPU利用率过高之后，导致应用中的线程无法获得CPU的调度，从而影响了程序的执行效率。我们可以使用Top或者h Top命令去查看整个系统的性能，包括CPU使用率，内存使用情况，各个进程的资源使用情况等等。然后我们可以通过杰斯泰克命令去获取Java线上的堆栈信息，分析出具体是哪些线程，哪些代码在消耗CPU，或者使用性能剖析工具，比如g普法、尔v小vm等进行CPU性能的剖析，找出高CPU消耗的方法，定位到具体问题以后，啊我们就可以针对性的进行优化。比如频繁GC死循环地柜调用复杂循环等等。最后还有一种情况就是程序本身没有问题，而是当前系统的访问量过高，导致系统资源不够，这个时候我们就需要去考虑对系统进行扩容。
	以上就是我对这个问题的理解。刷面试题只能帮助大家在有限的时间内去快速提升应试能力。但是有可能在面试过程中，我们准备的问题面试官没有问到，我们没有准备的问题，面试官正好问到了，所以我们要尽可能的去把技术的体系化做一个深度的梳理，然后再结合面试文档进行一个整体的梳理，从而确保自己一定能够通过当前的面试，对于Java技术的系统化梳理，大家可以选择酷泡科技的架构，掌心班课程，去提升解决问题的能力。如果大家对课程中的任何内容有疑惑，也可以在我的评论区去留言咨询。

26-程序员不得不承认的事实，公司并不在乎你的技术！【Java职场经验】-480P 清晰-AVC
	对于大部分公司来说，你们的技术就是老板根本就不关心。对对对，是的。程序员不得不承认的是。老板其实并不关心你的技术。嗯你好，麦克老师，我其实现在有一个问题，啊因为我也是在做技术做了有个快5年了，嘛对吧？然后我其实就一直发现了发现了一个问题，啊就是因为现在其实我们这边做技术做技术的同学嘛基本都是在想着怎么去深入技术，怎么去把技术做得更好了，但是在工作过程中我就发现其实对于对于大部分公司来说，你们的技术就是老板根本就不关心。对对对是的。是的，只是要只是就是产出。他只关心你关心你的产出。对，关心我们的产出，然后其实去年的时候也是也是有有一种那个趋势，嘛就是发年终的时候嘛我觉得明显就发现了，就是每个部门里面呢你做技术的老哥，比那种做业务的老哥拿的东西少得很多。那其实这其实现在我也是很迷茫，嘛就是可能后续的话也是会继续往技术方方向去发展，但是我总感觉我总感觉好像好像苟不到35。嗯我我给你分析一下你的情况，我我大概知道我给你分析一下，呃从你职业发展来说，你未来一定是走业务方向，在国内一定是走业务方向，因为你可以预见的是在目前我们使用的组所有的中间件也好，技术组件也好，都是用的国外的。
	你没有看到国内有很真正研发出这种各种技术组件被被大规模使用，除了说像阿里开源的像double这些组件以外，但真正其实大部分吃国外的一些铸剑，所以意味着其实国内它其实没有这样一个这个技术的环境去去去支撑我们能够走到很长远，不像国外，这是第一个点。所以业务是但业务可以的。因为业务是真正去产生价值的一个部分，对吧？所以你未来一定是往业务直接往业务这个方向走。你们最近说嗯想要去面试的话，我整理了一份2024年最新的面试文档，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享免费去。好，第二个第二个点，技术的价值不是说我能够希望通过技术去获得更更更多的东西。系数只是你的一个跷跷板，一个一个一个跷跷板，就是你想去阿里你想去字节，对吧？你想去京东，你想去这些公司前提是什么？前提是你能够通过技术这个突破口去切入，进入到这个公司，就像原来的学历是一样的，理解我意思吗？
	所以技术是你的一个基础的那个杠杆，你通过这个杠杆进入更大的平台，去接触更多的牛人，更更优秀的圈子，接触更大的业务，更接触嗯更更多的数据量，更更多高的并发，你接触这样的东西，你这个时候你的你的价值就会慢慢的被放大。但是技术一定不是你的主要的目标方向，它只是去让你在这个行业内去获得更多可能性的一个工具。至少在35岁之前，这些东西它都是很重要的。但是到了职业转型，比如说我未来转业务架构，因为未来转业务架构的可能性会比较大一点，所以我们未来转业务架构转业务架构怎么怎么转呢？就是你基于刚刚说的业务的方向能力，再加上你技术能力，啊老师老师我不知道怎么去做设计，我不知道怎么去解决问题。技术它能够给你带来的是这部分能力，因为我们在我们举个例子，比如说我们去我们去学刚我们去历史可以学到什么东西，啊我们可以学到数据结构，数据结构它里面涉及到很多数据结构优化，比如说跳跃表，so in，the set，啊那个这个压缩表，quick list。
	对吧？数不同数据结构，我们可以学到不同的l呃内存的讨论算法，呀 iuffu算法，对吧？我们可以像double里面学到这种负载均衡算法，spi思想，对吧？动态是这个自适应扩展点等等，就是我们学这些方法之后，我们在解决问题的时候，我们实际上是用这一类的方法去呃转移到我们业务体系里面去，帮我们解决这些问题，我们就有这样一个设计能力。所以再加上你本身业务的一个积累，你业务的一个专业度，所以这两者结合你是往这个方向走是比较容易的。所以简单来说我给你总结一句话，就是技术是你现在的目前阶段来说它只是一个工具，你不管是在公司里面也好，公司里面他不会关心技术高和低，他只关心你产产出快和慢。就你原来一个月能评估的工作量，你能不能你能不能一周给我做完，对吧？这是你的KPI。第二个你做这个事情有没有价值，能不能为公司带来更大的一个产出，或者更大的一个销售额的增长也好，或者说效率提升也好，这是价值。但底层有什么技术无所谓，但是技术又是你的一个跳板，它能够让你跳跃到更好的一个平台，听懂我意思没？
	所以这是这是我的一个建议，啊所以所以我跟所有的人，包括因为我自己干了14年，我知道哪些东西重要，哪些东西不重要，而且在这个过程中你如随着你越去到不同的平台，你的认知越来越宽之后，你也会像我一样看到更多的东西，你会有更多的参考的元素去做决策。叮叮。
27-【Java面试】金九银十面试，掌握这套刷题方法论，通过Java面试像喝水一样简单？-480P 清晰-AVC
	有人跟我说刷题就是刷量，如果你也有这样的想法，那你就陷入了一个刷题误区而不自知。Hello大家好，我是麦克。今天这条视频适用于所有正在准备面试，想要提高刷题效率的小伙伴们，因为这个方法非常强大，并且极具适用性，它会让你所有的努力都落到实处，实现真正的一分耕耘一分收获。但是要注意这个方法奉行的是长期主义，如果你没有长期投入的心理准备，建议你自行划走，其他真正想改变和逆袭的同学，建议你把这条视频耐心的看完。我知道很多人看完这个视频，要么还是没动力去进行系统化的刷题，要么呢就不知道怎么把题目进行分类排序，我早就考虑到了这种情况。所以我给大家准备了一个面试学习手册，里面的题目都是市面上的高频题经典题，而且我都按照不同类型进行分类排序了，有需要的小伙伴可以在我的评论区去免费领取。接下来我要说的都是我这十几年来走过的路，刷过的题，踩过的坑里面总结出来的经验之谈。现在大家最常用的刷题方法就是在面试之前的那段时间去集中大量的去刷高频题，经电梯通过刷题去记忆背诵相关的理论知识，在短期内呢快速提高应试能力，这种方法的核心是概率，你记住的题目越多，通过面试的概率越大，比如说100道题，你知道5道那就有5%的通过率，知道适当就有10%的概率通过面试，如果你时间不够，可以采用这样的方法，但是要注意，啊它有一个最大的弊端，就是它是一次性的，所以在时间还算充足的情况下，我还是建议大家采用系统化的刷题方法，很多同学觉得刷题只是一次性的投入，但是实际上据有关数据统计，互联网程序员平均在一家公司在职的时间不超过三年，不管是自身原因还是公司原因，我们的职业生涯都不可能只找一次工作，系统化的刷题和短期冲刺完全不一样。
	短期冲刺是让你的状态在某一个时间点达到巅峰，它的状态曲线是这样的，但系统化的刷题呢是这样的，它最大的优势在于它能够带来长期效益，就像做数学题，不是单纯的教会你这道题目怎么做，而是让你掌握这一类型的解题方法。要知道题目是不可能刷完的。但是如果你掌握了方法，搞懂了这块核心知识点，以后再遇到类似相同的问题的时候，你就能够举一反三，融会贯通，而且它会帮你构建一个完整的知识体系，变成你的一种思维能力，在以后的实际工作你也能用到，听懂的同学可以在我的屏幕前扣个一，然后拿出本子和笔，把下面的内容记好。因为接下来我要讲的东西就是整个视频的核心，也就是我总结出来的系统化的刷题方法论。好了，话不多说，直接上干货。一点分类分优先级刷题，分类大家都知道就是按照技术板块题目类型来分，比如说 Java基础知识并发编程与多线程，集合原理，实战场景里等等，这一部分我就不多说了，主要是和大家说一下怎么对题目进行优先级排序。我建议大家呢把题目分成三个等级，一典型的板块体，每个类型大概选5道题目，把每道题目至少刷6遍以上，达到能够脱口而出的肌肉记忆状态。
	不仅要知道题目的答案，还要进行一些延伸，把里面的技术点概念都了解透彻。第二核心体选200~250道高频题和经典题，每道题目刷上起码三遍，要理解清楚每道题目的解题思路，掌握最优解和多种解法，并且要知道不同解法的优缺点。第三，其他题目，理清逻辑和思路，自己有个清晰的印象就行。第二点，刷题要轻松结合，人的大脑是有一个遗忘曲线的，这是不可控的，但是我们可以从遗忘曲线中去掌握规律并加以利用，从而提升自我记忆的能力。所以我们在不同的阶段刷题的力度也要有所不同，刷题力度大致可以分为以下几类，粗刷金刷、破题、复刷和模拟，这是核心题的标准刷题模式。其他题目要根据重要程度再加减精刷复刷的次数。第三点，一边刷题一边给自己讲解。这样做有两个好处，第一可以加深印象，提高学习效率，因为声音比图像更容易被记忆。第二，可以提高我们的语言表达能力。很多小伙伴平时学的挺好，但一到面试就语言逻辑混乱，词不达意，是因为他们不能把思维很好的转化成语言的表达，这是需要经过长期锻炼的。
	所以我们平时要多说多练。第四点进行任务分配管理，如果我们刷题的时间没有规律，想刷就刷，那么学习效率效果都一定会大打折扣。必须要把刷题任务细分到天，制定一个合理的详细的刷题计划，并且严格按照计划去执行。之前我有提过一个概念，就是大脑的遗忘曲线，这也是我们必须要去做计划的原因。因为可能你隔10天再去刷题，之前学习的内容就忘记了。今天的视频就分享这里，我是麦克，我们下期再见。
28-【Java面试】秋招面试必问：InnoDB如何解决幻读问题？-480P 清晰-AVC
	我们在面试的时候经常会遇到事物隔离性的相关问题，前天有一个粉丝去快手面试，被问到一诺DB如何解决幻毒问题的。Hello大家好，我是酷跑科技的联合创始人麦克，这个问题要回答好，还是稍微有点难度的。所以我们今天呢就给大家分享一下这个问题的回答思路，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我们评论区留言求分享你一下，有需要的小伙伴可以在我的评论区置顶中去领取，这个问题可以从三个方面来了解和回答。一麦c口的事物隔离节点，麦c口有4种输入隔离级别，这4种隔离级别代表当存在多个事物并发冲突的时候，可能会出现的脏、毒，不可重复读。换组的问题，其中一诺DB在r隔离级别下解决了患者的问题。那么什么是幻读呢？幻读啊是指在同一个事物中，前后两次查询相同范围的时候得到的结果不一致，我们来看一下这个图。第一个事物里面我们执行了一个范围查询，这个时候满足条件的数据只有一条。第二个事物里面它插入了一行数据，并且提交了接着第一个事物再去查询的时候，得到的结果比第一个查询的结果要多出来一条数据，所以幻毒会带来数据一致性问题。
	一朵DB中引入了mvc和lbcc这两种机制来解决换读。其中lbcc用到了零件锁、电气锁和行锁，为了更清晰的说明这些锁，我们举个例子，假设现在存在这样一个b加速的索引结构，这个结构中有4个索引元素，分别是一、47和10。当我们通过组件索引查询一条记录，并且对这条记录通过for update枷锁的时候，这个时候呢会产生一个record的rock就是记录所或者说行所锁定ID等于一的这个索引，被锁定的记录呢在锁释放之前，其他事物是无法对这项记录做任何操作的。前面我说过对幻图的定义，换读是指同一个事物中前后两次查询相同范围的时候，得到的结果不一致。注意这里强调的是范围查询，也就是说一诺DB引擎要解决换毒问题，必须要保证一个点。就是如果一个事物通过这样一条语句进行锁定的时候，另外一个事物在执行这样一条音色的语句需要被阻塞，直到前面获得锁的事物释放掉。所以在印度BB中设计了一种间隙锁，它的主要功能是锁定一定范围内的索引记录，当对查询范围ID大于4and ID小于7枷锁的时候，会针对b加速中4和7这个开区间范围的索引，加间隙锁，意味着在这种情况下，其他事物对这个区间的数据进行插入更新删除的时候都会被锁住。
	但是还有另外一种情况，比如说像这样的这条查询语句是针对ID大于4这个条件枷锁，那么它需要锁定多个索引区间，所以在这种情况下，一诺DB引入了next k lock机制，next look呢相当于见习所加记录所的合集，记录所锁定的是存在的记录行，间隙锁锁住的是技术行之间的间隙，而next lock呢所做的是两者之和，每个数据行上的非唯一索引链上都会存在一个next。当某个事物持有该数据行的next lock的时候，会锁住一段左开右臂区间。因此当通过ID大于4这样一种范围查询枷锁的时候，会加max给lock。锁定的区间范围是这样的，间隙锁和next look的区别在于枷锁的范围，间隙锁只锁定两个索引之间的引用间隙，而next lock呢会锁定多个索引区间，它包含记录所和见习所。当我们使用的范围查询，不仅仅命中了r的rock，还包含了gap间隙。在这种情况下，我们使用的就是零件锁，她是my里面默认的行算法，虽然一诺DB通过介系所的方式解决了换毒问题，但是枷锁之后一定会影响到并发性能。
	因此如果对性能要求比较高的业务场景中，我们可以把隔离级别设置成RC，这个级别中不存在建议所。以上呢就是我对这个问题的理解。刷面试题只能帮助大家在有限的时间内去快速提升应试能力。但是有可能在面试过程中，我们准备的问题面试官没有问到，我们没有准备的问题面试官正好问到了，所以我们要尽可能的去把技术的体系化做一个深度的梳理，然后再结合面试文档进行一个整体的梳理，从而确保自己一定能够通过当前的面试，对于Java技术的系统化梳理，大家可以选择酷跑科技的架构，掌心班课程去提升解决问题的能力。如果大家对课程中的任何内容有疑惑，也可以在我的评论区去留言咨询。
29-别再盲目啃传统八股文了！2024Java面试新风向，行业变动一目了然！【计算机】-480P 清晰-AVC
	我今天晚上会通过直播的方式去给大家分享一下关于目前大家在面面试过程中遇到的一些痛点和一些解决方案，我会把很多我自己去实操的一些经验给大家分享出来，我是09年打我这个行行业的，然后到现在有15年的时间，所以我自己本身我也参与过无数次的面试，我什么类型的公司我都面试过，比如传统企业、啊互联网公司、啊金融公司，我自己有很多的一些面试的感悟，然后同时呢自己自己在工作里面我也面试过很多人，到现在几千人上万人应该是有的，就是我我那个时候是很早就做技术负责人，然后我需要参与的很多面试。最夸张的时候就一个新疆面很多人，我自己大概是非常清楚的，就是我要什么的人，我怎么去筛选我的维度，其实代表的是目前一个市场上的一个维度，就其实如果早几年去去大看的话，其实市场的面试官的能力是参差不齐的，但是到了今年的这个市场，你会发现整个士官的能力的体系已经有一个很大的提升，至少说我认可了现在很多公司的面试方式，那现在的面试方式什么？就是场景加技术加解决方案，加酵母。目前现在的面试呢其实是基于这样一个方式，他去通过这样一个维度来去考察大家的技术能力，我是比较认可这种方式，因为我一直在用这种方式比我们自己也有自己的官网，也有自己的一个平台，包括我们的直播平台是我们自己开发的。
	注意我在这个领域上其实是有很深刻的感受，我知道通过哪些维度去面试一个人是能够去识别出这个人的一个水平的。原来我们在早16年的时候，其实我们发现那个时候市场的面试的情况其实是比较参差不齐的，因为我们遇到一个很重要的一个点是当时很多面试的这个面试官，他们其实更多的还是基于纯技术的一个面试，就是会问你一些我们所谓的叫面试八股文，我们会问一些常规的一些技术问题，那么这些问题本来当然也没什么无可厚非，他能够做那个筛选没有问题，但是你你会发现现在的面试就会多了一些筛选维度，我们举个例子大家就理解我在讲什么了，比如说我们讲到卖杯子的这个缓存机制，如果是在那5年之前，吧大家可能在面试过程中遇到最多问题，就说一下 abs里面的缓存机制，那么这个时候就会说a是factory和CC这两种二级缓存，但是到了这个现在的话你就会发现他也会问一些面试的技术问题，但是他可能会说说一下你对麦克的缓存机制的理解和优缺点，这是第一问，但是他并不是会只问这一个点，他是会围绕这个东西去深度挖，基于这个问题我们继续来考察，针对于大型高并发系统，你会如何设计MS的缓存策略，以及提升性能和降低数据库的压力，有哪些注意事项？
	啊如果你发现max的缓存数据与数据库不一致，有哪些可能的因素，然后分享一下你在项目中利用卖杯的缓存机制，消化性能的具体案例，包括遇到了哪些挑战和解决方案，这个就是我们现在的一个面试的问题的变化，就是5年之前是这个可能就是一个问题，就你一个点就够了，但现在是这样一个方式，就是即便我是面的是八股文，但是它会结合场景来问，我再举个例子，大家明白了，比分之前可能我们问比如说什么印中的事物传播行为，这个大家很简单，就是我们原来疾病不记得，我也在网上一查就会告诉你有7种，然后什么你快点就看news。然后是炮塔内的的这7种，那我们基本上这么去回答出来，就也能通过面试，但是现在你会发现它会怎么灭。呢比如说唉这个第一你是如何理解spring的事物传播行为的这个地方，你会发现它是要自己组织语言的，你要去组织成你自己理解。第二个比如说在一个包含多个 service盗用的业务逻辑中，如果其中一个service方法执行失败，应该立即回滚，不影响其他服务的正常执行，你认为应该怎么设置事物传播行为，我再举个例子啊就是你如何理解最快的当然没有，但实际一定用中的作用并举例说明感受到没？
	就是这个是一种变化。如果原来我们在面试的时候，通过背诵一些常规的问题就能回答出来，到现在啊我在面试过程中构建的场景，然后希望你能够在这个场景里面去基于你的理解来去回答这个问题，这就是现在的一个变化，为什么会变成这样一个形式，大家明白我意思吗？就很简单的一个逻辑，就是大家都会去通过刷面试一得到答案的时候，如果每个人都会的时候，其实是没有差异化的，我们面试本身就是比如说10个人挑1个人，100个人挑1个人，那我怎么样去区分这个人的能力，所以我们需要有一个什么辨识度，所以在这里面就是如果说原来我们有标准答案可以去记，但现在你会发现不具备标准答案的情况下，你再去投递简历，也许拿到面试机会的时候，但是你一定列不过。因为什么？那我昨天接了一个同学的一个例子，就是他三年之前在杭州找一份工作，他在这公司干了三年，这三年之前是2021年，他还停留在说觉得那时候找工作很简单，那个时候毕业嘛杭州投了几份简历，然后轻松拿了一个互联网公司的offer，三年之后的3月份然后开始投简历，他用的是2021年的方式海投，然后高频度高频率的面试是这个方式来找工作，在2021年是没有任何问题的，因为这种方式有大量面试机会作为前提，所以有大量的容错和试错空间，并且当时的市场虽然卷，但是没有卷到今天的程度，这是一个变化，所以他开始投的时候发现投了一个月，然后灭了两次，那两次他都没有过，然后第二个又继续投，他开始有点慌，所以他当时在网上也去了解各种信息，然后后面发现好像市场确实变了，所以很焦虑。
那昨天我跟他聊的时候那种焦虑感非常非常的明显，我想跟他讲这是个变化，他会结合一些实际的情况和你自己理解，为什么这个都有区分度，呢因为如果8股文不具备辨识度，那么通过场景问题的考察，能够基于你自己的理解的回答，来判断你是否对某一个技术有深刻的认识，所以这个时候就具备了筛选的机制。这个是我想给大家去讲得很清楚的一个一个话题，我希望大家能够去认识到这个点，即便是在职的还没有投过简历的，甚至说有些是正在准备找工作的同学，所以我把这东西讲清楚是告诉你们，现在既然是这个情况，那我应该怎么准备，通过今天的这个直播的时间，我会给大家讲清楚怎么样做准备。

30-【Java面试】秋招面试必刷：如何设计一个短链系统？-480P 清晰-AVC
	Hello大家好，我是酷跑科技的联合创始人麦克，昨天一个工作7年的粉丝去参加阿里的面试，被问到如何设计一个短链系统，他觉得自己当时回答的不是很好，希望我能够帮他解答一下。所以呢今天我就给大家分享一下这一道问题的回答思路。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我的评论区留言求分享，免费去联系一下，有需要的小伙伴可以在我的评论区置顶中去留言领取，短链有很多好处，比如说在营销短信的场景中，啊由于短信长度的限制，我们可以把长链接缩短，去增加可发送文字的长度。第二，在生成二维码的场景中，啊长链接生成的二维码更加密集，扫描的时候呢识别难度较大。第三，在有些平台链接太长，无法被自动识别，而短链接没有这一类的问题。因此很多公司会搭建自己的短电系统，而这个问题可以很好的考察求职者的系统设计能力，以及解决问题的能力，所以你们应该给出一个相对完整且合理的设计方案。短链的原理很简单，用户访问短链的时候，短链服务器收到请求后触发302重定向，然后浏览器再请求重定向的地址获取目标网页的内容。
	因此短链系统就相当于在原始链接上建立了一个映射关系，既然是应税关系，那就必须要考虑几个关键问题。第一，如何生成短链？第二，短链和长链的映射关系如何存储？短链的组成有两个部分，分别是域名和长链接映射的字符串，短链系统就是根据这个映射字符串去找到匹配的长链进行重定向。因此我们需要考虑这个映射字符串的唯一性以及长度，常见的做法就是使用哈希算法，比如MD5，she-1，把长链映射成一个固定长度的哈希值，但是考虑到哈希字符串的长度，我们可以进一步的去选取哈希值，进行64进制的转换，得到一个6位长度的值，它可以表示接近568亿的数据量，应对短练的场景是完全足够的。接下来我们可以把短链和长链的映射关系保存在数据库中，如果考虑到性能也可以用reeds来存储，这样可以避免后续随着数据量越来越多造成的查询性能下降的问题，最后还需要考虑到哈希冲突的问题，我们可以通过在哈奇法来解决。以上就是关键部分的实现逻辑。如果自己的技术储备还不错，可以把整个架构方案设计更完善一点。第一，为了考虑后期病房量过高的问题，我们需要设计一个能够水平扩展的系统架构，我们可以采用微服务架构，将不同功能模块分解到不同的服务上面。
	比如生成短链的服务，查询常见的服务等等，每个服务都可以单独进行扩展。第二，为了防止恶意用户生成大量短链，我们可以限制每个用户每天生成的短链数量，我们还可以使用验证码，API速率限制等手段去防止机器人攻击。第三，为了提高性能，我们可以使用cdn，加速短链的访问，使用HP二协议来减少网络延迟，使用数据库分区和索引来优化查询速度等等。最后为了更好的观察短链系统的运行情况，我们需要搭建监控平台，包括系统性能监控业务数据监控和异常监控等等，还需要记录详细的日志，包括请求日志错误日志等等，以便进行问题的排查和性能优化。以上呢就是我的理解，面试题只能帮助大家在有限的时间内快速提升应试能力，所以通过冲刺去拿到offer以后，啊大家还是要选择像架构掌心班之类的系统化课程，去提升实际解决问题的能力。如果大家对课程中任何内容有疑惑，可以在我的评论区留言咨询。
36-【Java面试】高频面试题：为什么不能用浮点型表示金额？-480P 清晰-AVC

	为什么不能用浮点型去表示金额？这个问题来自于一个金融公司的面试真题，如果没有参与过金融项目开发的同学就不一定清楚。Hello大家好，我是酷跑科技的联合创始人麦克，今天给大家分享一下这个问题的回答思路，另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，能够帮助你们提升80%的面试通过率。一般在金融领域中啊要表示货币的精度，至少要精确地表示0.1或者0.01等货币的数字，这样在进行资金预算的时候，才能够避免出现精度丢失，造成用户资金的损失。而浮点数是用二进制科学计数法来表示的，这就意味着它不能精确的表示所有10进制的小数。所以使用浮点数进行算术运算，比如加减乘除可能会产生舍路的错误，在大多数情况下，这种错误可能影响不大。但是在处理资金问题的场景中，这些小的错误可能会累积起来，导致最后的结果与期望的结果有明显的差距。所以为了避免这一类问题，呢在处理金钱或者货币的时候，通常推荐使用特殊的货币类型，比如一个DC梦来表示金钱，这样的话可以确保在进行算术运算的时候能够保证精确的结果。
	以上呢就是我对这个问题的理解。我是麦克。感谢大家点赞和收藏，我们下期再见。
33-【Java面试】秋招面试必刷：kafka的零拷贝原理？-480P 清晰-AVC
	最近一个学员去京东面试，在第一面的时候遇到这样一个问题，请你简单说一下卡夫卡零拷贝的原理。Hello大家好，我是酷爆科技的联合创始麦克。今天给大家分享一下这个面试题的回答思路，我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我们评论区留言求分享，免费去复习一下。在实际应用中，如果我们需要把磁盘中的某个文件内容发送到远程服务器上，那么它必须要经过这样几个拷贝过程。第一，从磁盘中读取目标文件的内容，拷贝到内核缓冲区。第二CPU控制器，再把内核缓冲区的数据复制到用户空间的缓冲区中。第三，在应用程序中调用write方法，把用户空间缓出去的数据，拷贝的内核的烧开的8分钟，最后把在内核模式下收开了巴甫中的数据，复制到网卡缓冲区，网卡缓冲区再把数据传输到目标服务器上。在这个过程中我们可以发现，数据从磁盘到最终发送出去，要经历4次拷贝，而在这4次拷贝过程中，有2次拷贝是浪费的，分别是从内核空间复制到用户空间，再从用户空间再次复制到内核空间。
	除此之外，由于用户空间和内部空间的切换，会带来上下文的一个切换，对CPU的性能也会造成一些影响。而零拷贝就是把这两次多余的拷贝省略掉，应用程序可以直接把磁盘中的数据从内核直接传送到说ok的，而不再需要经过应用程序所在的用户空间，零拷贝通过dma技术把文件内容复制到内核空间的的buffer，接着把包含数据位置和长度信息的文件描述服务加载到索克的buff中，dma引擎直接把数据从内核空间传递给网卡设备。在这样一个流程中，数据只经历了两次拷贝就发送到了网卡中，并且减少了两次CPU的上下文切换，对效率有非常大的提高。所以啊所谓领拷贝并不是完全没有数据复制，只是相对用户空间来说，不再需要进行数据的拷贝。对于前面说的整个流程来说，零拷贝只是减少了不必要的拷贝次数而已。那么在程序中如何去实现零拷贝呢？在Linux系统中零拷贝技术依赖于底层的sendfile方法来实现，而在Java中 fire China点transfer to这个方法，底层实现就是用到了sendfile方法。
	除此之外还有一个叫mm的文件映射机制，它的原理是将磁盘文件映射到内存，用户通过修改内存就能够修改磁盘文件，使用这个方式可以获得很大的io提升，省去了用户空间和内部空间的复制开销。以上就是我对于卡夫卡中临考背原理的理解，我是麦克，感谢大家点赞和关注。我们下期再见。
35-【Java面试】秋招面试必刷：说一下你对Spring Boot的约定优于配置的理解？-480P 清晰-AVC
	请你说一下对于springboard中约定用于配置的理解。Hello大家好，我是酷爆科技联合创始麦克，今天呢我给大家分享一下这个面试题的回答思路。我整理了一份2024年最新的面试文档，有这个问题的满分回答，其中还包括52万字的技术场景问题的分析和85万字的技术面试与分析，可以在我们评论区留言求分享，免费去复习一下。这个问题可以从4个方面来回答。第一，首先啊约定由于配置呢是一种软件设计范式，它的核心思想是减少软件开发人员对于配置上的维护，从而让开发人员更加聚焦在业务逻辑上。第二，speedboat就是约定优于配置这一理念下的产物，它类似于spring框架下的一个脚手架，通过视频或者我们可以快速开发，基于spring生态下的应用程序，基于传统的租赁框架开发外部应用，我们需要做很多和业务开发无关的，并且只做一次的配置。比如说管理架包的依赖，外部电xm文件的维护，一次part是耐着点x秒配置像的一个维护，应用部署到web容器，以及第三方组件集成了视频IOC容器中的配置项的维护。
	而在食品步骤中，我们不需要再去做这些繁琐的配置，随便boss已经自动帮我们去完成这样一些动作，这就是约定优于配置思想的体现。第四，springboard约定，由于配置的体现有很多，比如是并不得start启动依赖项，它能帮助我们管理所有Java的版本。其次，如果当前应用依赖了spring mvc相关的价包，那么 sim或者会帮我们自动内置，他们开始容器来运行web应用，我们不需要再去单独做应用部署，以及sim不止的自动装备机制的实验中，通过扫描约定路径下的食品点faculty文件，来识别配置类，实现病的自动装配。最后还有默认加载的配置文件，application的property等等。总的来说约定优于配置是一个比较常见的软件设计思想，它的核心本质啊都是为了更高效以及更加便捷的实现软件系统的开发和维护。以上就是我对这个问题的理解。我是麦克感谢大家点赞和关注，我们下期再见。
32-【Java面试】场景题：两个库各100万条数据，如何在20秒内让它们对比完？-480P 清晰-AVC

	我这边有个有个同学问了个问题，啊我这边怎么我这边两个PG各100万条，我看一下我先看一下他问题问的比较好，这个场地问题，这不是8股文是吧？两个PG的这你是片circle吗？你是写简写吗？两个PC的库各100万条数据，如何保证20秒内对比完成？需要具体的一个你这打字打的有点不全，不通俗你懂吗？Pg是program。CPU是那个一个关系数据库建设。一批收购鲜茧一些减一些，写是简写的简写，但和如何你是想做两个两两两个库里面100万做对比吗？这个粉丝。好这个问。 Post grade CQ它pplcq叫PRO的grade CQ啊那个对那个大象那个数据库也是关系数据库。啊先谈的麦克老师谈完，我再谈一谈这个应该怎么去做，我想我思考了5分钟，我思考完我给你这个答案了。那什么问题？他的意思就是说我现在在我现在你不用想去PS2口，就好比我先用两个库嗯对吧？嗯两个库的数据我想做个比对，嗯请问你怎么能在20秒内把它比对完成？你先说一下你的看法。
	你一件事情看不好，我也在理解，你也说你的看法。
	像这种的话，100万的数据的话，最好是用大数据框架，用那个流式处理框架去做，你带过去人你再怎么样搞，你20秒也搞不完。那具体怎么做呢？具体大数据怎么做？大数据？你你用18个去处理。啊我说我说说具体的时间。就是要写代码，你把数据数你把你的所有的数据丢到那个18个里面去做分析不就好了吗？像如果说看看完你的那个面试宝典的话，正常去面试那东西薪资呢。拿多少薪资？啊如果你全部学会的话，我估计保守估计也得造3万。吧3万，你开玩笑，我靠这么牛逼3万，你是真发的吗？唉还真发了，麦克老师你真发给我了。当然我我拿个小号进你的这个粉丝群里面试宝典，我的妈我的妈我真真的掉这个面试吧有没有掉？这个面试完了有点牛逼，啊我靠。在你的粉丝群进主页可以拿到这个这个面食包，呢有点牛逼有点牛逼啊我靠。有点屌有点屌。啊其实你谈大数据方案，我先谈谈，我的一个思路啊我谈的思路是这样想的，呃我我先问一下他这个以后有没有有没有增量？我当然也没有增量，如果增量的话肯定要搞扩容的好不好？
	其实我觉得这个思路其实蛮简单的，首先呢你100万的数据，如果你你靠单台的去搞的情况，我估计不现实，嗯但那肯定不现实。所以你肯定要把100万把它分摊成n把它分段一下，就把它拆分成10个，分成10个20个不同的小文件对吧？然后放到。多个部门机器里面只是数据库。嘛对，我是我这我说的蛮简单。如果让我搞的话，20秒满姐呢我我直接去买很多服务器，郎朗父亲同时起来，然后搞分段的形式，我把产品分成10个。那你要把数据只要。只要说我每一个服务器里面去比对，能在20秒完成，ok我10个服务器并行处理，二审被搞定了，嘛在以后如果新的情况还是蛮简单，我这再提个服务器，所以我把一个大的日文件把它分段呀分成n多个小的块，然后每个服务器去测这么一块，它的一个对比的数据行了。我是这样实现的。就是超能力对吧？对，不是我是搞我是这样的事情，就是假设如果说我不用这个大叔喜欢这样做的好吧？就说假设有增量情况下蛮简单，你你以后只要再起这种。
	你就不应该做对比方案。你这块这个要看看就不应该走对比方案，你应该是去根据。就你你如果是你有两种情况，第一种情况就是说我已经有100两两个100万数据在那了，和第二组就是我在去业务正进在进行过程中去不断去入库的数据，这是两种情况，两种情况不一样，如果是已经有100万这样一个数据情况下，那你的对比就不可能20秒处理完成。你的数据已经成型了，包括像刚才有说你都通过那个 Md5你去生成每一条数据，MD5是一样的，就 MD5是一个必备的手段，就是你去表示每一条数据的一个差异化，对吧？因为MD5它是一个固定的一个结果，嘛就是生成一个哈希值。那你这比较因为。他这个其实没标准问题，为什么？因为他已经已经给你的库。那你怎么知道呢就不一样了。写取行值可以自己写个脚本比对什么，直接写脚本把它导成Excel表格的形式会怎么样。啊所以我们还是了解有点开心的。嘛很开心的是吧？还很开心的，不是这个粉丝。啊我觉得你没必要问这个什么叫双链表，单链表这东西我觉得那个太那个了你问的问题说实在话，你要不说不说，吧你就说不会，这样东西就是什么意思？啊就是头尾相连接懂了吗？头尾相连接，双链表代表是我只只想只想只想下一个。就是是这个意思晓得吧？嗯叮叮叮。
34-【金九银十】从没有面试邀约到连斩6个offer！找对努力的方向直接开挂-480P 清晰-AVC
	从投简历没人搭理，到半个月以内连续斩获6个offer，薪资从12k一路涨到20k这是我的一个学员在做出改变之后的真实变化。那他到底做出了什么改变呢？今天啊我就给大家分享一下，这个学院是二本学历，有4年的工作经验，工作地点是在广州，之前在一家小型互联公司上班，考虑到未来的职业发展，所以他想跳槽进入到更好的平台。但是啊他投了很多份简历，都没有拿到一个面试邀约，所以找到我来寻求帮助。和他聊过以后，呢我了解到他的诉求不只是短期的跳槽涨薪，而是想要稳步提升对座冲击大厂，所以我特意邀请了一位大厂在职的私教老师去帮他进行一对一的沟通指导和综合测评。从测评的结果来看，啊它是具备进入大厂的出差条件的。统招本科学历，有过中大型公司的背景，技术掌握的比较全面，而且人也比较年轻。不过呢这只是达到了进入大厂的最低招ping门槛，想要真正拿到offer，还是要提升整体的竞争力，而且他也还是有很多需要去补足强化的地方。比如项目经验偏传统，技术虽然全面，但是都不够深入，还有算法能力弱，对数据结构的概念不理解，表达不够流畅，缺乏自信，回答缺少业务思维，逻辑思维等等。
	基于这个学员的测评情况和根本概述，我给他建议是先短期突击，再长线作战，并且给他制定了一个细致的定制化学习方案。这个学习计划不只是单纯的看视频跟网课，而是简历、面试、技术、能力、素质四位一体的多维指导。首先求职方面，安排指导老师，一帮助它提炼项目亮点，优化简历，给他提供面试前的辅导、面试答疑、面试后的复盘等服务。其次在技术提升方面，呢分两个阶段来进行学习，先学习我们高薪offer冲刺般的大纲内容，快速吸收面试的全部核心知识点，然后再找到工作以后，再进行系统化的深度学习，帮他提升技术深度，重点强化数据结构和算法方面的能力，一步一步往大厂招ping需求的方向靠拢。最后是能力素质方面，这个学员最大的问题，其实表达能力和业务逻辑思维能力不行，这其实是很多程序员面临的普遍问题，尤其是只会敲代码，不关心整个宏观业务的程序员，但是如果想要进入大厂，那么这些问题是必须要解决的。所以我们安排了大厂教练给他做长期的一对一强化辅导，大厂教练通过模拟面试和交流对话，分享大厂真实实战项目和自己的成功经验，来帮助他反复训练表达逻辑，培养业务和框架思维。
	这个学院啊是5月底找到我的，强化培训，一个多月以后呢在7月中旬开始重新投递简历，截止到7月底他就一共拿到了6个offer，通过公司规模、项目背景、薪资待遇、发展前景等多个方面的对比分析，最后在我的建议下，呢我选择了一个对未来跳槽进大厂有帮助的公司，现在已经在进行第二阶段的技术学习了，相信用不了多久他就能够成功实现大场梦。要做出改变确实很难，但是我们需要有改变的勇气，连接是我们的资本，不要等到资本消耗完的那一天才开始后悔。如果你想做出改变，摆脱现在的职业困境，或者对自己职业发展感到迷茫，可以在我的评论区留言咨询，我可以帮助你提供Eva的指导和解决方案。好了，今天的视频呢就分享到这里，我是麦克我们下期再见。

37-【Java面试】秋招面试题：如何不停机进行数据迁移？-480P 清晰-AVC
	如何不停机进行数据迁移。Hello大家好，我是酷跑科技的联合创始麦克，今天给大家分享一下这个面试题的回答思路，另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，很明显这是一个场景问题。如果求职者呢有数据迁移的经验，很容易就能够回答出来，而且还能结合自己在实践过程中遇到的问题和解决方案进行综合描述，更好的突出个人的优势。这个问题对求职者如何分析问题，如何制定解决方案，是否能够考虑到可能的问题，并提前规划对应的措施等方面做一个综合评估。另外不停机数据迁移涉及到系统架构，数据库迁移、数据同步等多个方面，需要求职者有扎实的系统规划和设计能力。下面我们来看一下这个问题的完整回答。对于这个问题首先要做的就是把旧库的数据复制到新库中，而由于旧库还在服务线上的业务，所以不断会有数据写入到旧库，我们不仅要往新库复制数据，还要保证新旧两个库的数据实时同步，所以我们需要一个同步程序来实现新旧两个数据库实时同步。
	这里我们可以采用双写的方案，在进行数据迁移的同时，旧系统和新系统都同时写入数据，这种方案在数据迁移完成之前，需要保持两套系统并行运行，有一定的系统资源开销，但是可以实现平滑过渡。当新系统的数据和旧系统数据保持一致，新系统稳定运行以后，就可以逐渐将流量切换到新系统，并逐步停用旧的系统。不过啊切换到双鞋之后，新库和旧库的数据可能会存在不一致的情况，原因有两个，龟停止同步程序或者开启双险，这两个过程很难做到无缝衔接。第二，双选的策略也不能保证新库和数据的强一致性，这个时候我们还需要一个对比和补偿的程序。这个程序对比旧库最近数据的变更，然后检查新库中的数据是否一致，如果不一致就要进行补偿，开启双线以后呢还需要稳定运行至少几周的时间，并且我们要不断的去检查，确保不能有旧库写入成功，新库写入失败的情况出现。对比程序也没有发现新旧两个库的数据有不一致的情况，这个时候我们就可以认为新旧两个库的数据是一直保持同步的，接下来就可以用类似灰度的方式，把毒请求逐步切到新库上，如果出现问题的话，可以再切回到旧库。
	当全部读请求都切换到新库上之后，这个时候其实读写请求就已经都切换到新库了，至此呢我们就完成了在线更换数据库的全部流程。以上就是我的理解，我是麦克，感谢大家的点赞和关注，我们下期再见。
38-【Java面试】面试问你的项目中有什么亮点？你该如何回答！-480P 清晰-AVC
	请你说一下你项目中的亮点。Hello大家好。我是酷爆科技联合创始人麦克，今天我给大家分享一下这个问题的回答思路，如果你不知道怎么去提炼你的亮点，也可以进粉丝群找我帮你做一个免费的评测。另外我把网签的内容都打包在了加我面试里面包含了35万字的面试文档，200份精选简历模板以及Java架构师学习路线图，至少能够帮助你们提升80%的面试通过率。几乎每个准备去面试的同学都会被这个问题困扰。我羡慕很简单，就是CRD没有亮点怎么办？没有做过分布的项目哪有什么亮点？我之前做的都是单体项目，实在想不出有什么亮点。大家对这个问题的误解在于一定要项目足够好才有亮点。其实啊面试官在问这个问题的时候，是想了解你在项目中的成果和能力，我们可以从几个维度去准备。第一，解决复杂问题的能力，你可以描述你在项目中解决过哪些特别复杂或者有挑战性的问题，可以是技术问题，也可以是业务问题。比如说通过引入卡夫卡这个消息队列，优化了程序的效率，使得我们能够在高峰期处理百万级的消息。
	第二，做了一些提高效率的工作，比如说重构代码，优化数据库查询效率，引入异步线程，优化了代码的效率，开发了一个公共组件，提升了团队的开发效率。比如优化了一个复杂的慢c口语句，提高了数据库的查询效率，使得查询效率整体提升10倍。第三，突出团队协作和沟通方面的能力。比如说在项目中承担了核心开发或者团队小组长的角色，通过一系列的管理手段，按时完成了项目交付和提高了质量保障等等。比如我带领我的团队完成了这个项目，我负责分配任务，协调团队的成员工作，以及解决团队中出现的问题。在我的管理下，我们成功的按时完成的项目得到了客户的高度评价。最后我们还可以突出学习能力，比如项目里面要用到一个新的技术，这个技术之前没有用过，但是呢项目交付的时间比较紧，所以啊我大概花了三天时间在网上找了各种资料学习，在实际落地的时候还遇到了一些自己解决不了的问题，后面在get up的医学上找到解决方案，最后按期完成了项目的交付。因此对于项目中的亮点，你们可以从对业务设计的深入思考，问题解决的能力，或者对某个特定技术的深度理解，团队协作沟通等方面去准备，从而让面试官看到你在项目中的思考和总结，而不是一个只会cab的工具人。以上呢就是我的理解，我是麦克，感谢大家的点赞和收藏，我们下期再见。
39-【Java面试】直播被问场景题：“1亿个用户，每个用户发放十个优惠卷，怎么做不会重复？”-480P 清晰-AVC
	呃1亿个用户，给每个用户发放10个优惠券，怎么去不重复1个用户每个用户发放10个优惠券怎么做不会重复，呃1亿个用户给每个用户发放10个优惠券，怎么去不重复？这个问题我问的比较好，我觉得。提示直播间噢这假的啊噢这假的吓我一跳，1个亿用户给每个用户发10个优惠券，怎么保证不重放？你这里面首先你要解决的不是重发的问题，你要解决的是你可以怎么去发的问题。像这种这种大的用户，你你像你是全平台发的话，全平台化的话，你服务端去发送这个事情就不现实，你应该是客户端去主动去就调就是你的用户登录之后，去主动去拉取，拉取什么拉取我的优惠券，那么我实际上我应该是在我的服务端去创建一个平台券去发送发送以后是绑定的一个消息表，用户去登录之后时间做消息给拿到，这个没有销就是没有去领取的优惠券就好了。你分批发你怎么分配发一个通过。他这个他问的这个意思我可能大家明白啊他意思，就是说我现在有一个用户对吧？嗯我想去发优惠券，其实我我理解一般正常来说都是别人自己去领取的，一般都是您给我钱，就我自己去看了一个广告，嗯然后他去领优惠券，然后优先可能会捡捡那个库存对吧？
	比如我发1万发1万张对吧？我自己去领，就说他可能我不知道他问的这个意思，为什么去发优惠券，我一般没见过别人是发不都自己领的，嘛对，然后领完了把那个优惠券库存减一嘛对不对？减减一个嘛对吧？你也可以不你也可以不主动领，嘛你反正进去以后直接谈给他就好了。就直接拉了一个提示框。其实对刚刚有说就微博的那个流那个肺的瘤是一样的，实际上你的微博消息也是一样，你你1亿的粉丝我发一条消息，我不可能给一位用户，他都是用户登录之后直接主动去拉取那个流。有个广告一个广告广告页面有个广告页面，对对对。周总牵头在线，陆总先。卢总监还在直播。吧那个老师那个面试宝典我看完之后，我真的是我我都怂了，呀我的我都怕了，为什么？我立马真的去面试调到各种面试官。你可以随便弄2000多亿。可以随便问。嗯视频中提到的全网首发50万字面试宝典，有想要的小伙伴评论区置顶，可以免费领取。
40-【Java面试】秋招面试题：线程池中 shutdown()和 shutdownNow()方法的区别？-480P 清晰-AVC
	现成池中的虾子弹方法和虾子弹null方法的区别。Hello大家好，我是酷泡科技联合创始人麦克，今天给大家分享一下这个问题的回答思路，另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，能够帮助你们提升80%的面试通过率，这个问题并不难回答。但是如果我是面试官，还会进一步去深度考察底层的实现原理，这就给了很多自以为对线程池理解很透彻，并扬言看过现在是原码的同学当头一棍，单纯想通过刷面试题去找到工作，这个事情本身就不太现实。所以建议屏幕前的粉丝要专注在技术的系统学习上，可能大家都习惯了短平快，不需要长期艰苦的付出，就能快速拿到自己想要的结果。这个在当下Java市场中已经不太可能了，想要获得更多的回报，就得需要与之匹配的付出。下面我们来看一下这个问题的高手回答，下蛋和瞎蛋闹。这两个方法都是用来关闭现实的。瞎子荡这个方法会使得线程池状态变为关闭状态，意味着不再接受新的任务，但是已提交的任务会继续执行直到完成，因此啊 shutdown并不会立即停止现实中的工作线程，它只是停止了新任务的提交，一旦所有的任务都执行完成，那么现在持这种工作性能就会自动退出。
	简单来说呢它是一种优雅停止现顿式的方法。在内部的实践中，线人池用到了aqs同步状态来判断当前是否有正在运行的线程。瞎子档这个方法在执行限制中断之前会去竞争这个同步状态，从而去避免强制中断带来的任务执行不完整的风险。下蛋no，这个方法他会尝试立即停止所有正在执行的任务，暂停等待的任务，并返回正在等待执行的任务列表。在内部的实践中，呢它是通过调用线程的英特rap的方法来停止线程的，这个方法依赖于工作线程对于这个终端的响应特性，不保证能够立即停止正在执行的任务，但是会尽力去做。所以这个方法类似于一种暴力停机的实现。所以在实际开发过程中，我们尽可能使用下档这个方法去保证现实的优雅中断，来确保任务的完整性。以上就是我对这个问题的理解。我是麦克感谢大家的点赞和收藏，我们下期再见。
41-【Java面试】什么是微服务，说一下你对微服务的理解？-480P 清晰-AVC
	什么是微服务？说一下你对微服的理解。Hello大家好，我是麦克。一个工作了14年的Java程序员，今天给大家分享一下面试过程中遇到这个问题，我们应该怎么去回答。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字的面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在评论区的置顶中去领取。一般面试过程中问这个问题有两个目的，第一，是否真正理解微服务架构的特点和概念。第二，是否具备系统设计和架构能力，能否根据具体的业务场景和需求去设计合适的微服务架构。我认为这种问题千万不要通过死记硬背来回答，这样容易导致回答思路比较混乱。建议可以先理解，然后再总结成自己的语言去回答，把一些关键点回答正确，基本上就差不多了。微服务呢是一种架构风格，我们可以把应用程序划分为一组小型的松散耦合的服务，每个服务都运行在自己的进程里面，并通过轻量级的通信机制来进行通信。每个服务都可以独立部署，独立扩展、独立更新，从而提高了应用程序的可伸缩性、可维护性和可测试性。由于微幅呢是属于分布式架构下的一种针对应用架构的一种设计风格，所以我们会面临到分布式架构下的一些服务治理的复杂问题，因此是spring官方提供了一套spring cloud的解决方案，帮助我们快速实现微服务的技术方案的落地。
	以上就是我对微服的理解，如果你喜欢这个作品，记得点赞和关注，我是麦克，我们下期再见。
49-【Java面试】高频面试题：Spring Bean如何保证并发安全？-480P 清晰-AVC
	Spring如何保证并发安全性？这个问题是一个工作了，三年的粉丝私信发给我的，我觉得很多同学都不一定能回答出来。Hello大家好，我是酷炮科技联合创始人麦克。今天给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，能帮助你们提升80%的面试通过率。这个问题还挺重要的，因为在目前基于成熟框架下做技术开发，让大家对于很多Java基础有关的东西啊不需要过多关注，所以有可能会在无意中写出一些存在潜在安全漏洞的代码。我们知道默认情况下spring中的病是单立的，所以在多先生并发访问的时候，有可能会出现现场安全性的问题。而这个问题就是考察求职者对于此病病的作用，欲线程安全设计和实现依赖注入和管理，以及是对框架提供的并发安全。面试官可以评估求职者在并发编程领域和spring框架应用方面的知识水平。下面我们来看一下这个问题的回答。关于这个问题啊有几个方面的解决思路。
	第一，我们可以设置病的作用域，设置为圆形模式，这样的话每次从容器中获取病的时候，呢都会创建一个新的实力，避免了多线程共享同一个对象实力的问题。第二，在不改变病作用的情况下，可以避免病中存在一些可变状态的声明，我们可以尽量将状态信息存储在方法内部的局部变量中，或者使用线程安全的数据结构，比如康康的哈希迈克来管理状态，使用Java并发编中提供的同步锁机制来保证并发安全性。比如用新口net关键字或者与安静的rock来控制对共享状态的访问，从而去确保在同一个时刻只有一个线程可以去修改状态。以上就是我能够想到的几个常规的思路，感谢大家的点赞和收藏，我是麦克，我们下期再见。


46-我，211。工作了14年的Java架构师，讲述Java行业的焦虑！-480P 清晰-AVC
如果你不信被裁，以你目前的能力水平能找到工作吗？如果你在公司想要涨薪，你的老板会同意吗？Hello大家好，我是麦克。一位工作了14年的Java程序员，从最近粉丝的留言中，啊我能感受到大家普遍都比较焦虑，失业的，跳槽的都想把握住年后的求职小高峰，找到一份满意的工作，同时又对自己的能力呢没有信心，不知道该怎么去准备，比如这位粉丝他被裁员找不到工作，转行做起了销售，最近呢想重新面试啊找工作。还有这位粉丝，他提到两次涨薪的需求都被公司驳回了，他很不爽，问我到底要不要跳槽，我一直在跟大家强调，求职之前啊一定要先做好面试准备，应粉丝的要求啊给他准备了一套Java程序员求职突击手册，里面包含简历模板，热门面试题，谈心参考，一周面试突击课，全套Java学习资料，这份文档呢可以帮助你节约时间，最大程度提升求职效率。需要的小伙伴一键3点以后在评论区留言领取。如果你咨询压力比较大或者时间比较紧张，需要在短期内快速找到工作，我们也有一套完整的解决方案，包含技术诊断、定制化学习计划、技术提升技巧、项目重构、求职辅导、就业内推，完全以求职为方向，学完掌心至少提升30%，有需要的小伙伴可以在评论区置顶中去咨询。
	好的，今天的分享就到这里。我是麦克。我们下期再见。
44-程序员必看！！计算机行业所有值得考的高含金量证书，不走冤枉路!-480P 清晰-AVC
	建筑行业有一件，金融行业有CPA和CFP，那计算机行业有哪些能够成为我们职场砝码的高含金量证书呢？Hello大家好，我是麦克。这期视频啊我就给大家介绍一下，计算机行业含金量超高的几个权威证书，并且从企业的认可度、福利补贴、职业发展等多个维度去进行一个全面的梳理和分析。第一，计算机技术与软件专业技术的资格，简称软烤，是国企事业单位中含金量认可度最高的证书。他既是职业资格考试，又是职称资格考试，只要拿到中高级证书就可以直接ping任工程师职务。另外它还有积分落户抵扣个税技能补贴，提高退休金待遇的福利，并且这个考试没有学历和资格等限制条件，只要技术能够达到要求就可以报考，并且考取以后终身有效。第二，计算机程序设计能力考试，简称pat主要考察的是算法能力，pet的考试分数可以直接作为pet联盟企业的介绍性，只要你达到pet联盟企业规定的相应评级和分数，就能够跳过学历的门槛，直接免除筛选简历笔试环节，从平台拿到介绍信，直接进入面试，而且 bat联盟企业目前已经超过了200多家，包括许多国内外的头部大厂，比如谷歌、百度、华为、腾讯、网易等等。
	第三，项目管理专业资格认证，也叫PMP认证和敏捷管理专业人士资格认证叫act认证。这两个都是由pmi发起的，在全球近200多个国家和地区都得到高度认可，是含金量最高，国内认可度比较广的证书。如果你想从技术转型到管理，那么这两个证书是必须要具备的，和前面没有报名限制的增速不一样，这两个证书的报考条件相对比较严格，有年龄限制，而且还需要有指定专业机构的学习时长。另外这两个证书的有效期限只有三年，这三年内要攒够35个培训学时才能续证。最后我想跟大家强调，证书是官方和权威机构对我们能力的认可，它能够帮助我们去打破一些阻碍，拿到职场向上的机会。但是我们也要明白，这只是辅佐我们能力的方式，而不是能力本身。所以大家千万不要本末倒置，对程序员来说，啊只有硬技能才是职场唯一的必杀技。我给大家准备了一份Java学习路线图，里面包含了新手小白到资深架构师的完整学习路径，你们可以根据这个路径啊去拓宽强化自己的技术技能，有需要的小伙伴可以在我的评论区的置顶中去免费领取。今天的视频就分享到这里，我是麦克，我们下期再见。

下面是录音转文字，帮我把所有的错字，转换错的地方，全部转换出来， 直接输入修改的文本，其他都不用做：47-【Java面试】为什么Zookeeper集群的节点都是单数？-480P 清晰-AVC
	为什么猪keep集群的节点都是单数，这是一个很常见的面试题，但是很多同学回答这个问题的时候都回答不完整。Hello大家好，我是酷跑科技联合创始人麦克，今天给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，能够帮助你们提升80%的面试通过率。这个问题呢考察求职者对于猪keep集群的深度理解，涉及到集群选举投票和判票的机制等等。我们都知道猪keep集群的最小数量至少是三个节点，分别对应一个leader和两个follow，这是一种典型的带中心节点的集群架构，leader负责事务的处理和数据的同步，follow节点，负责数据的查询，以及当leader出现故障以后，follow节点需要被选举成为新的leader，继续对外提供服务。实际上在做k吧集群中还提供了一个observe节点，这个节点不参与到整个集群的选举和投票中来，只负责对外提供数据的查询功能，可以用来提高集群的数据查询性能。
	所以为什么猪keep集群节点一定是奇数？下面我们来看一下高手的完整回答。猪keep集群设计为基数，节点主要是为了容错和选举的需要。猪keeper在设计的时候采用了一种叫炸b的一致性协议，为了保证系统正常运行和服务的可用性，暂保协议需要大多数节点正常运行，也就是少数服从多数，这个我们称为过半机制。如果朱k的集群中有n个节点，那么至少需要n除以2+一个节点去正常运行，系统才能够正常对外提供服务。所以对这个问题来说，我认为有两个原因，第一，偶数节点并不能提高系统的容错能力，反而会增加系统的开销。假设我们有三个节点，那么按照过半机制，整个集群中最多能够容忍一个节点宕机，如果有4个节点，集训中依然只能容忍一个节点当机才能满足过半机制的判定条件。第二，当集群在进行leader选举的时候，如果节点的总数是偶数，就有可能出现两个子集各占一半节点的情况，从而导致选举无法正常进行。但如果节点总数是基数，就不会出现这个问题。
	以上就是我对这个问题的理解，我是麦克。感谢大家的点赞和收藏，我们下期再见。
42-【Java面试】高频面试题：Hash索引和B+树索引的区别？-480P 清晰-AVC
	叉7索引和b加速索引有什么区别？这是一个工作了4年的粉丝反馈给我的一个小米金融一面的变速真题，今天给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，能帮助你们提升80%的面试通过率。要回答这个问题。首先需要知道哈希索引和b加速索引这两个索引的特征和原理。先来了解一下哈希索引，哈希索引的结构和哈希map的结构呢有点类似，剑指p通过哈希映射到一个8k的桶里面，在这里面痛指的是一个能存储一个或者多条记录的存储单元，一个桶的结构包含了一个内存指针的数组，桶中的每行数据都会指向下一行，形成一个列表结构。当遇到哈希冲突的时候，会在桶中进行建筑的查找，采用哈希进行检索的效率非常高，基本上一次检索就可以找到对应的数据。B加速索引结构是一个多路平衡数，它的特点是根节点和分支节点只保存索引，所有的数据都存储在叶子节点中，叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小，从小到大顺序组成的一个双向链表，基于这样一个特点，使得b加速的高度在3~4成左右，就能够实现千万级的数据存储，以及适合对于组件范围的查找和分页查找。
	理解了这两种索引结构的特点后，再来看一下这两个问题的回答思路就很清楚了。哈希索引和b加速索引的区别我认为有几个方面，第一，哈希索引使用的是哈希表结构，他将索引键的值通过哈希函数映射到一个固定大小的桶中，然后在桶内进行查找。B加速索引使用的是多路平函数的结构，将索引键的值按照顺序存储在数节点中，并通过节点之间的指针进行查找。第二，在查询效率方面，哈希索引在等值查询上具有一个很好的性能，可以在常数时间复杂度内直接定位到目标记录，但对于范围查询和排序操作，哈希索引的性能会比较差。B加速索引在范围查询和排序操作上更加高效，因为它是按照顺序存储的数据，可以有效的支持范围查找。第三个，哈希索引对于磁盘存储的利用效率不高，因为桶之间的数据分布是随机的，可能会导致磁盘的随机访问，而b加速索引节点是有序存储的，有利于磁盘的顺序访问，减少了磁盘io的次数，提高查询效率。最后哈希索引在插入和删除操作上相对比较简单，只需要通过哈希函数确定筒的位置并插入或者删除记录即可。
	而b加速索引的插入和删除操作需要维护数的平衡性，可能需要进行节点的拆分和合并，相对来说会更加复杂。以上就是我对这个问题的理解。我是麦克我们下期再见。
48-【Java面试】AQS唤醒节点时，为何从后往前找？-480P 清晰-AVC
	Aps唤醒节点的时候，为什么是从后往前去找的？我敢说没看过aqs源码的同学，可能连这个问题都听不懂。Hello大家好，我是菇泡科技的联合创始人麦克，今天给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，能够帮助你们提升80%的面试通过率。这个问题可能很多人听不懂。我先来解释一下这个问题的背景。A QS呢是Java并发编程中一个非常关键的组件，它是用来构建锁和其他同步工具的一个类，内部呢使用了一个双向链表来管理等待锁的线程。对立的投节点呢通常是当前获得所的县城，而其他县城按照请求所的顺序啊排在后面。当霍德所的县城释放锁以后，就会唤醒头节点的下一个节点，这是一个正常的实现逻辑，但是呢在源码中多了这样一段代码，如果头节点的下一个节点出现异常，比如说状态不对，或者 a QS的设计呢是从队列的尾部往前去查找，直到找到一个有效的可以被唤醒的节点。
	而这个问题就是考察这部分的逻辑，为什么要从后往前找，而不是继续沿着头节点从前往后找。了解这个问题的背景以后，呢我们再来看一下这个问题的完整回答。关于这个问题我认为可以从两个方面来回答。第一，存储在双向链表中的任意一个位置的线程，都有可能出现县城中断，导致这个县城从队列中去移除。如果从前往后找，那么在并发场景中呢就可能出现一个空的节点的问题，导致无法实现有效的现场唤醒，出现死锁的问题。第二，a QS在初始化同步队列的时候，是先通过这样的代码，先构建指向前驱节点的指针，再通过这样一个代码去构建后继节点的指针。所以在并发场景中，从后往前查找，一定能够找到一个有效的节点。总的来说，a QS在唤醒节点的时候，从后往前走，主要是为了找到一个有效且可以被唤醒的节点，来保证并发程序的效率。以上就是我的理解。我是麦克。感谢大家的点赞和关注，我们下期再见。
45-【Java面试】为什么垃圾回收要分Eden区和Survior区？-480P 清晰-AVC
	为什么垃圾回收要分一等区和色yy区？一个工作6年的Java程序员，既然这个问题没有回答出来，hello大家好。我是酷爆科技联合创始人麦克，今天给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，能够帮助你们至少提升80%的面试通过率。如果你想进入互联网公司，这个问题呢基本上90%的概率会被问到，它是jvm里面一个非常基础的问题，没有回答上来的同学确实要反省一下，这个啊是Java8版本的运行时数据区，在这个图里面我们可以看到hip对内存的空间划分为一样区和o的区，其中样区又划分为一等区，survive from survivor to。如果大家在学习GB运行数据区的时候，主动去思考过这个部分的设计，那么这个问题就比较容易回答了。下面我们来看一下这个问题的高手回答。Gvm垃圾回收采用了分代回收策略，用这种策略的原因主要是基于两个重要的观察结果。
	一，大多数对象的生命周期非常短。第二，老的对象会引用新对象，但是新的对象很少会引用老的对象，而分袋回收的具体工作流程是这样子的。当新的对象被创建好以后，他们首先会被放在一等区，当一等去满了，就会触发一次迷冷GC，在这个过程中呢存活的对象会被移动到蛇WiFi区。为了平衡seven区的使用和避免内存的碎片，Java虚拟机会在两个serve区之间进行来回复制，每一次mini及时以后，仍然存活的对象会被复制到另外一个神玩偶区，直到达到GC年龄默认15次以后，移动到老年代，通过这样的设计以后，迷恋GC，只需要处理新生代的内存空间。由于新生代通常小于老年代，所以mini7c的时间相对比较短，同时啊大部分对象的生命周期又非常短，所以每一次迷你GC都能回收大量的空间，从而大大提高了垃圾回收的效率，避免了对整个堆内存进行频繁的腹肌c以上就是我的理解。我是麦克。感谢大家的点赞和收藏，我们下期再见。
51-【Java面试】高频面试题：高度为3的B+树可以存放多少数据？-480P 清晰-AVC
	高度为3的b加速可以存放多少数据？嗨大家好，我是工作了14年的加号程序员麦克，这个是蚂蚁金服第二面的面试真题，据说很多人没有回答上来，今天正好有空给大家分享一下这个问题的回答。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在我的评论区的置顶中去免费领取。B加素呢是一棵多肉平衡树，它的特点是通过减少非叶子节点的存储数据量以及增加数的分支数量，去降低速的高度，总要减少磁盘io次数来提高数据的检索性能。面试官通过这个问题去考察求职者对于b加速存储特性的一个理解，求职者应该对b加速的基本原理和特点有一定的了解，并能够解释低加速的高度和存储容量之间的关系。同时这个问题也是在考察求职者是否具备数据库性能调优的经验和能力，以及是否能够在实际工作中优化索引设计和查询性能。下面我们来看一下这个问题的完整回答。低加速的高度和存储数据的关系取决于索引的大小，数据也大小这样一些因素。
	在max口中b加速的每个节点都是一个数据页，数据页默认大小是16KB，非叶子节点存储的是索引值以及叶的偏移量，而叶子节点上存储的是完整的每一行记录。由于这个问题里面有很多变量都没有讲清楚，所以我们只能基于一个假设来做一个分析。假如一行数据的大小是一k那么理论上一页就可以存放16条数据。再假如我们的组件ID是big in类型，那么它的长度是8个之间，而指针大小在in的DB中预计会占用6个字节，那么这样一来我们就可以计算每一个数据页的纸的数量，最终可以得到1170个指针，一个指针指向一个存放的记录页，一个月可以存放16条数据，那么一颗高度为二的必加速就可以存放1170×16=18,720条数据。同理高度为三的b加速就可以存放通过这样公式计算出来的数据条数。所以理论上来说b加速的高度在2~4成左右，就能满足千万级别的数据量存储。当我们基于组件查询数据的时候，最多只需要2~4次磁盘io，以上就是我的理解，如果你喜欢我的作品，记得点赞和收藏我是麦，我们下期再见。
50-【Java面试】高频面试题：MySQL自增ID用完了会怎样？-480P 清晰-AVC
	麦c口自增ID用完了以后会怎么样？嗨大家好，我是麦克，一共做了14年的Java程序员，今天给大家分享一下面试过程中遇到这个问题我们应该怎么回答。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在我的评论区的置顶中去领取。在绝大部分的企业开发中啊一个表的主键Idi基本上都是采用数据库的OPPO increment来实现的。对于一个硬的类型的无符号自增ID，最大能够存储的数据量是20多个亿，当达到最大值的时候，ID就不会是真了。最后就会出现组件冲突问题，导致数据无法插入，实际上一个表不太可能会存储几十亿的数据，因为这么大规模的数据量要实现数据的查找和插入的性能是非常低的，所以面试官想通过这个问题去考察求职者对于数据库设计和管理方面的理解，以及对于数据库性能优化的一些思考，同时啊从这个问题中还可以考察求职者对于错误处理和故障恢复相关的一些理解。下面我们来看一下这个问题的完整回答。
	Max口制成ID用完以后，呢后续插入数据的时候，ID不会再递增，从而就会导致出现组件冲突，使得数据无法正常保存。这类问题一般不会出现，因为即便是intel类型的组件也能存储20多个亿的数据量。假设真的存在这样一个问题，我认为有几个解决思路。第一可以在设计前期就考虑这个点，把ID的数据长度设置更大一点，比如说用big燕子，第二我们可以不使用自证ID，而是采用业务组件，这样在后续做分表的时候会更加方便一点。第三，假设啊已经存在这样一个瓶颈了，那么可以考虑把数据迁移到新的表或者新的数据库里面，然后重置自己ID的范围，但是这个过程呢需要谨慎处理，从而确保数据一致性和业务逻辑的正确性。好了，今天的分享就到这里，我是麦克我们下期再见。

31-【Java面试】10分钟彻底搞懂Java中的各种锁！-480P 清晰-AVC
	这个问题讲清楚之后，锁这一块以后，所有的锁相关的问题我们全都能解决。很多同学说老师我备了很多锁，但是我在面试的时候还是搞不懂锁到底有哪些东西。学了很多锁之后，我发现这个锁越搞越模糊，是不是？说到锁的时候，我们一定会想到很多东西，比如说星空night。Lock。Rey安全的loc。分布式锁很多锁的类型。那么首先我们要知道一个点，所分什么类型，锁到底解决什么问题的？所解决一个问题，它的一个现场安全问题。所谓现场安全问题分三个维度，原子性、可见性、有序性，我们在多线程开发里面涉及到的现场安全问题是原子性、有序性、可见性。而scolite这个同步关键字，它是可以去解决我们在软件开发过程中，在多线程开发领域中涉及到了现在安全问题，这个都可以解决。那么我们讲到的这个安全问题，在实际开发过程中，就是怎么样去体现的？我们在这里面举个例子，比如说我们这里面有一个int类型的I的值，这个值呢存在我们的主内存里面，如果我们当前有一个数据在组内存里面叫inter I等于1，那么我们当前有两个县城，思锐的一线程一和three的二，现在二两个线程，同时去执行一个a加加的操作。
	请问一下这个时候这个结果是多少？这个结果它是一个小于等于2的值，为什么？因为 a加加这个指令它是非原子指令，如果你们学过并发的同学，你们一定知道 a加加其实是由三个指令组成，I加加在我们Java里面是一个指令，但是它最终转化成底层的汇编指，这时候是三个指令，他要先从内存加载I的值，第二个是对I进行一个递增。第三个是把这个 I的值写回到内存里面，是三个部分，get摩的find和。好，然后同样这边I的值也是一样，这三个操作同时执行的情况下，就有可能说两个线程同时拿到I的值等于0，那么拿到I等于0的操作做加加的操作的时候，它的结果等于多少？=1。他把一写回去，同样的道理，线程二可以并行执行，这个地方我会先把这个底层的铺垫部分讲清楚，所以大家认真听。那么这里面我们会存在一个这样一个情况，就是两个线程修改I的值的时候，它最终的结果可能是等于一，也可能等于2，所以它的结果不确定，问题出在哪个地方，呢问题出在于a加加这个指令是非原子的。
	所以我们在这种场景里面需要加锁，需要加同步锁，也叫排他锁。这个面试题呢在我的那个面试文档里面也是有的，如果你们没有领到那个35万字面试文档的话，点头一下进粉丝群去找那个群管理去领就好了。我们自己加个同步锁，这个同步锁起到什么样的作用？呢因为刚刚出现I等于一的这个情况，是因为两个线程同时执行，去同时拿到I的值，能不能够让县城从并行变成串行？呢能对吧？我们加同步锁，同步锁的一个特点就是多个现场访问这个共享资源的时候，在同一个时刻只允许一个现场访问，这个共享资源，这是同步锁的特点。这样的话我就能够去解决所谓的原则性问题。锁这个部分在Java的并发编程里面只有两类，第一类是叫共享锁，第二类叫排他锁。从功能层面来说只有两类锁，能理解吗？共享锁我们也称为叫独锁，毒所的特点就是允许在同一个时刻允许多个县城抢占到锁牌，大锁我们也叫斜锁，解锁是在同一个时刻，只允许一个县城访问这个共享资源，这是我们的锁的类型。
	在家我里面你们只要记住这两类锁就行了。那么有些同学说老师，我们刚刚还接触了什么？悲观所乐观所、自选所。第二个维度，再来拆分一下枷锁会存在什么问题，枷锁会存在性能问题。刚刚那个例子里面，枷锁就使得由并行变成一个串行。那么你们觉得病情的效率高还是串行的效率高？一定是并行对不对？所以枷锁会造成阻塞，所以我们在软件里面会考虑一个点，性能和安全性都照顾到。举个最简单的例子，库存这个事情库存扣减既要保证性能，是不是又要保证现成的并发安全性？我要保证它原子性的一个修改，对不对？那么我们在这个层面上来说，怎么去优化它，做好这个平衡？刚刚有同学说到一个无所化编程，这是一个一个思路。还有一个点，锁力度的优化，控制锁的力度的优化层面上，我们会去做一些什么事情，呢就是把锁的范围缩小，只需要去保证这个所的竞争的范围，在我的目标的需求范围内就好了。第二个，刚刚有的同学讲的唉能不能无所化编程，5所编程里面涉及到一个什么点？乐观所。
	乐管所是没有枷锁的，热管所是通过一个数据的版本来去控制多线程并发的一个数据修改的安全性，这个叫无所编程。也就是说我们在不枷锁的情况下去保证安全性，刚刚有人觉得case case它也是一个无锁的操作，它能够保证原子性和可见性。好，这个叫无所编程。那么除了这个优化以外，还有没有优化？星空袋子里面你们有没有听过偏向锁，轻量级锁和重量级锁？偏向锁轻电器锁重点锁到底是什么？首先我们要去了解枷锁的本质，枷锁实际上是去竞争一个同步状态，比如说我是一个0和1来表示有锁和无锁状态，所以我们去抢占锁的时候举个例子，啊比如说我们这里面有一个叫麦克点t ST，两个线程之类的一，思锐的二，我们在这里面加一个锁去保护麦克点txt，这个资源，保证多线程去访问麦克点txt，这个资源的修改的时候的安全性。我们加了锁，那么枷锁是去竞争一个访问资格对不对？也就是说能够具备访问资格的县城，才能够去访问麦克的txt，那么我怎么知道你有资格，我们是不是可以通过一个非常简单的道理，就是我们在生活场景里面，我们看到的很多站位的状态，比如说0和1或者说红绿灯，那么我们是不是有一个叫标记？
	这个标叫什么？呢叫同步状态，叫静态变量。同步状态就是比如说我们去定义一个int类型的 state等于0或者1，那么我们去表示竞争琐事，竞争这个同步状态。如果斯瑞德一进入这个锁的访问的时候，他先去把state修改成一，如果零表示空闲，一表示繁忙，那么我把它改成一，那么three的二在进入这个锁的判断的时候，只要去判断当前这个 State是不是等于一就行了，这是竞争所的本质，就是去竞争一个同步状态。星空net里面是怎么去实现同步状态的？在sequel里面通过操作系统层面的吗txt机制，这个Mark是什么？Mark操作系统层面的一个机制，我们去通过竞争马太师的机制去实现一个互斥的状态的一个处理，而这个是内核层面的东西。线程一和二去竞争吗？探索的时候它会涉及到一个内核指令的调用，因为吗txt这个是操作系统层面提供的一个互斥的一个机制，所以我们可以去通过内核指令去调，用这个机制来实现这个互斥的一个竞争的一个行为。
	所以这个地方就会涉及到一个什么呢叫用户态到内核肽的切换，这个切换会占用CPU资源，会消耗性能，为什么会消耗性能？因为用户线程要阻塞等待，然后要切换到内核线程运行，那么我需要把当前运行的现成的执行的指令的上下文要保存起来，同时要切换到内核线程去执行这个指令。所以这里面就会涉及到现成的主受唤醒以及上下文的保存，这个地方会消耗性能。第二个点线程二假设竞争到了锁，那么线程一需要干嘛？线程一需要阻塞等待。所以在这个情况下，在这个地方去枷锁的时候，会造成一个性能的影响。性能体现在什么地方？性能体现在两个部分，第一个竞争同步状态的时候，涉及到上下文切换，也就是用户它的内核态切换。第二个现成的阻塞和唤醒也会涉及频道切换，也会涉及到性能影响。还有第三个就是我们的从从并行到串行的改变，那老师有没有优化的方法？有，就是这个东西无法改变，对不对？那么我们能不能够改变上面两个部分呢这个也改变不了，因为你竞争到同步状态的时候，一个静态条件就是基于吗txt来实现的，所以这个也无法改变。
	所以这里面我们要关注一点，就是现成的主色唤醒会涉及到切换，这个地方的切换能不能够去避免？也就是说线程二竞争到了锁，第一个县城能不能够说不去阻塞等待，能够去竞争的所有有没有这个可能性？有。就是我能不能够让线程一在主摄之前进行从事，能不能？能对不对？从事就是我第一次尝试枷锁，我发现当下这个建成二已经获得所对吧？那我ok进入下一次循环再从事，所以我们突然发现唉这个地方叫自旋锁。什么叫自旋锁？就是通过一定的自旋的尝试去竞争所支援。这个部分在我的那个30万字面面试文档里面是有那个回答的，点头像进粉丝群去领取就好了。所以县城一可以从事去竞争，所那么县城一相当于是说在阻塞等待之前，通过从事去竞争所这个叫自选锁，也叫轻量级锁。所以我们讲的是轻量级锁，轻量级锁就是在枷锁之前去进行从事，如果线程二这个时候突然释放了锁，呢那我有没有可能抢到？能抢到。我们再往前看，有没有可能出现这样一个问题，就是我们加勒索的代码它不存在竞争，当然有可能。
	我们枷锁是保护这段代码的限制安全性，但是有可能在实际开发过程中这段代码就不存在竞争。就像我们写的CTRL里面判断请求参数是一样，客户端层面它不太可去传递空值过来，但是有可能因为我前端做了校验，但是我后端程序要保证安全性和稳定性，所以我需要去判断传过来只是不是为空，那么这个叫防御性编程对吧？所以这个时候如果没有竞争的情况下，我枷锁还有意义吗？没有锁的竞争的必要性就不存在了。所以这个时候我们能不能引入一个所去实现这个功能，呢所以就引入了偏向锁。什么叫偏向锁？就是当县城一进入这个所的时候，如果当前不存在竞争，那么他就会把这个锁偏向于线程一，那么县城一下次进入的时候，它就不再需要竞争所，这就要减少了竞争，所以偏向索你可以认为没有竞争，而轻量级锁存在轻微竞争，而重量级所才是最终我们枷锁的一个实现方式。所以偏向锁到轻量级的重力锁这个逻辑是干嘛？是去让线程阻塞，减少锁的竞争。我们继续往下讲，刚刚有同学老师在家网jdk里面还引入了一个优化，叫锁消除和锁膨胀，这是编译器层面的优化。
	这个优化什么意思？就是你可能写的这种代码本身就没有限制安全问题，但是你加了锁，然后gpm去编译的时候，发现唉这个地方加勒索导致了一个无效竞争，那么他就把这个锁消除掉，就认为你没有枷锁，这叫所消除。锁膨胀是说你控制的锁的力度太小了，导致频繁的枷锁，频繁的释放锁，频繁竞争，所以他把锁的范围扩大，叫锁的膨胀，这是优化优化加锁的性能，那么有了这个机制以外，嗯还有没有其他的锁？有同学说那个读写锁，读写锁是什么？也是一种优化，读多写少，读操作不会影响数据的一个准确性，因为它不会修改数据，但是我们举个例子，在这里面有个public，我的开始的方法，如果在这个方法里面，大部分的操作都是去查询，一个查询操作要去竞争，所这个方式有没有可能优化？当然可以优化。查询操作要不要加锁，不需要加锁，所以呢读写锁也是一种优化，就是去针对足多写少场景里面，毒和毒不互斥，读和读不经常锁，而读和写血和血实现互斥，除了性能问题以外，还有什么？
	锁的特性。宠物所重入锁是什么概念？避免死锁的一个设计，就是一个县城抢占到了锁，在释放锁之前，再次去竞争同一把锁的时候，不需要主色等待，直接进入重试次数就好了。这个是一种安全性设计。防死锁设计，在Java里面大部分的锁都是可重入的，好，那么这里面我又想到一个东西，大家有听过公平锁和非公平锁吗？公平锁和非公平锁。这是性能优化的特性，同学们，我们知道默认情况下锁都是非公平的，比如说辛苦nice。为安全log，它都是非公屏的对不对？它为什么要设计成非公屏锁？因为非工兵所的性能要比工兵所的性能更好，为什么性能更好？呢因为非公平锁意味着减少了锁的等待，减少了现成的阻塞唤醒。然后锁的特性层面还有没有其他的锁，分布式锁对不对？分布式锁是解决分布式架构下的力度的问题，我们辛苦烂锁是解决家伙病房里面的线程维度，而分布所是解决进程维度，这是不一样的。所以这个是锁的特性。还有一个东西有有同学讲到了叫悲观锁，杯灌锁就是我们刚刚讲的这个强制枷锁这个机制，就是我认为所有的访问都是非安全的，所以我必须要先去通过枷锁来去进行访问，叫悲观锁。
43-【Java面试】余老师回答惊艳Mic老师！电商秒杀系统以及超卖机制，听好了，我只讲一次！-480P 清晰-AVC
	于胜军挑战业务场景，面试题，电商的秒杀机制老师，我觉得我觉得你你要考一些考一些业务场景问题，考效果，吧我觉得不要考八卦八卦，我现在真的忘光了。我要搞搞应用场景是吧？不是你要考虑业务场景的问题。业务才是什么？对，你不要考那些什么，唉呀谁来推动怎么做，呀你那你告诉我设计一个秒杀系统怎么做？秒杀这不讲难的东西，嘛这东西我说实在话，哪个如果是现在哪个面试官我秒杀，我他妈真的想想想拍桌子你知道吧，秒杀不是说实在话，现在哪个人不会秒杀，哪个不会秒杀抢购。是这样的，这不是别别讲那个东西。那你说一下。我就实在话，我跟你讲秒杀，我真的搞烂了你知道吧？你要杀的东西我说实在话没有没有意义，我讲秒杀一般是怎么做的，我先说一下我看我看这个粉丝，嘛你们说对不对？啊秒杀，抢购他一般怎么玩了？我给你我给你讲一下，你你们不要给别人讲，哈这是我一麻子独创的答案，哈哪一次今天如果哪个去面试的时候面试过秒杀，我真想拍桌子，为什么？因为这东西看见假象，秒杀抢购记清楚一点，啊因为我以前电商我我在电商公司待过的记清楚，嗯首先你要保先保证网页得先加得出来，一些素材加载出来，所以第一步先干嘛？
	做动静分离，要把静态资源放在这个 Cd上去好吧？嗯嗯打包，先让王新加的出来，是一个非常非常重要的事情。然后再是别人在进行访问，到我们这个接口的时候那干嘛，那这个就很重要了。就是怎么看高频发。那么这维度态度同学们第一点肯定是什么了？第一，你就尽量给他做安全，你不管安全，那立马别人直接攻击你，把你搞垮。呀我操所以呢第一步我们肯定服下做集群，要把我们的系变成这样的一个pose的形式，通过k来去运行，为什么？因为在流量如果非常大的情况下，我可以根据我们这个黑白s做弹性控和送。这第二点第三点，基本的买circle什么索引优化倒不用多说，然后还有什么就优化，海外的继续这个我就不多说了。最赚点是m是你的这个库存怎么做超卖？刚刚MAC老师问的这个把古文其实就在他的那个面试班都有一下。你面试班怎么拿，呀我我给你看一下我看一下啊这里面有这里面有那这里面那个消息推送这呢这个东西了，看到没？相信推送。有是吧？对点点头，像进粉丝群。
	不是你不要问那些罢工，有的东西我刚刚把你罢工看的，朋友们有粉丝没有领，把我们赶紧点击他的主页进粉丝群，领我们的麦克老师亲自手写的八国密室保险吊打密室官同志们，嗯那我想问一下那个那我想问一下这个麦克尔怎么怎么卖？不是这个事情是你你要回答。那我想问你怎么在上班我就不要你。我想看你答案我想看你答案。不是我我要向你请教这个事情，我不会不是我要向你请教，我要我要向你请教。那那个那个那怎么防止超卖了，我想问一下。或者是你先你先你先说一下你的想法，你不要不要超过了答案。我我不能先说为什么？万一我说说你你现在抄我答案的。我我我说你的不一样好吧？你先说你什么我你你你回答一个，我说你就你不不一样的好不好？我的意思是说啊你你你可以谈谈就是说为了秒杀最难的其实不是不是高频发，这段是抄卖给你的。当先指不定我的妈你吃不下人气，200多人，我他妈这么直接就五。六十个人，我的妈这个是你的没关系没关系没关系。真的是就就刚刚那个秒杀又涨了50个人。
	我的妈呀反正又涨了50。我的妈。呀不是你你为什么你问你为什么你你回答问题的时候大家会特别关注你呢？是不是你平时表现太少了？这几种也表现太少了。因为什么？啊因为别人会觉得很你我为什么每次晚上直播的时候人气很高，啊都是靠演戏，靠靠好好叫，别人觉得立马奇葩很逗，你太正常植物没人看懂，朋友们我就想问一下，当前直播间有没有粉丝会秒杀了吗？估计没哪个会，为什么讲？你不会的话你就乖乖的在麦克老师的主页进粉丝群，它里面有奖秒杀，我今天早上退背了，你知不知道？怎么做，防止超卖。啊就是用mq一不减库存或者分部锁，封锁这东西有点性能很低，不建议。我我我跟你们说一下怎么去怎么做，啊我跟你讲以前我们公司这样做的，比如你假设你当前库存是有1万个库存，对不对？有10万块钱，最简单方式怎么做？你直接先升级光令牌，用另外一种形式，10万人过来利润快的死，先抢托克令牌，强制工作，然后再进行减库存。想不到了。那行，那这就是相当于你相当于是加了一个一个一个一个现有了。
	对是的，就是这样的加那个东西姓牛。嘛听听。

54-【Java面试】场景题：1亿个用户，每个用户发放十个优惠卷，怎么做不会重复？-480P 清晰-AVC

	呃1亿个用户，给每个用户发放10个优惠券，怎么去不重复？这个问题我问的比较好，我觉得。提示直播间噢这假的啊噢这假的吓我一跳，1个亿用户给每个用户发10个优惠券，怎么保证不重放？你这里面首先你要解决的不是重发的问题，你要解决的是你可以怎么去发的问题。像这种这种大的用户，你你像你是全平台发的话，全平台化的话，你服务端去发送这个事情就不现实，你应该是客户端去主动去就调就是你的用户登录之后，去主动去拉取，拉去什么？拉去我的优惠券，那么我实际上我应该是在我的服务端去创建一个平台券去发送发送以后是绑定的一个消息表，用户去登录之后时间做消息给拿到，这个没有销就是没有去领取的优惠券就好了。你分批放怎么分配放一个用户。他这个他问的这个意思我可能大家明白啊他意思，就是说我现在有一个用户对吧？我想去发优惠券，其实我我理解一般正常来说都是别人自己去领取的，一般都是您给我钱。就我自己去看了一个广告，嗯然后他去领优惠券，然后优先可能会捡捡那个库存对吧？比如我发1万发1万张对吧？我自己去领，就说他可能我不知道他问的这个意思，为什么去发优惠券，我一般没见过别人去发，不都自己领的，嘛对，然后领完了把那个优惠券库存减一嘛对不对？
	减减一个嘛对吧？你也可以不你也可以不主动领，嘛你反正进去以后直接谈给他就好了。就直接拉了一个提示框。其实对刚刚有说就微博的那个流那个肺的瘤是一样的，实际上你的微博消息也是一样，你你1亿的粉丝我发条消息我不可能给一位用户，他都是用户登录之后直接主动去拉取那个流。有个广告一个广告广告页面就是广告页面，对对对。麦克老师的那个面试宝典我看完之后，我真的是我我都怂了，呀我的我都怕了，我为什么？我立马真的去面试调到各种面试官，你可以随便。弄2000多点扣。可以随便问。嗯视频中提到的全网首发50万字最新Java场景题，有想要的小伙伴，评论区置顶可以免费领取。
53-【Java面试】高频面试题：Redis突然变慢，有哪些原因？-480P 清晰-AVC
	Ready是突然变慢，有哪些原因？这是一道大厂的面试真题，这个问题很多5年以上的程序员都没有回答出来。Hello大家好，我是酷泡科技的联合创始人麦克，今天给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在我的评论区的制定中去免费领取，这是一道比较开放性的问题。因为影响瑞丽斯访问变慢的原因啊有很多，比如硬件资源、网络数据规模、参数配置等等，求职者需要从宏观视角去思考，并尽可能的去全面说出关键的影响因素，从而突出个人的架构故障排查和分析等方面的能力。同时还应该针对问题提出自己的一些解决思路，展现出对于release性能优化的理解和经验，从而去获得面试官的积极反馈。下面来看一下这个问题的回答，当release突然变慢，可能有很多方面的原因。第一，内存不足，当内存不足的时候，可能导致key频繁被淘汰，响应时间上升，qps不稳定等问题，甚至有可能导致瑞士崩溃，进而去影响业务的运行。
	比如内存的利用率，或者已逐出的箭数量和命令最大时延均呈现上升的趋势，表明存在内存不足。第二，频繁的说句实在话，如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘io操作，磁盘io操作变得缓慢或者频繁，会导致liest的性能下降。第三主色操作，某些race命令呢会导致阻塞，比如主测试列表操作，慢查询等等。当这些操作被频繁调用或者执行时间较长的时候，会导致整个系统的性能下降。我们可以使用reds的性能分析工具和命令来识别慢查询，阻塞的操作，并针对性的进行优化调整。第四网络问题，如果release与客户端之间的网络连接存在问题，比如网络延迟或者贷款受限，会导致呢 release的响应变慢，我们可以通过排查网络延迟情况来进行判断。以上就是我的部分理解，实际情况可能因为系统的环境和配置的差异，出现的问题原因和解决的方式也不一样。一般情况下使用red的监控工具日志和性能分析工具，可以帮助我们更快的定位和解决性的问题。今天的分享就到这里，我是麦克我们下期再见。
52-【Java面试】高频面试题：Redis大key怎么处理-480P 清晰-AVC
	Ready？中的大k应该怎么处理？Hello大家好，我是菇泡教育的联合创始人麦克，昨天啊一个工作了7点的粉丝去面试，被问到这个问题的时候呢没有回答好，错过了一个很好的offer。今天啊我正好有空给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的评论区的置顶中去领取，这是一个场景问题。在企业级开发中错误地使用raci，有可能会出现大Kae的问题。因此面试官主要考察求职者对于reds性能优化和存储策略的了解，reds中的大p指的是在race中存储的某个key对应的value、数据量很大的情况下，可能会出现的问题以及解决方法。最明显的几个问题是一内存占用，大p占用大量的内存资源，导致ready是实力的内存压力增加。2网络传输延迟，大k的读写操作可能会增加网络传输的延迟影响性能，持久化备份，大p的持久化备份需要更多的磁盘空间和时间。
	所以求职者应该在了解这几个基本问题的情况下，提出应对处理release中大k的策略，并能够解释每种策略的优劣和适用场景，同时求职者还应该去了解red中的数据结构和特性，从而能够在实际的开发中去选择合适的存储方案，并进行性能优化和资源管理。下面我们来看一下这个问题的回答。关于这个问题我说一下我理解的方法。第一，把大k分割成多个小k来存储，比如把一个大的哈希结构分割成多个小的哈希结构，每一个小的哈希结构代表一部分数据，这样可以减少单个k的大小，去降低内存的压力。第二，搭建raci Klus集群，把key分配到不同的哈希斯note草所在的分片上，这样可以降低单个rate节点的存储压力。第三，如果已经存在了大k可以做数据的拆分和迁移，按照业务需求和规则将大t拆分成多个小的t并分布到不同ready实。然后再迁移完成之后，清理掉不需要使用的大k最后我们可以考虑使用压缩算法去进行数据压缩，从而减少存储空间的占用。
	也就是说在存储数据之前对数据进行压缩，在读取的时候进行解压缩，以节省存储空间和减少网络传输的数据量。当然我们还可以从业务层面去进行分析，了解大k产生的原因，并根据需求和访问模式去进行相应的优化。比如使用更加合适的数据结构，优化业务逻辑的设计方法等等。以上就是我的理解。如果你喜欢我的作品，记得点赞和收藏，我是麦克，我们下期再见。
56-【Java面试】高频面试题：Arraylist与LinkedList有什么区别？-480P 清晰-AVC
	Airless和legalist有什么区别呢？Hello大家好，我是麦克。一个工作了14年的Java程序员，这个问题主要是考察应届生和工作一年左右的程序员，这两个集合都是我们在企业级开发中经常用到的。如果你不知道这两个集合的区别和它的底层原理，可以在我的评论区的置顶中去领取一个30万字的大场面是指南，这个指南里面包括这个问题的完整回答，艾瑞斯和那个 list呢是Java集合框架中类似接口下的两个实现类，也是我们经常使用的集合类，所以这个问题本身的难度非常低，不过呢也是考察大家对于这两个集合的理解，来判断在工作之余是否有深度的去思考过技术的本质。下面我们来看一下这个问题的完整回答。关于这两个集合的区别，我认为有几个方面，第一点内部的实现方面，艾瑞斯的内部呢使用的是数组的实现，通过索引来访问元素，支持快速随机访问，link的list，内部使用的是双向链表来实现，每个元素都包含一个指向前一个元素和后一个元素的引用，适合插入和删除操作。第二，数据访问的时间复杂度不同，艾瑞斯的时间复杂度是o一，也就是我们的常量复杂度。
	Link类似的需要从头部或者尾部开始遍历链表，直到找到目标元素的位置，所以它的时间复杂度是一个on第三空间占用方面，艾瑞斯呢使用数组来存储数据，所以占用的空间是连续的，可能会产生内存碎片。Linux呢通过链表来连接元素，每个元素都包含前后节点的引用，占用的空间会相对比较大。以上啊就是我对这个问题的理解。如果你喜欢我的回答方式，记得点赞和收藏，我是麦克，我们下期再见。
55-【Java面试】高频面试题：Redis keys命令有什么问题？-480P 清晰-AVC
	在race中执行case，这个命令会出现什么样的问题呢？Hello大家好，我是菇泡教育的联合创始人麦克，昨天一个工作了4年的程序员去某互联公司面试，被问到了这个问题，今天这样有空给大家分享一下这个问题的回答。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的评论区的置顶中去免费领取 rids中的kiss命令，用于返回匹配指定规则的所有键，类似于数据库里面的Nike模糊匹配功能。这个问题考察求职者对于的性能和可靠性的了解，以及对于ride使用的最佳实践的熟悉程度。求职者呢在回答这个问题之前，一定要先知道kiss这个命令可能存在的问题，并且能够提出对应的解决方案和最佳实践，从而更好的去获得面试官的积极反馈。很多小伙伴遇到这类问题通不过的原因就是回答过程很混乱，没有一个清晰的回答逻辑。下面我们来看一下这个问题的高手回答。使用kiss命令可能会存在几个潜在的问题。第一，性能问题，kiss命令需要便利整个red的键空间。
	如果瑞士中的t的数量非常庞大，便利过程会非常耗时，从而影响到性能。第二，阻塞问题。Kiss命令呢是一个阻塞命令，她会主摄所有其它客户端对于raid server的一个访问，直到kiss命令执行结束。因此执行case命令会导致VIP服务器可能会暂时停止响应其他请求，导致服务不可用或者响应变慢。在生产环境下一般是禁止使用kiss命令的，特别是在数据量较大的集群环境中，一旦因为kiss命令阻塞了red的操作，就有可能使得集群判断right出现故障，出现故障恢复的一个现象，引发数据混乱和雪崩等问题。以上呢就是我的理解，如果你喜欢我的作品，记得点赞和收藏，我是麦克，我们下期再见。
58-【Java面试】为何JDK9要将，String的底层实现由char[]改成byte[]？-480P 清晰-AVC
	为什么gdk9要将是菌的底层实现由恰数组改成by的数组呢？这个问题比较冷门，不过有个粉丝正好不幸被命中，错失了一次好的机会，hello大家好，我是酷跑科技联合创始人麦克，今天给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，能够帮助你们提升80%的面食通过率，我认为这个问题是值得大家去学习和研究的。面试官通过这个问题想考察求职者对于GDP版本更新性能和内存优化方面的了解，对字符编码的认知以及对代码兼容性的考虑，这可以评估求职者在Java技术和性能优化方面的知识和经验。我先说一下结论，gdk九并没有将string的底层实现由恰速度改成buy的速度，而是在GDP九中引入了一个康派的string的一个优化，这个优化的目的是减少失俊对象的一个内存消耗。在GDP中字符串在Java的string内的内部是有一个包含该字符串中所有字符的恰数组来表示。同时 gdk内部使用utf-16的编码方式，意味着每个字符恰由两个字节来组成。
	如果一个字符串只包含英文字符或者一个ask字符，那么我们只需要一个字节就能表示所有 Asif的一个场景，这就意味着字符串实际存储的空间要比需要存储空间多了一倍。为了解决这个问题，gdk九引入了康泰克斯逊的优化，这个优化将实训对象的字符串数组恰改成了buy的速度，只有在需要存储非ask字符的时候才会使用恰数组。对于纯20个字符串，他的字节表示可以直接存储在8级数字中，从而去截止了一半的内存空间。这个优化是在编译器和运行时环境层面来实现的，对开发者来说是透明的，不需要去修改现有的任何代码，我们只需要通过这样一个虚拟机参数来控制，是否进行优化就好了。今天的分享就到这里结束了，感谢大家点赞和收藏，我们下期再见。
57-【Java面试】高频面试题：@Component和@Bean的区别？-480P 清晰-AVC
	Complain的注解和并注解有什么区别？Hello大家好，我是麦克。一个工作了14年的Java程序员，关于这两个注解，可能很多小伙伴知道他们怎么使用，但是让你去面试的时候回答出来这个问题可能会有点难度，你不知道从哪个点切入，不知道怎么样去组织语言，那么如果你有这个问题，可以在我的评论区的制定中去领取一个30万字的大闪电视指南，里面有这个问题的完整回答，complain的注解和并注解在应用开发中啊用的非常多。康珀的注解是一个通用注解，可以用在于任何类上，包括普通的Java类业务逻辑组件，持久化对象等等。通过康波的注解呢 spring会自动去创建这个类的实例对象，注入到一个食品IOC容器里面。病猪检啊是用于配置类中声明一个病的，它通常是用在配置类的方法上面，表示把这个方法的返回对象注册到食品iOS容器中，通过并注解啊我们可以自定义病的创建和初始化过程，包括指定病的名称庄玉，依赖关系等等。下面我们来看一下这个问题的高手回答。对于这两个注解的区别，呢我的理解啊有几个方面，第一，它的用途不同，仓库的注解是用于标志于一个普通类，而并注解是在配置类中去声明和配置一个病对象。
	第二，使用方式不同，come on的出解。适宜各类级别的注解，Spreen可以通过carpoint scanned注解去扫描修饰的carpoint注解的一个并且把这些类注册到spring IOC容器里面，而病种解释修饰在方法层面，它是在配置类中去手动声明一个病的定义，第三控制权不同。康坡的注解修饰的类啊是由spring框架来创建和初始化的，并注解允许开发人员手动的去控制并的创建和配置过程，所以并注解在配置上呢会更加灵活一些。以上就是我的理解，如果你喜欢我的作品，记得点赞和收藏，我是麦克，我们下期再见。
59-【Java面试】粉丝提问：“查询表的一条数据，CPU会转多少圈？”-480P 清晰-AVC
	他说你查询一个表，一条数据，请问CPU转多少圈？查询表的一条数据，CPU会转多少圈？你能回答上吗？来我这边我等一下查询一个表一条数据，CPU大概赚多少钱，这个没意义好吧？这个这个问题问的没意义好吧？我再说一下这个没意义好吧？你说什么？我这个问题我先不我先不考虑，我觉得我觉得我觉得我这边没有没有哪几个人问的比较难点的问题。啊不是刚才那个什么问题。他说你查询一个表，一条数据，请问CPU转多少圈？这个问题你知道吗？查询一个表，CPU转多少圈？这个问题啊。那你的那个面8个面试包里面有没有讲过18股里面？这个问题我恰好知道，我恰好知道。赚多少钱。啊那个那个啥 CPU的它是通过那个时钟始终来去统计那个 Cpu的一个运转运转的一个效率的。所以我们呃 CPU能转多少圈呢？嗯所以我这个SQL语句他要查询的耗时，然后比如假设我一个CPU查询，在一个3G赫兹的CPU里面，它的这种频率的震动大概是3亿次。我的妈呀别别提前准备好多的牛逼牛逼牛牛逼，这面试宝典我看过的，在你第八道题有9对吧？你那你你那你那个密室宝典的话有这道题我记得讲过了是吧？
	有点屌。你当兵是宝典的话我问一下啊现在现在更新的到多少道题了，南屏是宝典。面试宝典我现在现在现在我们出了一本书，然后那个50万字面是我宝典就暂时没更新了。没更新啊那边吃饭怎么领？呢对进进那个进粉丝群就好了。你完之后能不能能不能吊打明史班？呢你看。我就是我就是你。视频中提到的全网首发50万字最新场景题，有想要的同学评论区置顶，可以免费领取。

60-【Java面试】高频场景题：limit 500000,10和limit 10速度一样快吗？-480P 清晰-AVC
	在sq语句的分页查询中，这样一个语句和这样一个语句的速度是一样快吗？嗨大家好，我是古堡教育的联合创始人麦克，这个问题是小米第一面的面试真题，被问到这个问题的人呢是一个工作了5年的Java程序员，今天正好有空给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的评论区的咨询中去免费领取。Limit，语句啊通常用来实现数据的分页查询，而这个问题呢算是一个挖坑的场景体，主要考察求职者对于数据库查询语句的优化和性能调优的理解。求职者要知道limit50万石和那边的石之间麦西口在进行运算的时候，它的底层实现机制雷米的50万10表示从结果集中的第五十万行开始，返回10行数据，name的10表示返回结果集中前10行数据，同时啊最好能够针对性能问题提出合适的优化建议，从而去获得面试官的一些好的反馈。下面我们来看一下这个问题的完整回答。
	雷米的50万和name10的速度差异主要取决于两个关键因素。第一数据量，如果数据库中的数据量很小，那么两个查询的速度可能相差不是特别大，但是如果数据库中的数据量非常大，那么莱美的50万会跳过大量的数据行才能够返回结果，而name的10则不需要跳过这些数据行。所以如果表中有和索引，那么使用lem的50万石的时候，数据库可以通过索引来直接定位到指定的行号并返回结果。而对于雷米的时，数据库只需要返回前10行数据就好了。但是不管什么因素，雷米的50万的查询速度肯定是要比雷米的10的速度要慢很多。而随着数据量的增加，前者的采用速度会更慢，因此我认为可以从两个方面来优化。第一，从CK语句层面优化，假设存在组件ID，可以先使用子查询的结果作为过滤条件，从第五十万行的组件值开始获取10行数据，这样可以跳过大量的数据行，提高查询效率。第二从业务层面优化，正常情况下很少会出现翻50万页去查询一下数据，做设计本身就会存在问题。
	如果涉及到大量数据翻页的查询，可以尝试做冷热数据的分离，减少热数据的查询量，或者针对运营要用到的数据做一次分析，形成固话表以后展示出来。以上就是我的理解，如果你喜欢我的作品，记得点赞和收藏，我是麦克。我们下期再见。
63-【Java面试】当场麻木！被问：“Java虚拟机坏了怎么修？”-480P 清晰-AVC
	讲讲我的虚拟机坏了怎么修。下训机坏了怎么训，你问我怎么知道了？又不是我设计的。群里群里气坏了，这个时候我的我的我是这么认为的。啊那我确定建议重启一个虚拟机。重庆期虚拟机是吧？这样虚拟机坏了怎么修我的妈。那刚刚我刚刚有个粉丝啊就问的那个灰度怎么玩，啊我跟你说啊灰度这个东西，呢你要么自己拿耐克斯加网关来搭，通过里面有有个叫做原数据做区分版本，你知道吧？或者拿k百s的k百达是最简单的，因为里面把你标记好了，晓得不？嗯有4IP有这个版本区分的晓得吧？是这样的，定式虽然是另一部方法，不是Java写的，是c写的，就是掉另一个函数，你把源码点开知道它不是加急的。底层都是帕克和昂帕克这两个。对全部是c写的，定式生物都不是家伙写的，都是c写的，晓得。呃麦克老师我嗯。本质上来说，就是说我们怎么去识别灰度环境这个点，就是怎么去知道这个流量属于灰度环境？实际上本本身来说就是在你的网关层去做一个是的。对判断判断，然后判断你是不是灰度测，是不是会的，用户会的忽视的情况下，然后再进行走这样的一个找到你灰度的一个集群地址，然后再复制北京负载均衡。
	这个我说说句实在话，我说真的你的面试吧我跟你说有有点有有点有点太狠了，呀不是因为最近好多好多人跟我说，看你那面试宝典去面试的时候，把明明是把腿打断了，我靠有点狠有点狠有点有点牛逼，这个我告诉你有点小牛逼有点小牛逼。视频中提到的全网首发，50万字最新场景题，有想要的同学评论区置顶可以免费领取。
65-【Java面试】高频面试题：Spring加载Bean有哪些方式？-480P 清晰-AVC
	Spring加载并有哪些方式？Hello大家好，我是孤胖教育的联合创始人麦克，昨天一个刚毕业的小伙伴去面试的时候呢被问到这个问题，希望我能录一期视频啊来分析一下这个问题。今天我正好有空给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的评论区的视频中去领取，spring加载病有哪些方式，也就是说我们可以通过哪些方式去把这些病啊装载到IOC容器中，候选人应该去了解这些常见的spring加载并的方式，并能够去解释每种方式的适用场景和特点。如果你想要去获得面试官的一些积极反馈，最好是能够去把一些不怎么常用的机制也稍微提一下，这样好体现出你对这个领域的知识广度的理解。下面我们来看一下这个问题的完整回答。常见的病的加的方式呢有几种，第一种我们可以使用come point的注解以及它的衍生注解，比如 service通过这样一个注解，可以去把一个Java类标记为一个病，spring呢会自动扫描去加载这些标记的类。
	第二种我们可以通过xml配置文件中的病元素去定一个病，然后spring容器呢会读取并解析配置文件去完成并的装载。第三种可以通过配置类的方式，在Java类中去增加一个configuration注解，在指定方法上去增加个并注解来实现。最后spring呢还提供了两个扩展接口，import selector和been definition registry。这两个接口可以更加灵活的去控制病的加载和注册过程。以上就是这个问题的理解，如果你喜欢我的作品，记得点赞和收藏，我是麦克。我们下期再见。
61-【Java面试】场景题：一万辆车每分钟发送六万条数据，数据库处理慢导致MQ积压怎么解决？-480P 清晰-AVC
	1万辆车，每台车安装一个设备，该设备每10秒发送1条数据，每分钟要发6万条数据，嗯服务器端接收到数据之后发给m扣，嗯之后慢慢再添加到这个数据库。现在的问题是数据库处理速度慢，导致mq积压，怎么搞？就属于一个叫传感设备了，嘛实时的去跟踪那个每个车辆的运行情况了。像这种情况的话，你前面用mq来接是没问题的。然后数据库的这个写入瓶颈的话，你要去看一下，正常来说数据库的铁路的瓶颈，它的音色的操作，它其实因为性能影响并不大，当然涉及到如果就是你数据量比较大的话，索引的一个偏移或者索引的这个更新，它会影响到这个效率了，这层面的话我别的就是可以通过什么？你数据这一块的，这个最终你接触到的肯定是用来做那个分析，嘛比如说做监控嘛监控，那你一方面肯定是说你最好是先做数据的一个清洗，清洗完以后你再入库，吧这是一种方式。然后第二个就是我们在数据库层面做分库分表，然后像这种数据的话应该还是会有时间的一个特性的，所以我们可以通时间的维度去做冷库。
	其实我现在知道它是个什么场景，我跟他解释一下同学们他什么意思？啊其实我们现在有很多汽车安装一个设备，这个设备要每隔一段时间会给他们的这个服务器发个请求，它是相当于类似于心跳的，可能是每隔一段时间10秒对吧？那么他每一分钟就要发6万条的这个数据，你到这个服务器端最后做处理，操作不是直接的接口做的，而是什么呢？你发心跳到我的这个接口之后，我的我的接口可能就头一个消息到门口了，让客户一步来进行处理。那么其实我觉得他这个可以怎么做呢可以减少的问题。啊第一，可以把很多的消息直接合并成一条语句，直接插了DB，可以减少DB的一个连接数。你如果说有6万个，你如果同时用DB做6万次的一个DB连接，不用想低于直接崩盘的解垮了。这根线。就算你有使用睡睡莲池的话，那么你你也会有问题，啊因为有限制掉的，而且会一直堆积在这个莲池里面的，所以它这个还有点问题的。所以我跟你说你这个应该怎么解决？第一 mq肯定是需要做集群消费，第二个你肯定是要把我们的mq中的这个 Message消息把它取出来，要合并一下，比如合并50条，变成一条语句插入在DB里面去，这样的话就可以比你单条去插插插，减少io操作。
	这个我可以这么说的，但是如果量很大的话，建议肯定要走这样的一个负面分库考虑。还有就是什么？呢就是如果说以后如果量比较大的情况下，后面可以考虑灵活监听我们这样的一个数据量，如果数量非常多的情况下，就如果一旦发生很多消息，对于m扣的时候，你可以写个签名脚本，还有很多现在没有消费，就立马去再自动通过程序的方式起几个康斯嘛起来做集群上面保证很多。他这个其实可以这样去玩的，我跟你讲刚刚这一点其实都是麦克老师面试班都有的。呀我刚问了一下，这边大概还有30个人的群就买了。赶紧去领老头们赶紧赶紧领，我待会要领一下，我待会领面试宝典。怎么领就点头像进粉丝群就好了。
66-【Java面试】并发编程突击：CycliBarriar和CountdownLatch有什么区别？-480P 清晰-AVC
	赛克戴瑞和康德张浪区有什么区别？Hello大家好，我是麦克。一个工作了14年的Java程序员，这两个组件是Java并发编程里面guc这个包里面的组件，如果你不知道这两个组件的实现原理和他的一个回答思路，可以在我的评论区的置顶中去领取一个30万字的大场面试指南。这个指南中有这个问题的完整回答，这两个类啊在进行线程并发控制的时候使用的非常多，要能够完整的回答出这个问题，至少需要对这两个类有一个比较深度的理解。赛克Barry它相当于一个现成的同步计数器，当计数器的值还没有达到的时候，县城都会阻塞等待，直到达到设定的数值，所有线程都会被释放。以生活场景为例，比如说打篮球约了6个人，如果6个人都没有到期之前，先到的人需要等待，直到最后一个人到了以后才能开始比赛。抗子弹浪曲呢它可以实现一个或者多个线程阻塞，等待其他线程完成某个操作后再继续执行。一般可以用在多线程之间，需要相互等待，直到某个条件满足后才能继续执行的场景。实际上啊塞克白瑞和康德浪曲在特性上有一点点相同，所以要去对比他们的区别，啊其实还是有一定的难度的。
	下面我们来看一下这个问题的完整回答。据我的理解，呢我认为有三个方面的重要区别，第一，触发的条件不同，赛克Barry是在等待线程数量达到指定阈值的时候，会去触发一个屏障操作，所有县城都会被释放，并且屏障会重置，可以被重用。康德的浪曲呢是通过一个计数器来触发等待操作，这个计数器的初始值就等于等待的线程数量。每到一个县城完成一个任务以后，呢计数器就会减一，直到计数器为0的时候，所有等待的线程将会被释放。第二，从用性不同，赛克Barry可以被重用，也就是在一个县城通过屏障以后，可以再次使用，我们可以通过research的方法去重置赛克戴瑞的一个状态。他的浪曲呢是一次性的，不能被怂恿，一旦计数器减为0，就不能再次使用了。现成的写作方式不同，赛克Barry适合用在一组线程相互等待，达到共同状态，然后同时开始或者继续执行后续操作，并且它还可以额外的去设置一个roundtable参数，当一组线程达到屏障点的时候，可以优先触发汤真lunch啊适合用在一个或者多个线程等待其他线程执行，完成某个操作之后继续执行的场景中，比如在获取某个连接之前，需要等待连接出售后完毕，这个场景就可以使用康德launch来完成。
	以上呢就是我的理解。如果你喜欢我的作品，记得点赞和收藏，我是麦克，我们下期再见。
62-【Java面试】高频面试题：wait()和sleep()的异同点？-480P 清晰-AVC
	说一下wait方法和sleep方法的异同点。Hello大家好，我是古堡教育的联合创始人麦克，这个问题啊很多，1~3年的程序员都不一定搞得明白，可能在网上看了一些碎片化的知识，呢拿来借用当成的一个标准答案去回复面试官，结果导致面试通不过。今天正好有空给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了加我面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的评论区的制定中去领取。Wait和sleep这两个方法在并发片中使用比较多，两个方法都是让县城主色等待，但是等待的场景是不一样的。喂的方法通常是与single natural关键字一起来使用，用于县城之间的同步和协作，而sleep方法通常用于县城的暂停，以便控制执行时间间隔或者实现简单的定时任务。面试官主要想从这个问题中去了解求职者对于多线程并发编程基础知识的理解，大家在回答这个问题的时候，要清晰准确的去解释这两个方法的异同，还需要阐述way的方法和和sleep方法的使用场景和作用，理解和正确使用这种方法，可以帮助程序员编写线程安全和高效的多线程程序。
	下面我们来看一下这个问题的完整回答。Wait方法和sleep方法都是可以让线程暂停执行，也是并发编制中使用非常多的一个方法。它们的差异点主要体现在以下几个方面，第一wait方法是object类中的一个方法，而slave呢是4类中的一个静态方法。第二，wait方法用于多线程之间的协作和通信，而sleep方法是用于线程的休眠。第三，wait方法必须要在辛苦net的同步代码库中去调用，而sleep方法呢没有这样一个使用限制。第四无烟的方法会释放对象锁，使得当前县城进入到等待状态，直到其他线程调用罗蒂噻或者罗蒂塞or方法来唤醒，而sleep方法只能使当前县城暂停执行一段时间，并不会释放对象锁。以上就是我的理解，如果你喜欢我的作品，记得点赞和收藏，我是麦克。我们下期再见。
68-【Java面试】高频面试题：什么情况下不建索引？-480P 清晰-AVC
	什么情况下不需要建索引？嗨大家好，我是麦克。一个工作了14年的Java程序员，今天给大家分享一下面试过程中遇到这个问题，我们应该怎么去正确回答。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在评论区的置顶中去领取。一般情况下，面试官问的索引都是卖c口里面一诺DB引擎的b加速索引。所以大家首先要知道所有的原理，大家都知道b加速是一棵多路平衡树，它的特点是非叶子节点只存储索引，叶子节点存储数据，从而减少b加速层高，降低磁盘io次数，去提升数据的检索效率。通常情况下加索引是能够直接提升数据的检索效率的，但面试官反其道而行，问你什么时候不见索引。所以这个问题考察候选对于索引的理解深度，如果你期望这次面试有一个好的反馈，候选人需要能够分析出不见索引的原因和影响，并根据具体情况进行详细说明。下面我们来看一下这个问题的回答。我认为有几种情况不射箭索引。
	第一数据量太小的情况下，即使没有索引查询的速度也比较快，这个时候建索引反而会增加维护的成本和查询时间。第二数据离散度不高的列，比如说性别年龄这种创建索引呢反而会降低检索效率。从底层原理来说，相当于增加了b加速的扫描范围，从而去提高了查询的时间。第三，存在函数操作情况下，如果查询条件包含函数操作，那这个时候可能不会走索引，所以见索引的意义不大。最后频繁变更的表也不是偶见索引，比如说经常需要更新删除和插入操作那这种情况下，对表现力索引的开销就会很大，甚至可能影响到整个数据库的性能。以上就是我的理解，如果你喜欢我的作品，记得点赞和关注，我是麦克，我们下期再见。

64-【Java面试】高频面试题：CopyOnWriteArrayList底层原理是什么？-480P 清晰-AVC
	Copyright erased它的底层原理是什么样的？屏幕前的小伙伴这个问题你知道怎么回答吗？Hello大家好，我是麦克。一个工作了14年的Java程序员，这个问题是一个工作三年的同学在去参加一个20k月薪的大场面试的时候，遇到了一个真实问题，如果你不知道这个问题怎么回答，可以在我的评论区的制定中去领取这个问题的完整的高手回答。这个集合大家可能用的比较少，不是很清楚，它是Java并发集合框架中一个线程安全的类似的实现。它特点是在进行写操作的时候会创建一个底层的数据副本，并在副本上进行操作，而不是直接在原始数据上进行修改。所以它的这个特性就适用于读多写少的现成安全的场景。下面我们来看一下这个问题的回答。关于copy on right爱瑞斯的一个工作原理。呢我的理解是这样的，第一步初始化的时候，copyright Rui内部呢维护了一个可变宿主，用来存储我们的数据元素。第二，当执行数据变更操作的时候，先会创建一个原数据的副本。第三，在副本上进行写操作，修改副本中的元素，写操作完成以后，把元素组中的引用指向新的数据副本，使得新的宿主成为了一个内部的宿主。
	最后读的操作直接是在元素图上进行，因为读操作不会改变原的数据，所以读取元素的时候不需要枷锁。Copy on ride arise的工作原理，呢保证了多线程病发环境下，读写操作的现场安全性。实际上我们可以简单认为，它就是做了读写分离的一个设计机制。以上就是我的理解，如果你喜欢我的作品，记得点赞和收藏，我是麦克。我们下期再见。

67-【Java面试】面试突击：Redis key过期了，为什么内存没释放？-480P 清晰-AVC
	瑞尼斯里面的key过期了，为什么内存没有被释放呢？嗨大家好，我是麦克。一个工作了14年的Java程序员，昨天一个小伙伴在我的粉丝群里面提出这样一个问题，这个问题他没有回答出来，所以今天正好有空给大家分享一下这个问题的回答思路，如果你正在面试或者即将要准备面试，那么你们可以在我的评论区的制定中，去领取30万字的大场灭鼠指南，里面包括所有大场面试题的高手回答，在raise中key的过期清理呢是通过使用定期删除，合作性删除这两种机制来实现的。定期删除是指race中每隔一段时间会执行一次定期删除的操作，在每次执行定期删除的时候，瑞丽丝会随机抽取一部分的key，并检查他们是否已经过期，如果发现有过期的key呢就直接删除，并且释放对应的内存空间。这种机制保证了瑞丽斯能够定期清理掉过去的key，但并不保证所有过去的key都会被立即清理掉。惰性删除是指当一个key被访问的时候，瑞丽斯会检查key是否过期，过期则删除并释放对应的内存空间。
	了解了瑞丽松的k的过去策略以后，就可以知道这个问题应该怎么回答了。下面我们来看一下这个问题的完整回答。当历史中的key过期的时候，虽然这个Kae在逻辑上已经过期了，但是瑞士并不会立即释放对应的内存空间。由于瑞丽斯采用了定期删除和惰性删除的方式来清理k这两种机制啊意味着瑞丽斯通的key的过期清理并不是实时的，所以即使k过期了，瑞士也不会立即清理他们，只有在执行定期删除或者访问的时候才会进行清理操作，因此一些过激的key可能会在一段时间内仍然存在于red中，直到触发了相应的激励机制，才会被删除或者释放内存。以上就是我的理解，如果你喜欢我的作品，记得点赞和收藏，我是麦克。我们下期再见。
71-【Java面试】高频面试题：多线程异步和MQ有什么区别？-480P 清晰-AVC
	多线程异步和mq有什么区别？嗨大家好，我是麦克。一个工作了14年的Java程序员，今天给大家分享一下，面试过程中遇到这个问题我们应该怎么回答。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在我的评论区的制定中去领取多线的异步和mq异步，其实在特性上有异曲同工之妙。多线程是进程内的概念，mq是分布式消息队列，两者不在同一个维度上，至于区别，我想任何人都可以随便说出123。这个问题主要考察候选人对于并发编程和分布式消息队列的理解，以及候选如何考虑使用多线的异步和mq来解决不同问题。下面我们来看一下这个问题的完整回答。多线程和mq虽然在特性上都支持程序的异步操作，但是在实现本质上有很大区别。我简单说一下较大区别的几个点，第一，处理任务的维度不同，多线程是进程内的概念，在一个竞争中可以有多个县城病情处理任务，mq呢是通过把消息发送到不同业务节点的不同进程里面来处理任务。
	第二，数据的可靠性不同，多线程异步处理任务的时候，数据是基于共享内存来交互的，一旦程序崩溃，内存的数据会丢失。而使用mq的时候，呢我们可以通过消息队列的持久化机制来保证消息的可靠性。第三，分布式能力方面，mq具备分布式能力，我们可以把消息分发到不同节点存储和消费，而多线程只能在一个镜子中去处理任务。以上就是我的理解。当然很多细节层面的差异化也非常多，这里我们就不一一列举。如果你喜欢我的作品，记得点赞和关注，我是麦克。我们下期再见。
70-【Java面试】高频面试题：为什么MySQL不建议使用NULL作为列默认值？-480P 清晰-AVC
	浪子的处理啊是应用开发人员最容易出错的地方，主要的原因是大家习惯使用了二元的不好逻辑来去思考判断，而数据库对于浪子的处理逻辑是三值逻辑，hello大家好，我是麦克一个15年间的Java程序员，这两年大家会发现面试不再局限于常规的八股文，而是考察场景设计以及技术问题的深度理解。我也整理了一份2024年最新的面试手册，里面包括了面试题解析、简历优化建议和面试攻略等等，大家可以到我的评论区留言求分享，免费领取。那值是一种烈的特殊约束，我们创建一个新的烈的时候，呢如果没有明确的使用关键字闹闹声明，麦塞口会默认为他添加一个辣的约束，有些开发人员在创建数据表的时候，由于懒惰直接使用MAC口的默认推荐设置，导致在使用钠的场景中得出不确定的查询结果，以及引起数据库性能下降的问题，要理解为什么不建议使用钠作为默认值，首先得理解三值问题，大多数编程语言都是基于二值逻辑逻辑，只有真和假两个，而c口语言采用一种特别的逻辑体系，三值逻辑逻辑值除了真和假，还有第三个值不确定，也就是unknow。比如对于这样一种逻辑判断，得到结果都是懊恼，原因是闹值既不是值也不是变量，它只是表示没有值的标记，而这种逻辑比较只适用于值，而在CK语句中，如果ongo参与到逻辑运算中，就会存在一个计算优先级的问题。
	我们来看这样一个例子，有一张user表其中form字段默认是long值，假设这个表中存在一条数据，name等于text，父母自认为，那然后再执行这样一条SQL语句，name them test and formed in now。你们猜一下打印的结果是什么？没错，这个时候是无法查询出name等于test这样数据的。原因是这样一个条件，相当于是用一个too and Arnold的条件做一个查询。这个时候on no的优先级更高，所以结果是on no在sq语句中呢针对not and or这三类操作符，针对三值的处理逻辑有这样一个表格，在这个图中显然这部分是三值逻辑中独特的运算，这是在二级逻辑中不存在的，其余的c口位置都能由这三个逻辑运算组合而来，所以大家会发现如果ongo这个值参与到逻辑运算的时候，c口的运行结果和预期是不一致的。再举个例子，如果在比较位置中出现那样的情况，也会造成一些歧义，比如说我们想查询年龄等于20岁或者不等于20岁的所有用户，如果此时有一条数据的age，字段为now，那么通过这条语就是无法把这个数据查询出来的，我们必须要在后面再加一个age，is not这样一个判断。
	除了上述问题以外，呢假设索引链存在捺值，由于捺不会被索引导致索引变得很稀疏，从而影响到查询性能。在某些情况下，如果使用捺作为列的默认值，可能会违反业务逻辑或者数据库的约束，比如说某个列不允许为空，但是我们把它默认值设置为那则可能会违反约束。总的来说想要解决now带来的各种问题，最佳的方法应该是往表里面添加not on的约束，来尽力去排除闹的一个问题，那这样的话我们就可以回到每面的二值逻辑运算里面了。好了，以上就是我今天内容分享，我是麦克。感谢大家关注和收藏，我们下期再见。


72-【Java面试】高频面试题：什么是CompletableFuture？-480P 清晰-AVC
	什么是compliable future？嗨大家好，我是麦克。一个工作了14年的Java程序员，其实给大家分享一下面试过程中遇到这个问题我们应该怎么回答。另外我把网签的内容都打包在了加我面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在评论区的置顶中去领取。康普雷德菲菲特是Java引入的一个类，它可以解决异步执行任务和处理异步任务的结果。康普顿雷的future呢确实是一个很实用的组件，面试官想通过这个问题去考察候选人是否熟悉异步编程的概念，是否能够编写异步代码。另外compleat bruecher可以优化系统的性能和响应速度，所以面试官想要考察候选人是否能够设计和优化高性能高并发的一些系统，并且能够使用complied的future等工具来实现优化。下面我们来看一下这个问题的回答。Complied的future呢是Java吧里面引入的一个组件，它提供了一种简单且强大的方式来处理异步任务和处理异步任务的结果。
	在compleat出现之前，我们只能使用 callable future这样一个机制来去获取一波线程的执行结果，但future是通过阻塞等待的方式来实现的。对性能不是很友好，而使用comply的future可以让我们将一个耗时的任务提交给现存池呢进行异步处理，然后可以继续执行其他任务。等到异步任务雏形结束以后，会触发一个回调方法，我们可以在回调方法里面去处理一波任务的执行结果，相当于优化了future的阻塞等待的问题。类似于一种响应式编程方式，Complete的QQ提供了一些便捷的方法，比如说 then apply，then accept，先run等等。可以让我们以链式的方式来处理异步任务的执行结果，从而更加灵活的去编写异步代码。以上就是我的理解。如果你喜欢这个作品，记得点赞和关注，我是麦克，我们下次再见。
73-【Java面试】高频面试题：对接第三方接口要考虑什么？-480P 清晰-AVC
	对接第三方接口需要考虑什么？嗨大家好，我是麦克，一个工作了14年的Java程序员，今天给大家分享一下面试过程中遇到这个问题我们应该怎么回答。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在我的评论区的置顶中去领取。这个问题考察候选人实际开发过程中是否有参与过第三方接口的对接，以及在对接过程中是否有深度思考过，对接过程中存在一些问题，很多候选人基本上都是按照第三方接口的文档去写，甚至成熟一点的第三方接口都提供了封装好的工具包，使得大家很少去关注对接过程中可能存在一些问题。下面我们来看一下这个问题的完整回答。基于我的经验，主要考虑以下几个方面的问题。第一安全性问题。由于和第三方接口对接的时候，涉及到数据的跨网络传输，为了防止数据被拦截和篡改，需要采用安全的通信机制，比如说https协议，以及通过数据签名来避免数据篡改的问题。第二，接口的稳定性和可靠性，这两个方面呢会直接影响用户体验和业务的正常流程，所以我们需要做相对充分的评估和测试。第三，接口是否存在访问限制或者费用，如果存在病房量限制，需要评估是否满足当前业务的需求，如果存在费用，我们需要评估是否满足我们的预算范围。
	以上就是我的理解。如果你喜欢这个作品，记得点赞和关注，我是麦克，我们下期再见。
69-ThreadLocal有哪些使用场景-480P 清晰-AVC
	C的logo有哪些使用场景？啊嗨大家好，我是麦克。一个工作了14年的Java程序员，昨天啊一个小伙伴去某互联网公司面试，会问到这样一个问题，如果大家不知道这个问题该怎么回答，可以在我的评论区的制定中去领取30万字的大成品指南。这个指南里面有详细的回答思路。Three的logo是一种多线程隔离机制，它提供了多线的环境下对共享变量访问的安全性。在多线的访问共享变量场景中，啊一般的解决办法就是对共享变量枷锁，从而去保证在同一个时刻只有一个线程能够对共享变量进行一个更新，而枷锁会带来性能下降。所以呢16logo用了一种叫空间换时间的设计思想，也就是在每个县城里面都有一个容器来存储共享变量的副本，然后每个线程只对自己的变量副本去做更新操作就好了。这样既解决了现在安全问题，就避免了多现成竞争家属的开销。共享变量的副本是存储在所有的那里面的一个成员变量，叫所有logo map里面的，后续对副本的操作都是从这个思维的logo map里面去进行变更的，不会影响全局共享变量的值。
	下面来看一下这个问题的完整回答。Three的logo呢是可以基于副本的隔离机制来保证共享变量修改的安全性，它的使用场景很多，我简单罗列几种，第一，现成的上下文传递，在跨现成的交通场景中可以使用谁的logo，在不修改方法签名的情况下去传递现成上下文的信息。比如在框架和中介里面把请求的相关信息，比如说用户信息啊或者请求ID等等，存储在所有logo里面，那么在后续的请求处理内容中都可以方便的去访问这些信息。第二个数据库的连接管理，在使用数据库连接池的情况下，可以把数据库的连接存储在所有的logo里面，这样每个县城可以独立去管理自己的数据库连接，避免了县城之间的竞争和冲突。比如my Betty中的CC选对象就使用了c的logo来存储当前现成的数据库会话信息。第三事务管理。在一些需要手动管理事务的场景中，啊可以使用c的logo来存储事物的上下文，每个县城可以独立的控制自己的事物，保证事物的隔离性。Springe中的全section zeagonite一些manage类，就使用了十字路口来存储事物相关的上下文信息，不过啊在使用随logo的时候，需要注意使用规范，避免出现内存泄露的问题。
	以上就是我的理解。如果你喜欢我的作品，记得点赞和收藏，我们下次再见。


74-【Java面试】过滤器和拦截器有什么区别？-480P 清晰-AVC
	过滤器和拦截器有什么区别？我想大家可能是知道它们的区别的，但是真正要去动口说的时候可能就有点晕了。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在评论区的置顶中去领取。这个问题一般考察1~3年左右的程序员，主要是想了解候选人对于web应用程序中常见技术的掌握程度，以及对于请求处理流程和各个技术应用场景的理解程度。同时这个问题还可以了解候选人对于survey的容器、spring、框架等相关技术的掌握程度。因此大家在回答这个问题的时候，要结合自己的实际经验和理解，从技术实现进入场景性能等多个方面来进行回答，展示出自己对于web应用程序开发的深入理解，核实应用能力，下面我们来看一下这个问题的完整回答。第一，运行的顺序不同，过滤器是servlet容器接收到请求之后，但是在servlet被调之前运行了，而拦截技能则是在servlet被调用之后，但是在响应被发送的客户端之前来运行的。
	第二配置方式不同，过滤器是在web点插面领域进行配置，而拦截器是在spring的配置文件中进行配置，或者使用铸铁的方式进行配置。第三，菲特呢依赖于survey的容器，而intercept不依赖于service的容器。第四，Dita在过滤器中只能对request和response进行操作，而Entercept呢可以对cracks response。Handle mode and view xh进行操作，相当于英德塞特尔多了对于spring mvc生态下的组件的一个操作能力。以上就是我的理解，如果你喜欢这个作品，记得点赞和关注，我是麦克。我们下期再见。

76-【Java面试】为什么阿里巴巴强制要求使用包装类型定义属性？-480P 清晰-AVC
	为什么阿里的开发手册强制要求使用包装类型来定义属性呢？Hello大家好，我是麦克。一个工作了14年的Java程序员，又是一个开发规范性的问题，问题的本质是为什么企业强制要求使用包装类型定义属性。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在评论区的置顶中去领取，这是一个开发规范性的问题，开发规范更多的是为了后续程序的可维护性，以及避免出现一些低级错误，影响了程序的稳定。所以对于一些规模比较大的公司，对规范的定义就会更加严格和细致。所以在回答这个问题的时候，可以往包装类型的优势上去切入，从而保证自己回答的内容在面试官的预期范围内。下面我们来看一下这个问题的完整回答。我认为主要有几个方面的原因，第一默认值的问题，使用基本数据类型定义属性的时候，如果没有给属性赋予初始值，会使用默认值，比如说intel的默认值是0，而使用包装类型定义属性，如果没有给属性赋予初始值，那么属性的初始值就是钠，这样就可以更加清晰的去表达属性的状态。
	第二拆箱问题。在一些特定场景下，如果使用基本数据类型去定义属性，需要进行多次装箱和拆箱的操作，这个操作会带来额外的性能开销和代码的复杂度，而使用包装类型定义属性的时候，可以避免这个问题，提高代码的效率和可读性。第三，Java中的泛型只能使用对象类型，如果要在泛型编程中使用基本类型，就必须要使用对应的包装类型。最后包装类型提供了基本类型所不具备的方法和属性。比如说一course哈奇扣的舒适骏等等这样一些方法，这些方法在特定的场景中比较有用。以上就是我的理解，如果你喜欢这个作品，记得点赞和关注，我是麦克。我们下期再见。
78-【Java面试】阿里一面：为什么阿里Java手册禁止使用存储过程？-480P 清晰-AVC
	为什么阿里的Java开发手册禁止使用存储过程呢？Hello大家好，我是麦克。一共做了14年的Java程序员，昨天一个工作了4年的程序员去某互联网公司面试，被问到这样一个问题，如果大家不知道这个问题该怎么回答，另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，可以在我的评论区的咨询中去领取我整理的。一般来说每个公司都会有自己的开发规范，开发规范存的目的呢是减少一些低级错误和提升代码后期的可维护性。就这个问题来说，整个过程并不是绝对不能使用的，只是在不同规模的公司使用存储过程会带来一定的影响。因此候选人可以从存储过程本身的缺点切入，去解释就好了。禁止使用存储过程主要有以下考虑点，第一，存储过程的所有逻辑都是在数据库层面，这会导致代码后续的可维护性下降。第二，存储过程可能会包含复杂的业务逻辑，会导致数据库的负载增加，进而影响到整个系统的性能。第三，互联网公司的数据库会有专门的人来维护，开发人员是无法直接去访问生产库的。
	当我们把业务逻辑写到数据库的存储过程里面，那后续对业务进行升级的时候，不需要同步升级存储过程，不仅会造成工作职能的冲突，还会影响到业务逻辑的维护性问题。最后存储过程本身是比较难以调试和测试的，所以对于后续的维护来说也不是很方便。以上就是我的理解，如果你喜欢我的作品，呢记得点赞和收藏。
82-【Java面试】应用程序中存在包冲突的情况下，怎么发现和解决？-480P 清晰-AVC
	你们想象一个工作了4年的程序员竟然连这个问题都搞不清楚，应用程序啊存在包冲突的情况下，解决问题应该很容易，啊甚至大家在工作中也应该遇到过。啊好吧？今天呢抽空给大家分享一下这个问题的回答思路。另外如果你们正准备面试以及未来有跳槽计划的小伙伴，我们给你们整理了一个50万字的大场面试指南，有需要的小伙伴可以在评论区的制定中去领取，这个就是一个简单的经验问题。一般在工作中啊都有可能遇到，即便没有遇到过，也能基于自己已有的经验去回答出来，无非就是把存在冲突版本的包排出去，好了。下面我们看一下完整的回答。应用程序中存在包充足的情况下，一般不需要主动去发现，程序在运行过程中呢会提示异常，比如常见的no such mass的一个c选，通常这一类异常的原因啊是不同版本的依赖包中的类或者方法存在差异，所以我们可以去根据错误日志去定位到冲突的类或者方法，然后找到所属的包，接着可以使用intel这个工具自带的依赖关系分析，或者买粉盘思隽这样一个指令，来分析当前应用中的包依赖关系，定位到哪些依赖，包中引用了不同的版本库，最后可以在pom文件对应的依赖包中，通过 exclusive这样一个标签去排除掉d版本的依赖。以上就是这个问题的回答思路。
79-【Java面试】高频面试题：如何提升接口性能？-480P 清晰-AVC
	如何提升一个接口的性能？昨天啊也工作了7年的粉丝去高德面试，被问到这个问题的时候回答有点混乱，今天正好有空给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在我的评论区的视频中去领取，这是一道比较开放性的问题。面试官希望通过这一类的问题呢去打开面试过程中的沟通话题，并且尽可能的让候选人多去表达，从而去更好的了解候选人的技术能力，所以针对这一类的问题啊可以打开回答思路，从宏观到微观，把自己能知道的点全部说出来就好了。下面我们来看一下这个问题的回答方式，影响接口讯能的因素有很多，我基于自己的理解，分别从几个维度来回答。一从接口本身的实现维度来说，可以从几个方面来优化。一如果在接口中有操作数据库层面的代码，可以优化数据库的io的效率，比如说c口优化，数据库层面的优化等等，如果存在部分频繁访问数据库的热点数据，我们可以采用缓存机制来提升数据库io的效率。
	如果涉及到远程调用或者耗时的方法调用，可以采用异步的方式去避免同步阻塞，从而提升程序的运行效率。第四，代码本身的优化，可以利用合适的算法减少时间复杂度，避免一些很明显的重复计算等等。第二，从宏观列入的维度来说，可以关注几个方面，第一网络带宽带宽的大小或影响数据的传输效率。第二，服务器的硬件资源，比如说CPU内存会影响到接口中代码的执行效率。第三，单个部署节点的计算能力，瓶颈也会影响接口的性能。我们可以采用分布式部署的方式来进行优化。总的来说一个接口的性能的影响涉及的因素非常多，如果真的出现性能问题，可以根据系统日志以及压测的情况去去分析瓶颈点，再针对性的进行优化。以上就是我的理解。
80-【Java面试】高频面试题：敏感数据怎么加解密和传输？-480P 清晰-AVC
	敏感数据怎么加解密和传输，这是一个工作4年的粉丝啊去蚂蚁金服的第一面遇到了面试真题，其实正好有空给大家分析一下这个问题的底层逻辑，以及面试的时候的一个回答技巧。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在我的评论区的决定中去领取，这是一个典型的信息安全性问题。面试官主要通过这个问题呢去测试你对安全方面的了解程度，以及你在实际项目中如何保护敏感数据的能力，候选人可以通过加密算法的选择，加密方案的设计，数据传输的安全性等方面来进行一个分析。下面呢我们来看一下这个问题的回答。常见的加密算法呢有两种，一种是对称加密就是通信，双方共享，同一个泌尿，另一种是非对称加密，也就是通过公钥和私钥两种密钥分别进行加密和解密。对于客户端和服务端之间的数据传输，可以采用非对称加密的方式来实现。首先客户端用提前分配好的公钥对数据加密，然后再把密文传输到服务器端，服务器端通过密钥来解密，常见的飞盾加密算法呢有rsa和DSL两种，除了加密算法以外，还需要去通过安全的通信协议来进行传输。
	这里呢可以采用https协议，最后我们还需要确保公钥和私钥存储的安全性，防止被第三方拿到密钥以后能够破解内容。以上就是我的理解。
75-【Java面试】小米一面：MySQL update 是行锁还是表锁？-480P 清晰-AVC
	麦塞口中的update是行锁还是表锁？今天给大家分享一下这个问题的底层逻辑，以及面试的时候的一个回答技巧。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在我的评论区的重点中去领取。要回答好这个问题，啊首先需要了解MAC口中为什么要引入锁，在多个事物并行对同一个数据进行修改的时候，会产生事物的竞争，会造成脏、毒、幻、毒和不可重复度等问题。所以麦西口为了避免这类问题的出现，引入了事物的隔离节点。其实本质上来说最终解决的方式无非就是lbcc和mvcc两种，而锁是解决事物竞争问题的底层实现方式，通常来说枷锁会影响性能，所以啊一般情况下都会考虑到性能跟安全性的一个平衡。而MAC口呢也根据不同的作用范围提供了不同锁的实现方式，而这个问题就是考察候选人对于所范围的理解。下面我们来看一下这个问题的回答思路。麦塞口的阿布列操作既可以是行锁，也可以是表锁，具体使用哪种类型的锁？
	取决于执行update语句的条件，事务隔离级别等因素。如果update语句中的where条件包含了索引链，并且只更新一条数据行，那这个时候就会加行锁。如果为了条件中不包含索引链，这个时候会加表锁。另外根据查询范围不同，Michael也会选择不同力度的锁来避免患者的问题。比如针对组件索引的for update操作，max口会增加一个next来锁定ID等于10索引所在的区间，而针对于索引区间的查询或者修改，麦西口会自动对索引加间隙锁来解决换毒的问题。以上就是我的理解。
81-【Java面试】小米二面：Kafka中一个Topic有三个Partition？-480P 清晰-AVC
	卡夫卡中的一个topic，假设有三个petition，同一个消费组有两个消费者如何去消费这三个分区，我敢保证刷到这个视频的人，100个人只有一个人能回答出来，不要偷偷查资料，直接在评论区回答，我不相信会打脸。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在我的评论区置顶中去领取。在回答这个问题之前，先来了解一下卡卡的运行机制。当我们向某个topic发送消息的时候，在卡夫卡的博客上会通过pet分区的机制来实现消息的物理存储。一个topic呢可以有多个菩提选分区，相当于把一个topic里面的n个消息数据进行一个分片存储。消费者去消费消息的时候，会从指定的喷嚏群分区中去获取数据。在同一个消费组里面，一个消费者可以消费多个pretty分区的数据，但是消费者的数量只能小于或者等于菩提起分区的数量，而这里面提出来的问题是一个消费组里面两个消费者去消费三个petition，嗯我们很自然的能够想到，其中一个消费者肯定需要消费两个培训，但是哪个消费者来消费两个party分区，呢这就是这个问题的关键。
	下面我们来看一下这个问题的回答。这个问题涉及到卡夫卡里面的consumer骨科的那头，也就是消费组协调器，它会根据消费者订阅的topic里面的喷气体数量和消费组里面消费者实力数量来决定每一个消费者消费哪个菩提心分区，这个算法会在消费组里面选择一个消费者实力，去作为一个leader，leader负责分配petition分区给到消费者实力，并协调消费者实力之间的把T恤分配和rap。当一个消费者实力加入或者离开消费组的时候，协调器会触发potential的重新分配，确保所有的petition都能够被消费者实力均匀的消费。卡夫卡提供了三种potential分配策略，第一种叫轮巡，他会把pet分区均匀的分配给消费者实力，第二种叫范围，他会按照pet的范围进行分配。第三种叫棉质分配，他会尽可能的把同一个菩提群分区分配给同一个消费的实力。以上呢就是我的理解。
77-【Java面试】为什么有些公司禁止使用@Transactional声明式事务？-480P 清晰-AVC
	为什么有些公司禁止使用全section，生命是失误。呢 Hello大家好，我是麦克。一个工作了14年的Java程序员，屏幕前的小伙伴，如果你不知道这个问题该怎么回答，另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，全section的注解呢在很多互联网公司都有使用，并不是每个公司都禁止，所以是否需要使用，也和全section的注解的特性和特定环境有关系。所以大家可以沿着穿section的注解的生命是事物可能存在的问题去说就好了。下面我来看一下这个问题的完整回答。我认为有几个方面的考虑，第一，在方法上面增加transaction的生命是事物，如果一个方法中存在较多耗时的操作，很容易引发常数的问题，而常事物会带来锁的竞争影响性能，同时也会导致数据库的延迟被消耗尽，影响到程序的正常执行。第二，如果方法存在嵌套调用，而被嵌套调用的方法也声明了全是action的事物，那么这个时候就会出现事物嵌套的调用行为，容易引起事物混乱，造成程序运行结果出现异常的问题。第三，transaction的声明事务是将事物控制逻辑放在注解里面，如果项目中的复杂度增加，事物的控制可能会变得更加复杂，导致代码的可读性和维护性下降。
	所以为了避免这一类的问题，有些公司会推荐使用编程事务，这样可以更加灵活的去控制事物的范围，减少事物的锁定时间，提高系统的性能。以上就是我的理解。如果你喜欢我的作品，记得点赞和关注我是麦克，我们下期再见。
85-“我”，211学历和十年Java开发经验，离职后直接丧失择业权！ Java行业现状-480P 清晰-AVC
	年薪百万的技术大牛被辞，资深程序员转行送外卖，10年it老兵摆摊创业。Hello大家好，我是麦克。这两年网络上总是被程序员大龄失业的新闻刷屏，好像不管技术多牛，级别多高，大龄失业都是it主义的宿命。今天我不讲技术干货，给大家分享一段真实的学员经历。如果屏幕前的你步入了大龄，不知道接下来的路该怎么走，因为年龄问题而感到非常焦虑，那么这期视频呢一定会对你有所帮助。这位学员啊今年34岁，在武汉工作了89年，毕业以后呢进入了一家保险公司，做软件开发之后就一直待在传没有进入过互联网公司。虽然有10年的工作经验，但是开发水平和四五年的掌握的技术战呢也比较陈旧，也没有什么拿得出手的项目，只带过5个人的小团队，技术积累和软实力的培养都非常少。去年他因为家里有事，于是在10月份辞职，想着凭借自己211的学历，10年的项目经验，找工作应该是分分钟的事情，结果啊理想很丰满，现实很多，简历投了无数。不是没人理，就是聊了上去没？根本没有什么面试机。
	有一些机会自己又嫌待遇不好，只能含泪选择拒绝。听说2023年互联网会回暖，他本来想着过年以后趁着所谓的回暖，找一下机会，没有想到今年的就业形势，就算他把标准一降再降，开始海投也没有找到工作，在走投无路之下，呢他找我寻求帮助，听了他的经历，啊他肯定会发现他的问题还不少，年龄偏大，但是又没有掌握与之相匹配的技术战。项目偏传统，没有互联网的工作经验，技术上没有优势，管理经验也不够，对自己的职业生涯呢也没有一个清晰的规划。针对他的情况和现在主流的招ping需求，啊我帮他明确了自己的职业发展路线，并且定制了一个详细的学习计划。因为年纪比较大，不适合再去和年轻人去拼性价比，所以我让他转化思路，往资深架构师的方向去包装自己，帮他梳理了一遍以往的工作经验，进行了一些简历优化和项目重构，并安排老师师全程指导，甚至啊让他在面试的时候去把面试过程录下来，然后我们通过听录音去分析他的一个问题，和他的一些改进方向，从而不断的去帮他提升面试通过率，找到工作以后啊再按照计划去进行系统化的学习，去把短板补。
	陈旭的租赁危机确实存在，但危机的本质啊不是年龄的增长，而是能力和年龄的不匹配，提早布局规划才能避免大牛危机。如果你也对现状感觉不满，又不知道从哪里开始去改变，也可以在我的评论区或者主页中去。今天的视频呢就到这里了。我们下期再见。

84-【Java面试】Kafka消息队列怎么保证exactlyOnce，怎么实现顺序消费？-480P 清晰-AVC
	卡夫卡消息队列怎么保证exactly once？怎么实现顺序消费？这个问题啊难倒了很多5年以上的程序员，而且这个问题的面试频率也非常高，建议大家收藏以后反复观看。另外我把这个问题的回答整理到了一个50万字的大场面试指南里面，大家可以在我的评论区置顶中去领取。在回答这个问题之前，先了解一下卡夫卡的运行机制，当我们向某个topic发送消息的时候，在卡夫卡的block上会通过和提醒分区的机制来实现消息的物理存储。一个topic可以有多个petition，相对于把一个topic里面的n个消息数据进行一个分片存储，消费端去消费的时候，会从指定的partition里面去获取。在同一个消费组中，一个消费者呢可以消费多个petition里面的数据，但是消费者的数量只能小于或者等于把电信分区的数量，理解卡夫卡的工作机制以后，再来理解一下exactly one's的意思。在mq的消息投递中啊有三种意义，第一种是 at most once，他的消息投递最多一次可能会丢失，但不会出现重复。第二种是 at least once消息同意至少一次可能会出现重复，但不会丢。第三种是exactly once，消息投递啊正好一次，不会出现重复也不会丢，所以要回答这个问题，必须要从上面这两个角度去切入。
	首先我先回答一下卡是如何保证exactly once，准确来说，目前市面上Emme queue产品基本上都没有提供exactly once的一个语义实现，我们只能通过一些其他手段去达到 exactly once的一个效果。也就是说确保生产者只发送一次，消费端呢只接受一次。第一，生产者可以采用事物消息的方式，事物呢可以支持多分区的数据完整性和原则性，并且可以支持kuang绘画的exactly ones的一个处理与即使生产者宕机重启，依旧能够保持数据只出了一次，开启事物首先需要开启密等性，并设置这样一个参数为主，然后对生产者的消息发送啊做一个事物控制，如果出现导致生产者从事的错误，这个消息呢只能写到卡夫卡布洛克中的日志中一次。第二，虽然生产者能够保证在卡卡block上只记录唯一一条消息，但是由于网络延迟的存在，有可能会导致布洛克在投递消息给消费者的时候，触发从事导致投递多次，所以作为消费端可以采用幂等性的机制来避免从事带来了重复消费的问题。
	其次关于顺序性消费的问题，在卡不卡里面呢每个position分区的消息本身就是按顺序来存储的，所以只需要针对topic设置一个petition，这样就可以保证所有消息都能够写入到这个 patient里面，而消费者这边只需要去消费这个分区，就可以实现消息的顺序处理。以上呢就是我的理解。
89-【Java面试】高频面试：怎么使用redis实现一个延时队列？-480P 清晰-AVC
	怎么使用release实现一个延迟队列呢？昨天一个工作了6年的粉丝去应ping一个年薪40万的工作，在第一面的时候被问到这个问题。屏幕前的小伙伴如果你知道这个问题怎么回答，那么你应该可以拿到40万年薪。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的评论区的制定中去领取这个文档。要回答这个问题，啊首先要明白什么是颜值队列，其次呢还得了解 rids里面有哪些结构可以支持延迟队列这样一个特性，延迟队列是一种特殊类型的消息队列，他允许把消息发送到队列里面，但不立即投递给消费者，而是在一定时间以后再把消息投递给消费者去完成消费。所以它通常用于需要在未来的某个时间执行某个任务的场景，比如订单的超市处理，定时任务等等，在Lettice里面可以使用g赛的这个有序集合来实现节烈。具体的实现方式我们可以把它分成几个步骤，第一我们可以使用Ga的命令去把消息添加到这样一个GB sett里面，并且把当前的时间作为scob。
	第二，启动一个消费者线程，使用z软几百stop命令去定时从c赛的集合中去获取当前时间之前的所有消息。第三，消费者处理完成以后，可以从有序结合中去删除这些消息。通过这种方式，虽然可以实现延迟队列，但是消费端需要不断的向瑞德斯去发起轮巡，所以它会存在两个问题，第一，轮巡存在时间间隔，所以延迟消息的实际消费时间会大于设定的时间。第二，大量的轮巡动作会对ris服务器造成很大压力。所以如果我们需要去使用的研制消息，很多mq组件都支持这样一个能力，比如说rock mq以上就是我的理解。
83-【Java面试】表数据量大的时候，影响查询效率的主要原因有哪些-480P 清晰-AVC
	单表数据量大的时候，影响查询效率的主要原因有哪些？最近有在面试过程中遇到这个问题的小伙伴可以刷一告诉我一下，这个问题呢也是一个一线大厂的征集，当时呢那个工作6年的粉丝也没有回答上来。今天给大家分享一下这个问题的解答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，可以在我的评论区置顶中去领取。这个是一个比较开放性的问题，它没有标准答案，大家可以把自己所有知道的东西啊全部说出来就好了。开放性问题在面试过程中比较常见，主要的目的是去挖掘候选人的技术能力，让候选人尽可能多的去说自己的技术理解和边界，从而为后续的面试问题啊提供依据。表数据量大的时候，呢主要有几个方面的因素来影响查询效率。第一磁盘io数量大意味着需要从磁盘读取更多的数据，而磁盘io的速度相对会比较慢，因此呢会影响到查询效率。第二索引失效，索引啊是提高查询效率的一个重要手段，但是如果随机失效就会导致查询效率下降。
	所以失效的原因可能是查询条件中使用了不支持索引的操作服，或者是数据分布不均匀导致所以失效。第三数据分页，当需要查询大量数据的时候，数据库需要进行数据分页，而数据分页的过程会占用大量的CPU资源，因此呢也会影响到查询效率。第四锁竞争，当多个事物同时对一个数据表进行读写操作的时候，就会产生锁的竞争，而锁竞争会导致查询效率下降，最后就是内存的使用。当数据量大的时候，啊需要占用更多的内存空间来缓存数据，而如果内存不足，就会导致数据库频繁的进行磁盘io从而影响到查询效率。以上就是关于这个问题的回答。
86-【Java面试】JVM中的三色标记法是什么？-480P 清晰-AVC
	Gvm中的三色标记法是什么？这是一个年薪40万的真实面试题，大家可以先点赞收藏，反复观看。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，有需要的小伙伴可以在评论区的制定中去领取。三色标记法是Java虚拟机里面垃圾回收算法的一种，它主要用来标记内存中存活和需要回溯的对象，它的好处是可以让TV不发生，或者仅仅短时间内发生一个stw，也就是我们常说的stop的味，从而达到GM内存回收的一个目的。在鸡m中 CMS精益垃圾回收器都用到了三色标记法，在三色标记法中，啊 Java虚拟机呢会把内存中的对象分为三种颜色，第一种是白色，表示还没有被垃圾回收器扫描的对象，第二种是黑色表示已经被垃圾回收器扫描过，并且这个对象以及其引用的其他对象都是存活的。第三种是灰色表示已经被垃圾混沌机扫描过，但是对象引用的其他对象还没有被扫描，在GC开始的时候先把所有对象都标记为白色，然后从跟对象开始去便利内存中的对象，接着呢把直接引用的对象标记为灰色，然后再判断灰色集合中的对象是否存在。
	指引用。不存在就直接放入黑色集合里面就好了，如果存在就需要把指引用的对象放入到灰色集合中，按照这样一个步骤啊不断的进行一个推导，直到灰色结合中的所有对象都变成黑色以后，那么这一轮标记就完成了。最后呢还处于白色标记的对象，就是不可达对象可以直接被回收。以上呢就是对于这个问题的回答。
87-【Java面试】说一下Kafka中Partition分区副本的Leader选举算法？-480P 清晰-AVC
	请你描述一下卡夫卡中的petition分居副本的leader选举算法。我敢说这个问题99%的程序员答不上来，不服来评论区打我的脸，这个问题确实有一定的难度，不知道也可以理解。我把这个档案整理到了一个50万字的大场面试指南里面，大家可以在我的评论区自己中去领取。在卡夫卡的架构中，一个topic的逻辑主题可以分成多个pet分区，去实现消息内容的物理存储，同时为了保证party分区的一个可靠性，啊卡夫卡设计了分区副本的概念，也就是一个party去分区可以设置多个副本，在多个副本中啊由于涉及到数据的同步，所以卡夫卡针对于petition分区副本级啊设置了一个lead副本，可follow副本、leader副本负责处理所有的读写请求，follow副本呢只负责从lead副本去同步数据，而这个问题就是去考察候选人对于petition分区副本集中的leader选举机制的一个了解。所以如果你希望获得面试官的一个青睐，至少要回答到具体的点上，因为在卡夫卡中除了帕蒂逊分区副本的leader选举以外，还会涉及到卡夫卡集群本身的leader选举，当然这两个不是同一个概念，千万不要搞混了，卡不卡？
	首先会选择一个具有最新数据的副本，作为新的leader，也就是rsr集合的副本，其中RS二集合呢指的是与lead同步的副本集合，简单理解就是他们的数据同步状态与leader最接近，并且他们与leader副本的网络冲击延迟是最小的。如果isi集合没有可用副本，卡不卡呢会从所有副本中去选择一个具有最新数据的副本作为新的leader。当然在这种情况下选举出来的leader，由于和原来老的leader节点的数据呢存在较大的延迟，所以可能会造成一部分的数据丢失的一个情况。所以卡夫卡设计者把这个功能开关的选择呢交给了开发人员，如果愿意接受这种情况，可以通过这样一个参数来设置，开启之后虽然会造成数据丢失，但是至少可以保证依然能够对外提供服务，保证可用性。
91-【Java面试】Redis中的哨兵选举算法是如何实现的？-480P 清晰-AVC
	Release中的哨兵选举算法是如何实现的？昨天一个工作了7年的粉丝去某外包公司面试，被问到这个问题的时候啊不知道该怎么回答，今天正好有空给大家分享一下这个问题的回答思路。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的评论区置顶中去领取。Vs里面的masterkry slaver集群呢是不具备故障恢复能力的，也就是说master节点挂了以后，需要从集群中的其他level节点去选举一个新的master，继续提供服务，因此呢在race里面引入了三层的哨兵机制，通过哨兵来监控集群的一个状态，实现master选举。哨兵啊是一种单独的进程，所以为了保证哨兵的可靠性，我们也会对哨兵做集群部署。假设哨兵节点有三个，那这个时候呢这三个节点分别去监听reds里面的三个主从节点。这就存在一个问题，一旦瑞丽斯主从集群的某个节点出现故障，而故障节点被其中一个三种哨兵节点检测到，但是另外两个节点还没有检测到，那三个哨兵节点如何在意见上达成一个一致呢？
	同时哨兵节点怎么去判断，哪一个slave节点应该成为master，呢这就是这个问题的底层逻辑。也是候选人在面对这个问题的时候，需要去思考和回答的方向。当release集群中的master节点出现故障，哨兵节点检测到以后，啊会从瑞士集训中的其他slaver点钟去选举出一个作为新的马尔。具体的判断依据呢有两个部分，第一个部分叫筛选，第二个部分叫综合评估，在筛选阶段会过滤掉一些不健康的节点，比如下线或者断线的节点，或者没有回复send哨兵心跳响应的slave节点，同时啊还会评估实力过往的网络连接的情况，如果在一定时间内斯莱瓦和master经常性断联，而且超过一定的阈值，也不会考虑经过筛选以后，剩下的都是一些健康节点了。接下来就是要对健康节点进行一个综合评估了，具体呢有三个维度按照顺序来判断。第一根据是level节点的优先级来判断，我们可以通过是level刚配合你这个配置项，可以给不同的slave节点设置不同的优先级，优先级高的优先成为master。
	第二选择数据偏引量差距，最小的节点其实啊就是比较斯莱瓦和原来的master节点的数据复制进度的一个差距，避免丢失过多数据的问题。第三，slave的让ID在优先级和复制进度都相同的情况下，让ID越小，就说明他的创建时间越早，那么他就会优先具有选择master的一个权利，经过以上步骤呢就可以选举出一个新的master节点了。另外如果哨兵存在集群的情况下，其中一个哨兵节点认为right集群出现故障，另外两个哨兵节点还没有感知的情况下，在进行master选举之前，center哨兵集群需要通过公式算法来达成一致，这里呢用到了rap的协议。以上就是我的理解。
88-不同年限的程序员，简历上应更注重哪一点？-480P 清晰-AVC
	所有30岁以上的或者工作5年以上的同学，你的简历的偏重点不是一个纯粹的开发，我就给你分析一下这个简历的模板很好，很工整。然后你的那个简历的这个结构其实也比较清晰，第一眼看过去基本信息，你的那个所谓的自我评价就是你个人优势部分，更优势不比如你熟悉GPS底层原理，这里面呢你怎么去描述？注意啊认真听，你熟悉基本底层原理，你可以侧面去加一个东西，就是我有过gvm的调优经验，或者你可以量化一下，我解决过内存溢出或者那个内存泄露的问题，就是你可以通过一些侧面案例去描述这个事情。这个描述呢就比你的这种什么类加载这个东西的描述更加立体一些。然后你这个部分熟悉等主流框架，比如说你熟悉它对不对？然后你这后面再加一个，我有0~1去搭建spring call的项目的经验，或者我在3~4个项目中有用过spring cloud的这样一个技术站，那这样我的描述就会多了一个什么？更加丰富的一个维度去证明我在这个领域内确实是有优势的，是有沉淀的。这里面你还可以去评价什么点？
	除了技术以外，所有30岁以上的或者工作5年以上的同学，你的简历的偏重点，不是一个纯粹的开发。就是很多工作5年以上同学，我上面描述的就是技术很牛逼，在这个行业技术牛逼不够，你要知道1~5年你可以写技术很厉害很厉害都没有关系，这个时候你的面试机会会偏重于说我会关注你的标签就是技术大牛对不对？5年以上我可能会关注你的一个综合维度，你有没有做过架构，有没有做过管理，就是你要突出你在这个行业干了5年，并且积累过除了技术以外的其他能力。所以你在你的简历上，你不能单纯只写你的技术站，特别是30岁以上的，你30岁以上你写个简历全部记录在你会发现你没有面试机会，或者面试机会特别少。因为我对于30岁以上的程序员的需求，关注的不再是你的技术，我会关注你的比如说逻辑思维能力、全局把控能力、管理能力和你的这个架构能力，那么你的简历上要不要突出这一点？一定要的。你要突出你在里面做过架构，所以你在这个自我评价这部分，我要体现出架构的一些经验，我在哪个公司做了什么事情，这套简历模板我这里也有，我等会发你们一下点，我头像进粉丝群好吗？
	我把这个东西全部打包发给你们，啊这里面大概有85万字的面试文档加上88套简历模板，你怎么去选都可以，啊你们只要点个关注就好了，嘛然后我是纯粹免费分享给大家。
92-【Java面试】在2G大小的文件中，找出高频top100的单词？-480P 清晰-AVC
	在一个g大写的文件中，快速找出高频Top100的单词，昨天一个工作5年的粉丝在面试的时候被这个问题直接问傻了，脑子完全转不过来，这种问题在面试过程中一般问的比较少，但是如果运气不好，正好遇到这个问题，可以在我之前整理的50万字的大场面指南里面去找到对应的回答。经过两年时间整理，呢大场面试指南已经涵盖了市面上99%以上的问题，大家可以在我的评论区的制定中去领取，这是一个典型的拓扑k的问题，在面试的时候呢会产生很多的变体，但是不管怎么变，啊 Top k这问题的本质是一样的。对于这一类的问题啊我们可以发散自己的思维，因为这种问题本身就没有什么标准答案，面试官更多的是去考察候选人的技术思维和技术积累，因此大胆一点回答是没有任何关系的，这个问题的关键因素有两个，一两g大小的文件意味着文件大，并且无法一次性漏到内存里面。第二，需要从这么大的文件中去筛选，如果用普通的思维方法查找的速度会比较慢，因此我们可以从这两个方面着手去思考回答思路。关于这个问题我说一下我的回答思路，第一，我们先把两g的文件分割成大小为512KB的小文件，总共会得到2048个小文件，避免一次性读取整个文件造成内存不足的问题。第二我们可以定一个长度为2048的哈希表数组，用来统计每个小文件中单词出现的频率。
	第三步我们可以使用多线程去并行便利2048小文件，针对每个单词进行哈奇曲目运算，分别存储到长度为2048的哈希表数组里面，接着我们再遍历这2048个哈希表，把频率前100的单词存入到一个小顶堆里面，最后小顶堆中最终得到100个单词，就是Top100了。这种解决方案的核心思想就是把大文件分割成多个小文件，然后采用分制和堆的算法来解决这个问题。以上就是我的回答思路。
90-【Java面试】SkipList的索引过程，能否越两级搜索？-480P 清晰-AVC
	Skip Blaise，也就是跳跃表的索引过程能否越两级搜索。这个问题是一个工作5年的粉丝在平安的第一面被问到的一个真实问题，这个问题呢他没有回答出来，今天正好有空给大家分享一下这个问题的回答思路。同时啊我把这个问题的回答整理到了一个50万字的面试文档里面，有需要的小伙伴可以在我的评论区置顶中去领取。跳跃表呢主要由几个部分构成，第一表头它负责维护跳跃表的节点指针。第二，跳跃表的节点它是保存元素值以及多少层。第三层这个概念呢保存的是指向其他元素的指针，高层的指针越过的元素数量会大于等于第一层的指针。为了提高查找的效率，程序总是先从高层开始去访问，然后随着元素的范围值的缩小去慢慢降低层次，表尾呢全部是由none来组成，表示跳跃表的一个末尾。我这样说大家理解起来觉得会有点复杂，简单来说就是在一个链表的基础上增加多层索引，这个层数是随机的，每一层索引都是原始链表的一个子集，并且索引元素的间隔逐层增大，这样就可以在一个较高的层级上进行一个快速搜索，从而减少搜索的时间复杂度。比如说在这样一个跳跃表中，想要查找88这个数字的位置，它可以通过逐层跳跃来快速找到，相比于链表来说啊查找性能会快很多。
	理解这样一个背景，呢我们再来看一下这个问题的回答。在一般情况下，跳表的查找过程是从最高层开始逐层向下查找的，每一次查找都是在当前城中找到小于目标元素的最大值，然后再跳转到下一层继续进行查找。如果最后找到了目标元素，就返回这个元素所在的节点，否则会返回空，所以对于跳跃表中的索引过程，啊并没有直接去跳跃两层解锁的情况，它也是逐层进行一个判断比较，最终去查找到目标元素。以上就是我的理解。

95-一册在手，offer我有！50万字Java求职面试终极指南!-480P 清晰-AVC
	Hello大家好，我是超级宠粉的麦克。为了帮助大家尽快找到心仪的工作，实现跳槽涨薪的目标，我特意准备了一份50万字的Java程序员求职面试手册，让你直接吊打面试官，里面包括19个技术章节，涵盖Java的方方面面，超过400个经典面试题，包含不报学员的真实面试案例，实时面试场景模拟，大场面试题，小场后端和高频面试题精选等等。每个题目啊我们都是从问题分析、答题思路、标准答案和面试点评4个方面去做一个深度的剖析。同时文档还附赠了不同年限的精美简历模板，程序员全生命周期的学习路线图以及对应的课程规划，各地区薪资普查表和职业路线图，不管你是求职还是跳槽都能够用得到。领取的方式我已经放在了评论区，有需要的小伙伴可以刷球分享领取，或者在我的主页简介中领取。
97-【Java面试】有1、2、3线程,让线程1在执行的时候立马执行线程3，线程3执行的时候立马执行线程2，怎么实现？-480P 清晰-AVC
	现在有一二三三个县城，我想让县城一在执行完以后立马执行县城三，限制三，执行完以后立马执行限制二，请问这个功能怎么实现？这是一个工作两年的粉丝在面试的时候遇到的一个问题，他以为这个问题很难回答，直到在面试结束以后啊去看了我给他的大场面试指南，发现这个时期原来这么简单，如果你们在面试过程中也有遇到这样的困扰，可以在我的评论区去领取。刚刚的那个大场面是指南，这个问题啊涉及到Java并发编程里面的知识，并发编程考察的方向还挺多的，建议大家可以专门去学习一下并发编程相关的知识体系。在姜末中可以直接使用three类提供的join方法来干预现成的执行顺序，join方法可以让当前线程等待另外一个线程执行完毕以后再继续执行。我们可以在线程一中去调用线程三的join方法，让线程一等待线程三执行完以后再继续执行。同样我们可以在限制三里面调用限制二的教育方法，让限制三等待限制二执行结束以后再继续执行。我们可以看一下这段代码，县城一中的代码里面创建了县城三，并且在启动县城三之后调用了join方法，让现在一等待现在三执行完毕以后再继续执行。
	同样在线程三的代码中创建了线程二，并且在启动线程二之后调用了join方法，让限制三等待限制二执行完毕以后再继续执行。最后通过调用star的方法启动线程一和线程二，这样就可以达到我们的目标。以上就是我的理解。
96-【Java面试】请简述Mysql的二阶段提交原理？-480P 清晰-AVC
	请减速麦c口二阶段提交的原理，一个工作了7年的粉丝啊表示，之前从来不知道卖SQL里面有二阶段提交这样一个概念，然后呢就以年龄大为理由，礼貌的拒绝了。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的评论区的指点中去领取。很多粉丝在面对这个问题的时候，第一反应绝对是懵的，因为他并不知道麦西口里面哪里涉及到二技能提交。实际上如果在max开启了冰log日志的情况下，在max事务提交的时候，需要同时完成radio log和冰log的事物写入big log和冰log，大家都知道一个是事务日志，另外一个是数据库变更的逻辑日志。这是两个独立的写入磁盘的动作，并且两个操作都要成功。而为了保证两个日志内容的一致性，需要用到两阶段的提交机制。麦西口的二技能提交啊发生在video log和宾logo的日志写入阶段，也就是把日志写入和日志提交拆分成两个阶段，来确保 radio log和宾log的写入的数据一致性。
	第一阶段是prepare阶段，在这个阶段中MSC我会把失误操作记录到redo log中，并标记为prepare状态。第二阶段是康妹的阶段，当事物提交的时候，max狗会将事物操作记录到冰log里面，然后把radio logo中的日志设置为康妹的状态，所以英斗DB在写radio logo的时候并不是一次性写完的，而是有两个阶段，prepare和康妹的这就是两阶段提交的含义，在这样一个设计中，如果在写入radio rock之前崩溃，那么此时redo log和bealock中是没有数据的，那么数据是满足一致性的，如果再写入redo log，prepare阶段立马崩溃了，那么之后会在崩溃恢复的时候，由于video中没有标记为康妹的，于是拿着radio local的事物ID去冰local中去查找，此时肯定是找不到的，那么这个时候就执行回滚操作。如果在写入冰logo后立马崩溃，在恢复的时候，由于radio logo中的事物ID可以找到对应的b log，那么这个时候可以直接提交数据，通过这个方式就可以保证radio log和宾log的数据一致性。以上就是我的理解。
104-【Java面试】limit 1000000,10 加载很慢该怎么优化？-480P 清晰-AVC

	昨天一个工作5年的粉丝去面试，被问到这样一个场景问题，通过name的语句去分页查询100万页，每一页查询10条，这个查询条件如果比较慢的情况下，我们应该怎么去优化？当时没有回答出来马尔向我求助，这个问题呢在我整理的30万字的大厂后端面试指南里面是有的，可以在评论区的置顶中去领取。关于这个问题呢有很多种解决方案，大家可以在回答的时候尽可能的考虑全面一点。第一种，如果ID是连续的，可以直接使用这样一个方式，这种方式其实就是先对数据做过滤，然后再lay，可以有效提升查询效率。第二个通过order by加索引来解决，需要注意ID是索引链，通过索引排序以后，再勒姆同样可以减少计算次数。第三个从业务层面来考虑，限制页数，一般情况下用户去翻100页来查找数据，如果让你们老板去翻100页，估计第二天就把你开除了，我们通常会通过搜索来优化查找过程。以上呢就是我对这个问题的回答思路，面试的时候不一定要完全陷入到面试官的逻辑里面，也可以跳出来思考。好的，今天的分享就到这里。Byebye。
93-【Java面试】如果发生内存泄漏怎么排查？-480P 清晰-AVC
	如果在生产环境上发现内存泄漏，我们应该怎么去排查呢？昨天一个工作了三年的粉丝在投递了200多家公司以后，终于约到了那次机会，好不容易遇到一个面试机会，因为没有实操过，所以被问到如果发生内存泄露该怎么排查这个问题的时候，他不知道怎么去回答。另外我把网签的内容都打包在了加我面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以去评论区的视频中去领取。关于内存泄露有关的面试题，呢在面试过程中的面试频率还挺高的，一方面啊它是一个比较重要的基础知识，另外一个方面我们写的所有程序都是运行在GPS上，在出现故障的时候，需要开发人员具备解决该问题的能力，这个问题分为两个部分，第一，什么是内存泄漏以及会带来什么样的影响？第二，内存泄露的排查和解决方法。内存泄露是指在程序运行的过程中，啊因为某些原因导致不需要使用的对象，仍然占用gbm，内存空间，并且这块内存还无法被回收，最终呢导致程序占用的内存越来越大，从而出现om的错误，或者影响程序的性能。一般情况下除了om这种错误以外，内存泄露也会出现一些比较明显的现象。
	比如说频繁的腹肌c内存占用量过大，一直无法释放等等。内存泄露的排查，呢我们一般会根据现象去定位问题。所以第一步我们会先去定位是否是内存泄露，比如说老年代逐步增长，富尔基c卡顿年轻带的内存一直在高位无法被释放，频繁富尔GC等等这些现象基本上都是内存出现异常。要了解GC的情况，我们可以使用GC的命令去查看虚拟机中各个内存的使用情况和GC情况，然后使用double工具去把当前那种down下来，然后使用mat工具来进行一个分析，如果当普的文件比较大，呢可以使用轻量级的在线分析工具，仅卖 mat工具会自动分析当铺文件的内容，给出一个分析结果，并定位到有问题的类。然后我们只需要根据分析的结果找到对应的代码进行优化就好了。一般情况下可能是循环引用，内存对象泄露没有被销毁，动态分配内存以后，释放长期持有对象引用资源未被关闭等等，以上就是我的理解。
99-【Java面试】gc年龄为什么要设置成15次？-480P 清晰-AVC
	最近啊一个工作了三年的粉丝在刷了几遍面试题以后，自信满满的去参加面试，前面的回答都还很顺利，回到基层年龄的时候也能够去准确的说出15这个词。但是没有想到的是面试官又继续问金星年龄为什么要设置成15次，可以超过15次吗？然后这位面试官以基础掌握不牢固为理由拒绝了。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字的面试文档，200份精选简历模板以及Java架构师学习路线图，大家可以在我的评论区的制定中去领取，这是GB内存划分和垃圾回收方面的基础问题，难度并不大。只要稍微了解过，对内存划分就能回答出来。比较难的点在于我们一定要去了解为什么默认只是种只要搞懂这个点，那么任何关于这个问题的变体，我们都能够回答出来，GC年龄的默认值是15，这个默认值15是通过实验和优化之后得到的一个比较合适的值，它可以在保证垃圾回收效率的前提下，尽可能的去减少移动到老年代中的对象数量，当然我们也可以通过这样一个参数来调整，但是这个值也有一些限制，它不能设置为一个负数或者0，这样会导致所有对象都直接进入老年代，而不会放置在新生代中进行垃圾回收，其次它的最大值是15，而且不能超过15。
	原因是对象的精神年龄啊是存储在对象头里面的，他里面分配了4个比特位来进行存储，而在二进制里面4个beta v的最大值就是15，以上就是我的理解。
94-【Java面试】高频面试题：MVCC过程中会加锁吗？-480P 清晰-AVC
	Mvcc过程中会加锁吗？昨天一个工作4年的粉丝在面试的时候呢被问到这个问题，他果断而自信的回答说不会，然后呢面试官就拒绝了他。后来啊在我给他的大厂面试指南里面看到答案以后，恍然大悟，经过两年时间的整理，啊大厂面试指南已经覆盖了市面上99%以上的问题，大家可以直接去评论区的制定中去领取。 Mvcc机制全称叫马TV选康凯润CTRL叫多版本并发控制，它是确保在高并发的情况下，多个事物读取数据的时候，布加索也可以多次读取相同的值。Mvcc在可重复读的事物隔离级别下，可以解决脏、毒、脏、血和不可重复毒等问题。我们知道mvcc呢是基于乐观锁的实现，所以很自然会想到mvcc是不枷锁的，这个问题呢也要看情况来回答。下面我们来看一下回答的建议。在mvcc中通常不需要枷锁来控制并发的访问，相反每个事物都可以读取到已提交的快照，而不需要去获取共享锁或者排他锁。在写操作的时候，mvcc会使用一种叫写实复制的技术，也就是在修改数据之前，先将数据复制一份，从而创建一个新的快照。
	当一个事物需要修改数据的时候，mvcc会首先检查修改数据的快照版本号，是否与该事物的快车版本一致，如果一致就表示可以修改这条数据，否则这个事物需要等待其他事物完成对该数据的修改。另外这个事物在新坏账上的修改的结果不会影响原始数据，其他事物可以继续读取原始数据的快照，从而解决脏、毒和不可重复毒的问题。所以正是有了mvc机制，让多个事物对同一个数据进行读写的时候，不需要枷锁，也不会出现读写冲突的问题。以上就是我的理解。
98-【Java面试】如何设计实现一个集群环境下的分布式单例模式？-480P 清晰-AVC
	前两天一个工作了8年的粉丝，在面试的过程中啊被问到单例模式的问题，他当时还暗自窃喜，因为他已经准备了7种单例模式的回答，结果面试官不按套路出牌，问他如何设计实现一个集群环境下的分布式淡定模式，顿时给闷散了。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图，他可以在我的评论区的置顶中去领取单例模式，相信每一个人都会，但是分布式集群下的单例模式就很困难了。大家如果在面试的时候遇到这个问题，肯定第一时间反应就是懵了，但是其实也不用着急。其实这个问题应该可以拆成两个部分，第一如何实现跨进程级别的单粒实力。第二，如何保障在任何时刻只有一个进程可以访问这个实力，一旦做到这两个点，那么基本上我们这个问题的答案就有了，但是关于第一个点，如果按照常规的单例模式的思路去思考，是无法去实现的，因为啊你不管怎么做，最终每个进程获取到的对象实例，在进程内的内存地址都是不一样的。所以我们应该换一个思路，也就是对象状态的唯一性，简单来说就是不同的进程在获取这个对象实例的时候，都能保持上一个进程，对这个状态修改之后的一个状态。
	首先我们可以把单例对象序列化保存到文件里面，然后再把这个文件存储到外部的共享存储组件里面。其次各个进程在使用这个单位对象的时候，先从外部共享存储组件里面去读取到内存，并且反序列化成对象来使用，最后当前进程使用完这个单粒对象以后，再把这个对象序列化以后，再存储回外部的共享组件里面，去实现更新，并显示的把当前这个对象实力从本地内存里面删除掉。据这样一个操作呢就能够保证各个进程对单例对象的状态一致性，但是因为多个进程可以同时访问这个单例对象，所以为了保证在任何时刻都只有一个进程去访问这个当地对象，所以我们就需要引入到分布式所的设计，也就是一个进程在获取到分布式，所以后才能访问这个共享代理对象，使用完以后再释放分布式锁。当然分布式所的实现可以使用中keep etcd release等等。以上就是我的理解。

