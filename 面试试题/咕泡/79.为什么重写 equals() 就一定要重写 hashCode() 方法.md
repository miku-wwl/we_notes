在 Java 中，如果你重写了 `equals()` 方法，通常也需要重写 `hashCode()` 方法。这是为了确保对象的 `equals()` 和 `hashCode()` 方法的行为一致，从而保持 Java 的 `Object` 类中定义的一些约定，这些约定对于某些数据结构（如哈希表）的正确工作是非常重要的。以下是为什么你需要同时重写 `equals()` 和 `hashCode()` 的几个原因：

### 1. 一致性

根据 Java 的 `Object` 类规范，如果两个对象相等（即 `equals()` 返回 `true`），那么它们的哈希码（`hashCode()` 返回的值）必须相等。如果只重写了 `equals()` 方法而不重写 `hashCode()` 方法，可能会导致违反这一约定，进而导致一些问题。

### 2. 哈希表的正确工作

Java 中的一些集合类（如 `HashMap`, `HashSet` 等）依赖于对象的 `hashCode()` 方法来定位元素的位置，然后通过 `equals()` 方法来确认元素是否是正确的。如果 `equals()` 方法返回 `true` 而 `hashCode()` 方法返回不同的值，那么这些集合类将无法正确地定位元素，从而导致数据丢失或行为异常。

### 3. 避免性能问题

如果 `equals()` 方法返回 `true` 而 `hashCode()` 方法返回不同的值，那么在哈希表中，即使两个对象相等，也可能被存储在不同的位置，这会导致性能问题。当查找对象时，哈希表会首先使用 `hashCode()` 方法来定位桶的位置，然后再使用 `equals()` 方法来确认对象是否相等。如果哈希码不一致，那么即使对象相等也无法正确定位，从而导致查找失败或增加查找时间。

### 例子

假设有一个类 `Person`，它有两个属性 `firstName` 和 `lastName`。如果我们只重写了 `equals()` 方法而不重写 `hashCode()` 方法，那么可能会导致以下问题：

```java
public class Person {
    private String firstName;
    private String lastName;

    public Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return firstName.equals(person.firstName) &&
               lastName.equals(person.lastName);
    }

    // 注意：这里没有重写 hashCode()
}

// 使用示例
HashMap<Person, String> map = new HashMap<>();
Person p1 = new Person("Alice", "Smith");
Person p2 = new Person("Alice", "Smith");

map.put(p1, "value1");
System.out.println(map.containsKey(p2)); // 应该输出 true，但实际上可能输出 false
```

### 解决方案

为了确保 `equals()` 和 `hashCode()` 方法的行为一致，应该同时重写它们：

```java
public class Person {
    private String firstName;
    private String lastName;

    public Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return firstName.equals(person.firstName) &&
               lastName.equals(person.lastName);
    }

    @Override
    public int hashCode() {
        int result = firstName.hashCode();
        result = 31 * result + lastName.hashCode();
        return result;
    }
}
```

### 总结

为了保证对象在哈希表中的正确存储和查找，以及遵守 Java 规范中的约定，如果你重写了 `equals()` 方法，就应该同时重写 `hashCode()` 方法。这样可以确保 `equals()` 和 `hashCode()` 方法的行为一致，从而避免潜在的问题。