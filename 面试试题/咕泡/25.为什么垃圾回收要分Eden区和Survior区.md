https://www.bilibili.com/video/BV16Z421T7dh/?spm_id_from=pageDriver&vd_source=e68d16a745abc4950a26a5336414bb34
 

在 Java 中，垃圾回收器（Garbage Collector, GC）负责自动管理和回收不再使用的对象所占用的内存空间。为了提高垃圾回收的效率，Java 虚拟机（JVM）将堆内存划分为不同的区域，并采用了不同的垃圾回收策略。其中，新生代（Young Generation）通常被进一步划分为三个部分：Eden 区和两个 Survivor 区（通常标记为 S0 和 S1）。下面是为什么需要这样划分的原因：

### 1. 短暂对象的快速回收

大部分对象的生命期都很短暂，特别是在 Web 应用、服务器端应用等场景下。对象创建后很快就不再使用，如果不对这些短暂存在的对象进行快速回收，就会导致大量的内存浪费。

### 2. 复制算法的优势

Eden 区和 Survivor 区的设计是为了更好地利用复制算法（Copy Collection）的优点。复制算法的基本思想是在两个同样大小的空间之间来回复制存活的对象，而不是对整个区域进行清理。这样做的好处是可以避免对象碎片化的问题，并且只需要扫描和复制存活的对象，大大减少了 GC 的工作量。

### 3. 对象晋升机制

对象在 Eden 区中创建后，经过一次 Minor GC（也称为 Young GC）之后，如果对象仍然存活，则会被移动到 Survivor 区。Survivor 区通常有两个，以便在多次 Minor GC 之后，仍然存活的对象可以逐步晋升到老年代（Old Generation）。

### 4. 年龄提升机制

对象在 Survivor 区中每经历一次 Minor GC 并且存活下来，它的年龄就会增加一岁。当对象的年龄达到一定的阈值（默认为 15 岁），对象就会晋升到老年代。这样可以确保只有那些真正需要长期保存的对象才会被转移到老年代，从而避免老年代过快地填满。

### 5. 空间效率

通过使用 Survivor 区，可以确保只有那些值得保留的对象才会被保留下来，这样可以有效地减少内存空间的浪费。同时，由于大部分对象很快就会被回收，所以 Eden 区可以频繁地进行垃圾回收而不影响性能。

### 6. 延迟老年代的填充

通过对象晋升机制，可以让那些存活时间较长的对象进入老年代，从而延迟老年代的填充速度，减少 Full GC 的频率。

### 具体实现

在 HotSpot 虚拟机中，新生代的分配如下：

- **Eden 区**：用于存放新创建的对象。
- **Survivor 区**：通常有两个，即 S0 和 S1，它们的大小相同。每次 Minor GC 之后，Eden 区中的存活对象会被复制到一个 Survivor 区中，另一个 Survivor 区则清空。下次 Minor GC 时，再交换这两个 Survivor 区的角色。

### 总结

通过将新生代划分为 Eden 区和 Survivor 区，Java 虚拟机能够更高效地处理短暂对象的回收，并通过复制算法和对象晋升机制来优化内存管理和减少 GC 的开销。这样的设计使得 JVM 能够更好地适应不同类型的应用场景，特别是在需要频繁创建和销毁对象的应用中表现尤为出色。
