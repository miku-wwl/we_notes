
/**/
说一说my betas里面的缓存机制，唉呀我是myco。昨天一个工作4年的粉丝去面试，被问到拍bets里面的缓存基博士了半天没有回答出来，然后回来就在群里面抱怨说面试太久了，实际上呢 my best多级缓存在开发中是会用到的一些功能，如果这个部分没有弄清，主可能会出现一些莫名其妙的问题，最后还得通过百度来帮你解决，个人能力呢还是没有得到提升。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图。回到正题，max里面设计的二级缓存是用来提升数据的检索效率，避免每次数据的访问都需要去查询数据库，一级缓存是是一个c型级别的缓存，也叫本地缓存，因为每个用户在执行查询的时候都需要去使用这个 c型来执行。为了避免每次都去查数据库，买贝利斯呢把查询出来的数据保存到sex的本地缓存中，后续的c口如果命中缓存就可以直接从本地缓存中去读取，如果我们想去实现跨c和c型级别的缓存，那么一级缓存就无法实现，因此在max里面设计了二级缓存。
	就是当多个用户在查询数据的时候，只要有任何一次SQL拿到了数据就会放入到二级缓存里面，其他的c和c区呢就可以直接从二级缓存里面去加载数据，一级缓存的距离实现原理是在c可c区里面只有一个xq头，每一个SQL里面呢有一个叫logo case的对象，当用户发起查询的时候，my best会根据执行语句在logo case里面去查询，如果没有命中缓存再去查询数据库里面，并写入到洛克case里面，否则直接返回，所以啊一级缓存的生命周期是c个c型，而且在这样一个设计里面可能会存在数据的张图问题，比如说在多个c和c型或者分布式环境下，我们的每一个c和c型或者每一个节点都缓存了一份数据，那么我们在进行数据查询的时候可能会拿到一个脏的数据，二阶缓存的具体实现原理是使用k7x修饰了sq头，所以在进入一级缓存的查询流程之前，会先通过k区x口进行二级缓存的查询，开启二级缓存以后会被多个CC型共享，所以它是一个全局缓存。
	因此它的查询流程是先查二级缓存，再查一级缓存，最后再查数据库。另外卖贝利斯的二级缓存相对于一级缓存来说，实现了c可c型之间的缓存数据的共享，同时缓存力度也能够控制到name、space的级别，并且我们还可以通过实现k线接口来实现缓存的不同组合，对k型的可控性也更强，多级缓存的设计思想非常常见，比如说像拉cos纽约卡里面都有用到，学习这一块的思想，呢有助于提升解决问题的能力。好了，今天分享就到这里，在面试的时候大家还有遇到哪些比较难的问题，欢迎在评论区给我留言。