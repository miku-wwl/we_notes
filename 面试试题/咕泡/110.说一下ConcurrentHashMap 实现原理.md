谈谈concurrent Ashe map，在实现原理之前分享过一期哈希map的面试题，然后有个小伙伴私信我说他遇到了一个康卡伦的哈希迈克的面试题，不知道该怎么回答，于是呢就有了这一期的内容。Hello大家好，我是酷跑科技的联合创始人麦克，今天我给大家分享一下这个面试题的回答思路，如果你想要文字版本的回答，可以在我的评论区的置顶中去免费领取30万字的面试文档。这个文档包括了各个一线大厂的面试真题，而且每道题目都有详细的解答，能够帮助你们对面试题的更深度的理解，从而去更好的应对面试的一个场景。这个问题我需要从三个方面来回答。这个呢是康康的哈希迈普在GDP1.8中的存储结构，它是由数组单向电表和红黑数组成。当我们初始换一个康凯尔哈希迈普实力的时候，默认会初始化一个长度为16的数组。由于康康的哈希map它依然是一个哈希表，所以它必然会存在哈希冲突的问题。慷慨哈西卖不采用链式荀子法来解决哈希冲突，当哈希冲突比较多的时候就会造成链表过长，这种情况就会使得康凯伦的哈希脉搏中数据元素的查询复杂度变成了on因此在gdk1.8中引入了红黑素的机制，当速度长度大于64，并且链表长度大于等于8的时候，单项电表就会转化为红黑素。
	另外随着Kanye哈希卖GB的动态扩容，一旦电表长度小于6，红黑素就会退化成单项链表，慷慨的哈希卖本质上是一个哈希卖，因此功能和还是卖不是一样的。但是康凯轮的哈希不在哈西卖的基础上，提供了并发安全的实现，病房安全主要实现是通过对指定的no的节点枷锁来保证数据更新的安全性，如何在并发性能和数据安全性之间做好平衡，在很多地方都有类似的设计，比如说CPU的三级缓存，my circle的buff，星空net的所升级等等。康看着哈希曼也做了类似的优化，主要体现在以下几个方面。第一，在jdk1.8中，康凯伦的哈希迈普的所的力度是宿主的某一个节点，而在jk1.7中呢锁定的是一个sad门，锁的范围更大，因此呢性能上会更低。第二引入了红黑素，降低了数据查询的时间复杂度。红黑素的时间复杂度是o跟第三，当宿主程度不够的时候，康凯瑞哈希迈普需要对宿主进行扩容，在扩容的时间上，康看了哈希迈普引入了多线程并发扩容的机制，简单来说就是多个线程对原始数据进行分片以后，每个县城负责一个分片的数据迁移，从而提升了扩容过程中的数据迁移的效率。
	康凯尔哈希迈普中呢也有一个赛制方法来获取总的元素个数，在多线程并发场景中，在保证原子性的前提下，来实现元素个数的累加，性能是非常低的。康凯伦的哈希迈普在这个方面的优化主要体现在两个点上。第一，当线程竞争不激烈的时候，直接采用case的机制来实现元素个数的原子递增。第二，如果现成竞争激烈的情况下，使用一个数组来维护元素个数，如果要增加总元素个数，则直接从数组中随机选择一个，再通过case来实现原子递增。它的核心思想是引入了一个宿主来实现对并发更新的负载均衡，降低了锁的竞争。以上就是我对这个问题的理解，我是麦克，感谢大家关注和点赞。我们下期再见。