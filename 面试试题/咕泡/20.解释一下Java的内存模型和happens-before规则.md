Java 内存模型（Java Memory Model, JMM）是为了确保多线程程序中的内存一致性而设计的一套规定。Java 内存模型定义了程序中各个变量的访问规则，以及线程间通过共享变量传递信息的抽象机制。在 Java 中，多线程环境下变量的可见性、有序性和原子性是通过内存模型来保证的。

### Java 内存模型的核心概念

Java 内存模型主要关注以下几个方面：

1. **主内存（Main Memory）**：所有线程共享的内存区域，用来存储对象实例和静态变量等。
2. **工作内存（Working Memory）**：每个线程私有的内存区域，用来存储线程使用的变量的副本（如局部变量、方法参数等）。

### Java 内存模型的关键原则

Java 内存模型定义了一些规则来确保多线程程序的一致性，其中最重要的概念之一就是“发生先于”（Happens-before）原则。

### Happens-before 规则

Happens-before 是一种偏序关系，用来描述两个操作之间的顺序。如果一个操作 A happens-before 另一个操作 B，那么从 JMM 的角度来看，操作 A 就发生在操作 B 之前。如果一个操作 happens-before 另一个操作，那么前者对共享变量的所有修改对于后者都是可见的，并且所有的 side effects 对后者来说都是有序的。

Java 内存模型定义了以下几种 happens-before 关系：

1. **程序顺序规则**：
   - 程序中的执行顺序决定了 happens-before 关系。如果在单个线程内，操作 A 发生在操作 B 之前，那么 A happens-before B。
2. **锁定规则**：

   - 一个 unlock 操作 happens-before 同一锁的后续 lock 操作。这意味着解锁一个锁的线程的所有修改对于随后加锁同一锁的线程来说是可见的。

3. **volatile 变量规则**：

   - 对 volatile 变量的写操作 happens-before 后续对同一个 volatile 变量的读操作。这意味着一个线程对 volatile 变量的写入对于其他线程对该变量的读取是可见的。

4. **线程启动规则**：

   - 线程 start 方法的调用 happens-before 任何线程执行的操作。这意味着主线程启动一个新线程时，主线程对共享变量的修改对于新线程来说是可见的。

5. **线程终止规则**：

   - 线程中的所有操作 happens-before 线程的终止（即 `Thread.join()` 返回）。这意味着线程中所有对共享变量的修改对于主线程调用 `join` 方法后是可见的。

6. **传递性**：
   - 如果 A happens-before B，且 B happens-before C，则 A happens-before C。

### 示例说明

让我们通过一个具体的例子来说明 happens-before 规则的应用：

#### 示例代码：

```java
public class HappensBeforeExample {
    private volatile boolean ready = false;
    private int number = 0;

    private class ReaderThread extends Thread {
        public void run() {
            while (!ready) { // 等待 ready 变为 true
                Thread.yield();
            }
            System.out.println(number); // 输出 number 的值
        }
    }

    public void writerMethod() {
        number = 42;
        ready = true; // 设置 ready 为 true
    }

    public static void main(String[] args) throws InterruptedException {
        HappensBeforeExample example = new HappensBeforeExample();
        ReaderThread readerThread = example.new ReaderThread();
        readerThread.start();
        example.writerMethod();
        readerThread.join();
    }
}
```

#### 解释：

在这个例子中，`ready` 是一个 volatile 变量，用来通知 `ReaderThread` 是否可以开始读取 `number` 的值。当主线程调用了 `writerMethod` 方法后，它修改了 `number` 和 `ready` 变量。由于 `ready` 是 volatile 变量，因此 `writerMethod` 中对 `ready` 的写操作 happens-before `ReaderThread` 中对 `ready` 的读操作。这意味着 `ReaderThread` 读取到 `ready` 为 `true` 时，可以看到 `number` 已经被设置为 `42`。

### 总结

Java 内存模型通过一系列规则确保了多线程程序的一致性和安全性。Happens-before 规则是其中的核心概念之一，通过定义操作之间的偏序关系，确保了共享变量的可见性和有序性。理解这些规则对于编写正确的多线程程序至关重要。
