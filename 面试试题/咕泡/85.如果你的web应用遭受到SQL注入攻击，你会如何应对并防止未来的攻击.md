当Web应用遭遇SQL注入攻击时，应立即采取紧急措施，并制定长期计划来防止未来的攻击。以下是应对SQL注入攻击的详细步骤：

### 1. 立即响应

#### 1.1 确认攻击
- **检查日志**：查看服务器和应用的日志，寻找异常的SQL查询或错误信息。
- **验证攻击**：通过数据库查询记录或审计日志来确认是否存在异常的SQL查询。

#### 1.2 阻止攻击
- **暂时禁用受影响的功能**：如果可以确定某个功能存在漏洞，可以暂时禁用该功能，以防止进一步的损害。
- **封堵恶意IP**：根据日志信息，封堵发起攻击的IP地址或IP段。

### 2. 短期内的修复

#### 2.1 修复漏洞
- **使用预编译语句或参数化查询**：确保所有的SQL查询都使用预编译语句（Prepared Statements）或参数化查询（Parameterized Queries），而不是字符串拼接的方式。
  - **示例代码（PHP）**：
    ```php
    $stmt = $pdo->prepare('SELECT * FROM users WHERE username = :username');
    $stmt->execute(['username' => $username]);
    $users = $stmt->fetchAll();
    ```
  - **示例代码（Python）**：
    ```python
    cursor.execute("SELECT * FROM users WHERE username = %s", (username,))
    users = cursor.fetchall()
    ```

#### 2.2 输入验证
- **输入验证**：对所有用户输入进行严格的验证，确保输入符合预期格式，防止非法字符进入SQL查询。
  - **示例代码（JavaScript）**：
    ```javascript
    function validateInput(input) {
        const regex = /^[a-zA-Z0-9_]*$/;
        if (!regex.test(input)) {
            throw new Error('Invalid input');
        }
        return input;
    }
    ```

#### 2.3 输出转义
- **输出转义**：对于需要动态生成的SQL查询，确保所有用户输入都进行了适当的转义处理。
  - **示例代码（Python）**：
    ```python
    import html
    username = html.escape(username)
    ```

### 3. 长期防御策略

#### 3.1 代码审查
- **定期代码审查**：建立定期的代码审查机制，确保所有涉及数据库查询的代码都符合安全标准。
- **使用静态代码分析工具**：使用静态代码分析工具（如 SonarQube、FindBugs）来自动检测潜在的安全漏洞。

#### 3.2 安全意识培训
- **培训开发人员**：定期对开发人员进行SQL注入攻击防范的培训，提高安全意识。
- **最佳实践文档**：编写并维护一份关于SQL注入防御的最佳实践文档，供团队成员参考。

#### 3.3 使用ORM框架
- **ORM框架**：使用ORM（Object-Relational Mapping）框架（如 Hibernate、Entity Framework、Django ORM）来管理和执行数据库操作，减少手动生成SQL查询的机会。

#### 3.4 安全审计
- **定期安全审计**：定期进行安全审计，检查系统的安全性和漏洞。
- **渗透测试**：定期进行渗透测试，模拟攻击者的行为，找出潜在的安全漏洞。

#### 3.5 日志和监控
- **增强日志记录**：增强日志记录功能，记录所有SQL查询和异常情况，便于日后分析。
- **实时监控**：使用实时监控工具（如 Prometheus、Grafana、ELK Stack）来监控系统的运行状态，及时发现异常情况。

### 4. 示例代码

以下是一个使用 Python 的 SQLAlchemy ORM 框架来执行安全的数据库查询的示例：

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = Column(String)

engine = create_engine('sqlite:///example.db')
Base.metadata.create_all(engine)

Session = sessionmaker(bind=engine)
session = Session()

# 安全地插入数据
new_user = User(username='alice')
session.add(new_user)
session.commit()

# 安全地查询数据
result = session.query(User).filter_by(username='alice').first()
print(result.username)
```

### 总结

面对SQL注入攻击，首先需要迅速采取措施阻止攻击，然后立即修复漏洞。长期来看，需要建立一套完整的防御体系，包括代码审查、安全培训、使用ORM框架、定期安全审计等。通过这些措施，可以有效预防未来的SQL注入攻击，并提高系统的整体安全性。