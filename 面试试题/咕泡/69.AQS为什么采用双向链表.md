AQS（AbstractQueuedSynchronizer）是 Java 并发包 `java.util.concurrent.locks` 中的一个抽象类，它为实现自定义同步器提供了基础框架。AQS 主要用于构建锁和其他同步组件，如 `ReentrantLock`, `Semaphore`, `CountDownLatch` 等。

AQS 使用了一个双向链表（FIFO 队列）来管理那些等待获取同步状态的线程。这里有几个原因说明为什么 AQS 选择了双向链表：

### 1. FIFO（先进先出）特性

AQS 的等待队列遵循 FIFO（先进先出）原则，即最先等待的线程应当最先获得同步状态。双向链表能够很好地支持这一特性，因为它允许高效地在队列的头部添加和删除节点。

### 2. 线程等待和唤醒

当一个线程调用 `acquire` 方法试图获取同步状态时，如果当前状态不允许，则线程会被挂起并加入到等待队列中。当同步状态可用时，等待队列中的线程需要被唤醒并恢复执行。双向链表可以方便地支持这样的操作，即在队列尾部添加等待线程，在队列头部移除并唤醒线程。

### 3. 线程取消

在某些情况下，等待队列中的线程可能需要被取消（例如，由于超时或者中断）。双向链表使得可以从中间位置移除一个节点变得容易，而不需要遍历整个队列。

### 4. 高效的插入和删除操作

双向链表提供了对节点的快速插入和删除操作，这对于高并发环境下的性能至关重要。在 AQS 中，线程被包装成 `Node` 对象，并通过双向链接的方式组织成一个队列。每个 `Node` 包含对前一个节点和后一个节点的引用，这使得插入和删除操作都非常高效。

### 5. 线程间的通信

AQS 中的双向链表不仅支持线程的等待和唤醒操作，还支持线程间的通信。例如，当一个线程释放了同步状态后，它需要唤醒等待队列中的下一个线程。双向链表的结构使得这种操作变得简单。

### 示例代码

下面是一个简化的示例，展示如何在 AQS 中管理等待队列：

```java
public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer {
    private static final long serialVersionUID = 7316153563782823691L;

    // Node 类，表示等待队列中的一个元素
    private static class Node {
        // 状态，例如等待原因（条件变量等待、中断等）
        volatile Node prev;
        volatile Node next;
        volatile Thread thread;
        // 等待状态
        volatile int waitStatus;

        Node(Thread thread, Node mode) {
            this.thread = thread;
            this.prev = mode;
        }

        // 其他方法...
    }

    // 头节点
    private transient volatile Node head;
    // 尾节点
    private transient volatile Node tail;

    // 添加到队尾
    protected void enqueue(Node node) {
        // 省略部分代码
        Node t = tail;
        if (t == null) {
            doInsert(node);
        } else {
            t.next = node;
            node.prev = t;
            tail = node;
        }
    }

    // 从队头移除
    protected Node removeHead() {
        // 省略部分代码
        Node h = head;
        if (h != null && h != tail) {
            Node s = h.next;
            unlinkFirst(h);
            return s;
        }
        return null;
    }

    // 插入节点
    private void doInsert(Node node) {
        // 省略部分代码
        if (tail == null) {
            head = tail = node;
        } else {
            tail.next = node;
            node.prev = tail;
            tail = node;
        }
    }

    // 移除节点
    private void unlinkFirst(Node node) {
        // 省略部分代码
        node.next.prev = null;
        head = node.next;
        node.next = null;
    }

    // 其他方法...
}
```

### 总结

AQS 使用双向链表来管理等待队列的原因在于它能够高效地支持线程的等待、唤醒、取消以及插入和删除操作。此外，双向链表还能简化线程间的通信机制，使得 AQS 能够更好地适应高并发环境下的同步需求。