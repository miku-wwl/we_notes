在一些公司中，禁止使用`@Transactional`声明式事务管理的做法可能是出于多种考虑，这些考虑通常与性能、可维护性、安全性和团队经验有关。以下是可能导致公司禁止或限制使用`@Transactional`的一些原因：

### 1. 性能考虑

- **性能开销**：`@Transactional`注解通常会导致AOP（面向切面编程）的增强，这会增加一定的性能开销。虽然这种开销通常很小，但对于高性能、高并发的应用来说，累积起来可能会成为一个问题。
- **锁定问题**：如果事务管理不当，可能会导致锁定时间过长，进而影响并发性能。例如，长时间持有数据库锁可能会导致其他事务等待甚至超时。

### 2. 可维护性和复杂性

- **隐式事务边界**：使用`@Transactional`可能会隐藏事务的边界，使得事务的开始和结束变得不明显。这对于代码的可读性和可维护性来说可能是一个问题。
- **事务传播行为**：如果不正确地配置事务的传播行为（如`PROPAGATION_REQUIRED`、`PROPAGATION_SUPPORTS`等），可能会导致嵌套事务的问题，进而影响事务的一致性和隔离性。

### 3. 安全性和数据一致性

- **错误的事务边界**：如果事务边界定义错误，可能会导致数据不一致的问题。例如，在一个事务内未正确处理异常，可能会导致部分操作成功而部分失败。
- **事务隔离级别**：如果事务的隔离级别设置不当，可能会导致脏读、不可重复读等问题。

### 4. 团队经验和最佳实践

- **团队技能**：如果团队成员对声明式事务管理的理解不够深入，可能会误用`@Transactional`，导致上述提到的各种问题。
- **最佳实践**：一些公司可能有自己的最佳实践和编码规范，他们倾向于使用编程式事务管理（即通过编程的方式显式地开启、提交或回滚事务），以确保事务管理的一致性和明确性。

### 5. 调试和诊断

- **调试困难**：声明式事务管理可能会使调试变得更加困难，尤其是在复杂的事务逻辑下。编程式事务管理通常更加显式，易于跟踪事务的开始和结束点。

### 6. 框架限制

- **框架兼容性**：某些情况下，使用声明式事务管理可能会遇到框架兼容性问题，尤其是在使用一些特定的ORM工具或数据库驱动时。

### 示例：编程式事务管理

编程式事务管理通常涉及显式地开启事务，并在适当的时候提交或回滚事务。例如，在Spring框架中，你可以这样做：

```java
@Autowired
private PlatformTransactionManager transactionManager;

public void performOperation() {
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    TransactionStatus status = transactionManager.getTransaction(def);

    try {
        // 执行业务逻辑
        // ...
        
        transactionManager.commit(status);
    } catch (Exception e) {
        // 出现异常时回滚事务
        transactionManager.rollback(status);
        throw e; // 重新抛出异常，以便上层处理
    }
}
```

### 总结

尽管如此，`@Transactional`仍然是一个非常强大且方便的特性，它简化了事务管理的代码编写。是否禁用`@Transactional`主要取决于公司的具体情况和技术决策。在很多情况下，使用`@Transactional`仍然是推荐的做法，特别是当团队成员熟悉其用法，并且性能不是关键瓶颈时。最终的决定应该基于对项目的具体需求、团队经验和最佳实践的综合评估。