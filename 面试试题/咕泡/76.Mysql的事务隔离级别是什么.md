MySQL 的事务隔离级别定义了事务在执行过程中与其他事务的交互方式，以及如何处理并发事务之间可能产生的问题，如脏读（Dirty Reads）、不可重复读（Non-repeatable Reads）和幻读（Phantom Reads）等。MySQL 支持四种事务隔离级别，分别是：

1. **READ UNCOMMITTED（未提交读）**
2. **READ COMMITTED（已提交读）**
3. **REPEATABLE READ（可重复读）**
4. **SERIALIZABLE（可串行化）**

### 1. READ UNCOMMITTED（未提交读）

这是最低的隔离级别，允许事务读取尚未提交的数据（脏读）。在这种隔离级别下，事务可以看到其他事务未提交的数据更改。虽然这种隔离级别可以提高并发性能，但由于数据的不稳定性，通常不推荐使用。

### 2. READ COMMITTED（已提交读）

在这个隔离级别下，事务只能读取已经提交的数据。这意味着事务不会看到其他事务未提交的数据更改。这个隔离级别避免了脏读的问题，但在并发事务较多的情况下，可能会导致不可重复读的现象。

### 3. REPEATABLE READ（可重复读）

这是 MySQL 默认的隔离级别。在这个隔离级别下，事务在整个事务期间看到的数据是一致的，即使有其他事务在此期间提交了新的数据更改。这意味着事务在执行期间可以多次读取同一数据，并且得到相同的结果。但是，这个隔离级别仍然不能完全避免幻读的问题，即在事务执行过程中，其他事务插入的新行导致查询结果发生变化。

### 4. SERIALIZABLE（可串行化）

这是最高的隔离级别，它可以确保事务之间完全隔离，如同事务是按照某种顺序串行执行的一样。这种隔离级别可以避免所有并发问题，包括脏读、不可重复读和幻读。但由于其严格的锁定机制，可能导致大量的事务等待，影响性能。

### MySQL 默认隔离级别

MySQL 的默认隔离级别是 **REPEATABLE READ**。这意味着在默认情况下，事务在整个事务期间看到的数据是一致的，即使有其他事务在此期间提交了新的数据更改。这个隔离级别通常在大多数应用场景中提供了足够的隔离性，并且在并发性能和数据一致性之间达到了一个较好的平衡。

### 如何设置事务隔离级别

在 MySQL 中，可以通过以下方式设置事务隔离级别：

#### 1. 动态设置（使用 SQL 语句）

```sql
-- 设置事务隔离级别为 READ UNCOMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 设置事务隔离级别为 READ COMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 设置事务隔离级别为 REPEATABLE READ （默认）
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 设置事务隔离级别为 SERIALIZABLE
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

#### 2. 配置文件设置（my.cnf 或 my.ini）

在 MySQL 的配置文件中设置全局的事务隔离级别：

```ini
[mysqld]
transaction_isolation = REPEATABLE-READ
```

### 选择合适的隔离级别

选择合适的事务隔离级别需要权衡数据一致性和并发性能之间的关系。在实际应用中，通常会根据具体的业务需求和并发情况来选择合适的隔离级别。例如：

- 如果需要保证数据的一致性，并且可以接受一定程度的性能损失，可以选择 **SERIALIZABLE**。
- 如果希望在并发性能和数据一致性之间取得平衡，可以选择 **REPEATABLE READ** 或 **READ COMMITTED**。
- 如果对并发性能要求非常高，并且可以接受一定程度的数据不一致性，可以选择 **READ UNCOMMITTED**。

在实际开发中，建议根据具体的应用场景和需求来选择合适的事务隔离级别，并通过测试来验证其效果。


/**/
Miss的事物隔离级别是什么？什么情况？写了5年的ciud还搞不清楚max口的数隔离节约，难怪呢在第一面就被刷下来了。一个工作了5年的粉丝在一个公司干了5年，觉得自己特别厉害，什么都能搞定，结果每次一到技术面就被刷，那我该怎么办？原本我是想让他系统学习一下，但是他已经找了两个月工作，急需要快速找到一份工作稳定下来。另外我把网签的内容都打包在了Java面试指南中，里面包含了35万字面试文档，200份精选简历模板以及Java架构师学习路线图。回到正题，啊事务隔离级别啊是为了解决多个并行事务竞争导致的数据安全性问题的一种规范，具体来说多个事物竞争可能会出现三种不同的现象。第一种假设两个事物，t一和t二同时在执行，t15有可能会读取到t2之5未提交的数据，未提交的事物t二可能会回滚，也就导致了t一事物读取到最终不一定存在的数据产生张图的现象。第二个假设有两个事物，t一和t二同时执行事物t一在不同的时刻读取同一行数据的时候，结果可能不一样，从而导致不可重复读的问题。
	第三种，假设两个事物t一和t二同时执行，事物t一执行范围查询或者范围修改的过程中，事物t二插入了一条属于事物t一查询范围内的数据，并且提交了这时候在事物t一查询中发现多出了一条数据，或者在t一事务执行过程中发现这些数据没有被修改，看起来好像是产生了幻觉，这种现象呢我们称为幻族，而这三种现象在实际开发过程中可能有些场景不能接受某些现象的存在，所以在CK标准中定义了4种隔离级别，分别是不未提交，在这种隔离级别下可能会产生脏、毒、不可重复毒和贩毒。第二种是无以提交，在这种事物可能节约下可能会产生不可重复读和换读。第三组是烤重复读，在这种隔离级别下可能会产生幻毒。第四种是串行化。在这种隔离级别下，多个并行事务串行化执行不会产生安全性问题。在这种隔离级别里面，只有串行化彻底解决了全部问题，但也意味着这种隔离级别的性能是最低的。在massica里面，英诺DB引擎默认的隔离级别是安二也叫可重复读，因为它需要保证事物acid特性中的隔离性特征。
	好了，今天分享就到这里。在面试的时候大家还有遇到哪些比较难的问题和有趣的问题，欢迎在评论区给我留言。