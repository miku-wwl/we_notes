/**/
卡夫卡的领考背原理，最近一个学员去京东面试，在第一面的时候遇到这样一个问题，请你简单说一下卡夫卡零拷贝的原理。Hello大家好，我是酷爆科技的联合创始麦克。今天给大家分享一下这个面试题的回答思路。另外如果你想用文字版本的回答，可以在我的评论区的制定中去领取30万字的面试文档，这个文档不仅包含了各个一线大厂的常见面试真题，而且对每道题目都进行了详细的解答，能够很好的帮助大家提高面试的通过率。在实际应用中，如果我们需要把磁盘中的某个文件内容发送到远程服务器上，那么它必须要经过这样几个拷贝过程。第一，从磁盘中读取目标文件的内容，拷贝到内核缓冲区。第二CPU控制器，再把内核缓冲区的数据复制到用户空间的缓冲区中。第三，在应用程序中调用write方法，把用户空间缓冲区的数据拷贝的内核的sock的巴菲尔中，最后把在内核模式下收开了巴甫中的数据，复制到网卡缓冲区，网卡缓冲区再把数据传输到目标服务器上。在这个过程中我们可以发现数据从磁盘到最终发送出去，要经历4次拷贝，而在这4次拷贝过程中，有2次拷贝是浪费的，分别是从内核空间复制到用户空间，再从用户空间再次复制到内核空间。
	除此之外，由于用户空间和内部空间的切换，会带来上下文的一个切换，对CPU的性能也会造成一些影响。而零拷贝就是把这两次多余的拷贝省略掉，应用程序可以直接把磁盘中的数据从内核直接传送到说ok的，而不再需要经过应用程序所在的用户空间，零拷贝通过dma技术把文件内容复制到内核空间的的buffer，接着把包含数据位置和长度信息的文件描述服务加载到索克的buff中，dma引擎直接把数据从内核空间传递给网卡设备。在这样一个流程中，数据只经历了两次拷贝就发送到了网卡中，并且减少了两次CPU的上下文切换，对效率有非常大的提高。所以啊所谓领拷贝并不是完全没有数据复制，只是相对用户空间来说，不再需要进行数据的拷贝。对于前面说的整个流程来说，零拷贝只是减少了不必要的拷贝次数而已。那么在程序中如何去实现零拷贝呢？在Linux系统中零拷贝技术依赖于底层的sendfile方法来实现，而在Java中 fire China点transfer to这个方法，底层实现就是用到了sendfile方法。
	除此之外还有一个叫mm的文件映射机制，它的原理是将磁盘文件映射到内存，用户通过修改内存就能够修改磁盘文件，使用这个方式可以获得很大的io提升，省去了用户空间和内部空间的复制开销。以上就是我对于卡夫卡中临考背原理的理解，我是麦克，感谢大家点赞和关注。我们下期再见。