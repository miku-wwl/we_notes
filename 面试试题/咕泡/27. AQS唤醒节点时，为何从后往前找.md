https://www.bilibili.com/video/BV12H4y1c7ew/?spm_id_from=pageDriver&vd_source=e68d16a745abc4950a26a5336414bb34 


在 Java 的并发工具包 `java.util.concurrent` 中，`AbstractQueuedSynchronizer`（简称 AQS）是一个用于构建锁和其他同步组件的基础框架。AQS 使用一个 CLH 锁队列（Craig-Landin-Harris lock queue）来管理等待的线程，该队列是一个双向链表结构，每个节点代表一个等待的线程。

### AQS 的核心结构

AQS 中有几个关键的概念：

- **独占锁**：只有一个线程可以获得锁。
- **共享锁**：多个线程可以同时获得锁。
- **CLH 锁队列**：等待锁的线程被组织成一个双向链表。

### CLH 锁队列的特点

CLH 锁队列是由 Peter Harris 在 1991 年提出的一种无锁队列算法，其特点是不需要额外的锁来保护队列本身。CLH 锁队列中的节点具有以下特点：

- **头节点**（Head Node）：当前持有锁的节点，或者最后一个尝试获取锁失败的节点。
- **尾节点**（Tail Node）：队列的最后一个节点，新加入的节点会成为新的尾节点。

### 唤醒节点的原理

当一个线程释放了锁，AQS 需要唤醒下一个等待的线程使其有机会获得锁。在 CLH 锁队列中，AQS 选择从后往前（从尾部到头部）唤醒节点的原因如下：

1. **公平性**：从尾部向前唤醒可以保证先进先出（FIFO）的原则，即最早等待的线程优先被唤醒。这有助于实现公平的锁获取顺序。

2. **减少竞争**：在高并发的情况下，多个线程可能会同时尝试获取锁。如果从头部开始唤醒，可能会导致多个线程争抢锁，而实际上只有一个线程能够成功获取锁。从尾部开始唤醒可以减少这种竞争，因为尾部节点是最接近获取锁成功的节点。

3. **减少唤醒成本**：从尾部开始唤醒可以减少不必要的唤醒操作。因为如果从头部开始唤醒，可能需要遍历整个队列来找到合适的唤醒节点，而从尾部开始唤醒只需要找到最近的一个符合条件的节点即可。

### AQS 中的实现细节

在 AQS 的实现中，当一个线程释放锁时，会执行以下步骤：

1. **减少锁状态**：将锁的状态减少，表示锁已被释放。
2. **检查是否需要唤醒**：如果当前没有线程持有锁（锁状态为零），则需要唤醒等待队列中的一个线程。
3. **从尾部向前查找**：找到尾部节点（即最后一个节点），尝试将其转换为头节点，并唤醒对应的线程。

### 示例代码

以下是一个简化的示例，展示了 AQS 中从尾部向前唤醒节点的部分代码：

```java
protected final void setHead(Node oldNode) {
    // 设置当前节点为头节点
    Node h = oldNode.prev;
    if (h == null) {
        // 如果头节点的前驱为空，说明队列中只有一个节点，直接设置头节点为 null
        head = tail = null;
    } else {
        // 否则设置新的头节点，并且清除 head 的前驱指针
        head = h;
        h.next = null;
    }
}

protected final void unparkSuccessor(Node node) {
    // 找到尾部节点
    Node s = node.next;
    if (s == null || s.waitStatus != 0) {
        // 如果尾部节点为空或者状态不正确，则从尾部向前查找第一个状态正确的节点
        s = null;
        for (Node t = tail; t != null && t != node; t = t.prev) {
            if (t.waitStatus <= 0)
                s = t;
        }
    }
    // 唤醒找到的节点
    if (s != null) {
        LockSupport.unpark(s.thread);
    }
}
```

### 总结

AQS 选择从尾部向前唤醒节点的主要原因是出于公平性的考虑，同时减少不必要的唤醒操作，从而提高并发性能。这种设计使得 CLH 锁队列能够在高并发场景下更加高效地工作。


/**/
Aqs唤醒节点时，为何从后往前找aqs唤醒节点的时候，为什么是从后往前去找的？我敢说没看过aqs源码的同学，可能连这个问题都听不懂。Hello大家好，我是菇泡科技的联合创始人麦克，今天给大家分享一下这个问题的回答思路。另外想要文字版本答案的小伙伴，可以在我的评论区置顶中去领取30万字的面试文档。这个文档啊不仅包含了各个一线大厂的常见面试真题，而且对每道题目都进行了详细的解答，能够帮助你们提升80%的面试通过率。这个问题可能很多人听不懂。我先来解释一下这个问题的背景。A QS呢是Java并发编程中一个非常关键的组件，它是用来构建锁和其他同步工具的一个类，内部呢使用了一个双向链表来管理等待锁的线程，对立的投节点呢通常是当前获得所的县城，而其他县城按照请求所的顺序啊排在后面。当获得索的现成释放锁以后，就会唤醒头节点的下一个节点，这是一个正常的实现逻辑，但是呢在源码中多了这样一段代码，如果头节点的下一个节点出现异常，比如说状态不对，或者 a QS的设计呢是从队列的尾部往前去查找，直到找到一个有效的可以被唤醒的节点。
	而这个问题就是考察这部分的逻辑，为什么要从后往前找，而不是继续沿着头节点从前往后找。了解这个问题的背景以后，呢我们再来看一下这个问题的完整回答。关于这个问题我认为可以从两个方面来回答。第一，存储在双向列表中的任意一个位置的线程，都有可能出现县城中断，导致这个县城从队列中去移除。如果从前往后走，那么在并发场景中呢就可能出现一个空的节点的问题，导致无法实现有效的现场唤醒，出现死锁的问题。第二，a QS在初始化同步队列的时候，是先通过这样的代码，先构建指向前驱节点的指针，再通过这样一个代码去构建后继节点的指针。所以在并发场景中，从后往前查找，一定能够找到一个有效的节点。总的来说，a QS在唤醒节点的时候，从后往前走，主要是为了找到一个有效且可以被唤醒的节点，来保证并发程序的效率。以上就是我的理解。我是麦克。感谢大家的点赞和关注，我们下期再见。