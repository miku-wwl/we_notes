在Java Spring框架中，`@Resource` 和 `@Autowired` 是用于依赖注入（Dependency Injection, DI）的注解。尽管它们都可以实现依赖注入，但它们之间存在一些差异：

### @Autowired

`@Autowired` 是Spring框架提供的注解，主要用于自动装配Bean。当使用`@Autowired`时，Spring容器会自动查找并设置Bean的依赖。`@Autowired`可以应用于构造函数、方法、字段或属性的setter方法上。

特点：
- 默认按照类型（byType）进行匹配。
- 可以使用`@Qualifier`注解来指定按名称（byName）装配。
- 支持使用JSR-330标准的`@Inject`注解，后者也是由Spring支持的。
- 如果没有显式设置，则当找不到合适的Bean时，默认行为是抛出异常。
- 适用于配置类、服务类以及其他需要依赖注入的地方。

示例：
```java
public class MyService {
    private Repository repository;

    @Autowired
    public void setRepository(Repository repository) {
        this.repository = repository;
    }
}
```

### @Resource

`@Resource` 是Java的JSR 250规范的一部分，由Java EE平台提供。`@Resource`不仅用于依赖注入，还可以用来访问JNDI资源和其他资源。

特点：
- 默认按照名称（byName）进行匹配。
- 如果没有指定名字，默认使用字段名作为查找的名字。
- 可以通过`name`属性来指定要查找的Bean名称。
- 如果没有显式设置，当找不到合适的Bean时，默认行为是抛出异常。
- 可以用于EJB容器中的资源查找，如DataSource、ConnectionFactory等。

示例：
```java
public class MyService {
    @Resource(name="myRepository")
    private Repository repository;
}
```

### 总结

- **用途**：`@Autowired`主要用于Spring的依赖注入；`@Resource`除了Spring的DI外，还可以用于EJB容器中的资源查找。
- **查找方式**：`@Autowired`默认按类型查找；`@Resource`默认按名称查找。
- **灵活性**：`@Autowired`可以与`@Qualifier`结合使用来指定依赖的具体Bean；而`@Resource`可以通过`lookup`和`name`属性来指定查找的资源。

在实际开发中，两者的选择取决于具体的需求。如果你的应用完全基于Spring框架，`@Autowired`可能是更直观的选择，因为它提供了与Spring框架更好的集成。然而，如果你的应用需要与其他Java EE服务集成，使用`@Resource`可能是更合适的选择。在现代的Spring Boot项目中，通常推荐使用`@Autowired`。

/**/
At resource和at的区别。Hello大家好，我是专注Java干货分享的辉辉。Resource注解和奥特尔的注解都是私营项目中用来进行依赖注入的注解，他们的区别也是最常见的面试题之一。今天我带大家深入了解一下，有很多小伙伴问我有没有好的学习路线图推荐，所以这里我把自己从普通开发成长为架构式的详细学习路径分享给大家，涵盖大厂知识实战项目，千万级流量的架构设计方法等内容，有需要的小伙伴在评论区扣666即可领取。它们的区别主要有两点，第一个来源不一样，resource纾解它是由Java一一提供的，所以它的包是属于Java exo的application，并且它是定义在art包下面，而奥特while的注解它是spring的注解，由spring框架提供的注解。第二个他们的装配方式不一样，这也是他们最主要的区别。比resource注解它默认会根据名称去装配，如果名称没有，它才会根据类型去装配。我们来举个例子，假如现在我有两个对象，一个是灰灰一个是灰灰，他们都实现了ipos的接口，并且加了serves注解，这两个对象都会注入到我们的iOS容器，然后我们通过实现他们的耐乱的这个接口，它会有一个run方法，当我的程序启动以后会去执行run方法的逻辑，现在我通过resource方法去进行依赖注入，我现在想去找到灰灰这个对象打印出来是没有问题的，为什么没有问题呢？
	因为他的名字是灰灰，然后接收的对象也是灰灰，我们去执行，拿到的就是灰灰这个对象。没问题，那么假如你把灰灰这一个名字改成灰灰一，那么他会优先根据名字去加载，所以你加载的是灰灰一，但是如果你用灰灰去接收它是会报错的，我们来执行一下会发现它会报错。为什么报错？呢因为它需要灰灰一来接收，但是呢它是用灰灰来接收的，所以如果你去加载的是灰灰一，那么你必须要用灰一来去接收，所以我们现在第一个结论resource一定是先根据名字去进行查找了。好，如果名字没有，他才会去根据类型，也就是你接受的类型去查找，假如我去写一个不存在的对象灰灰三，灰灰三这个对象是不会在iOS容器的，那么这个时候找不到他会干嘛呢去找灰灰一，所以他拿到的就是灰灰一这个对象。而奥特while的注解他默认是根据类型，如果类型有很多个，那我再根据名字，如果名字还查不到，那么奥特while的注解呢会优先根据类型，我们来举个例子，用out不是right？
	灰灰就算你去定义一个灰灰一的名字，我们可以去看一下，拿到灰灰一，虽然你的名字是灰灰一，但是奥特while的注解是根据类型的，所以他拿到的是灰灰。那么假如说有多个类型就是我去查找的时候，它是一个抽象，它会有很多的实力。假如这个时候我注入的是艾波森这一个接口，这个接口它有两个实现，一个是灰灰，一个是灰灰一，那么我到底拿谁呢？我就会根据名字。假如现在你传的是灰灰一，他拿到的就是灰灰一，假如你这个名字是灰灰，那么拿到的就是灰灰，假如你是拿一个不存在的这一个名字，那么他会报错，因为他不知道根据这个类型去拿什么，你看他已经讲得很清楚了，我不能够去注入，为什么呢它有超过多个实现，那么我不知道去哪一个时限的时候，我必须配合另外一个注解叫qualify来使用，来指定你要去加载哪一个变name去加载灰灰，那么这个时候它就不会报错，并且拿到的是灰灰，如果你指定灰灰一，他拿到的就是灰灰一，今天的内容就分享到这里，如果你有什么问题可以在下方留言，我是灰灰，我们下期再见。